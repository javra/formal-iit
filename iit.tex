Inductive-Inductive Types are specified by giving a context in  a small type
theoretic syntax which we will refer to as \emph{source type theory}.

%TODO add waay more explanation
This idea originates from Ambrus Kaposi's work on the syntax of \emph{higher}
inductive-inductive types (~\cite{ambrussyntax}) which we adapt and rid of equality
constructors to only allow for inductive-inductive types.
In contrast to their presentation we will leave the context of the ambient type
theory implicit and, instead of highlighting syntax of the ambient type theory,
mark elements of the source type theory in \gr{green}.

\section{Signatures for Inductive-Inductive Types}

We assume that the source type theory makes use of the standard syntax of type
theory, using contexts, types, terms, and variables.
Types and terms are uniquely ascribed to one of two \emph{kinds}:
Either their kind is \grm{\Sc} which indicates that the type contains sort
constructors, or their kind is \grm{\Pc} because elements of it describe
point constructors.
We will write \grm{\Gamma \vdash A :: k} to say that \grm{A} is a type of kind
\grm{k} and \grm{\Gamma \vdash t : A :: k} to state that \grm{t} is a term of the
type \grm{A} which in turn has kind \grm{k}.
Often, we will omit the annotation of the sort, meaning that a judgment is to
hold true for both \grm{\Sc} and \grm{\Pc}, or that the kind of a term's type
has already been specified.

It's important that contexts can be extended by sort and point types in any order
(see Example~\ref{ex:tmnil}) to be able to capture sorts which depend on previously
defined point constructors.
So we have the usual two rules for context formation:
\begin{equation*}
\inferrule{}{\grm{\vdash \cdot}}
\qquad
\inferrule{\grm{\Gamma \vdash A :: k}}
  {\grm{\vdash \Gamma, A}}
\end{equation*}

We need one atomic constructor for sort types:
For plain types we and the codomain we need a type \grm{\UU} which serves as a
token for the \emph{universe}.
We will call terms of this universe ``small types''.
Positiviy requires that these are the only (internal) types which are allowed in
the domain of functions.
An operation \grm{\El} reifies these small types to big types, making our version
of universe what is commonly referred to as ``Tarski-style universe'' (cf. ~\cite{luotarski}):
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}{\grm{\Gamma \vdash \UU :: \Sc}}
\qquad
\inferrule{\grm{\Gamma \vdash a : \UU}}{\grm{\Gamma \vdash \El(a) :: \Pc}}
\end{equation*}

For sorts which are type families over other sorts that we seek to define, and for
constructors which recursively refer to other constructors, we need $\Pi$-types
which have a small type as their codomain.
Note that whether we want to build a sort or a point type only depends on the
kind of the \emph{codomain} of such a $\Pi$-type.
To eliminate from $\Pi$-types we want a rule for its \emph{application} which
turns a term of a $\Pi$-type into a term of its codomain:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash a : \UU} \\ 
  \grm{\Gamma, \El(a) \vdash B :: k}}
  {\grm{\Gamma \vdash \Pi(a, B) :: k}}
\qquad
\inferrule{\grm{\Gamma \vdash t : \Pi(a, B)}}
  {\grm{\Gamma, \El(a) \vdash \IIapp(t) : B}}
\end{equation*}

Since we are working with explicit substitutions, we need to postulate a calculus
for substitutions \grm{\IISub{\sigma}{\Gamma}{\Delta}} between any two contexts
\grm{\Gamma} and \grm{\Delta}.
The substitutions should form a category as postulated by the following rules:
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}
  {\grm{\IISub{\id}{\Gamma}{\Gamma}}}
\qquad
\inferrule{\grm{\IISub{\sigma}{\Delta}{\Sigma}} \\
  \grm{\IISub{\delta}{\Gamma}{\Delta}}}
  {\grm{\IISub{\sigma \circ \delta}{\Gamma}{\Sigma}}}
\end{equation*}
\begin{align*}
\grm{\id \circ \sigma} &= \grm{\sigma} \\
\grm{\sigma \circ \id} &= \grm{\sigma} \\
\grm{(\sigma \circ \delta) \circ \gamma} &= \grm{\sigma \circ (\delta \circ \gamma)}
\end{align*}

We can pull back types and terms along substitutions, and these pullbacks are functorial
in the categorical structure:
\begin{equation*}
\inferrule{\grm{\Delta \vdash A :: k} \\
  \grm{\IISub{\sigma}{\Gamma}{\Delta}}}
  {\grm{\Gamma \vdash A[\sigma] :: k}}
\qquad
\inferrule{\grm{\Delta \vdash t : A} \\
  \grm{\IISub{\sigma}{\Gamma}{\Delta}}}
  {\grm{\Gamma \vdash t[\sigma] : A[\sigma]}}
\end{equation*}
\begin{align*}
\grm{A[\id]} &= \grm{A} \\
\grm{A[\sigma \circ \delta]} &= \grm{A[\sigma][\delta]} \\
\grm{t[\id]} &= \grm{t} \\
\grm{t[\sigma \circ \delta]} &= \grm{t[\sigma][\delta]}
\end{align*}

We have a canonical substitution into the empty context and we can extend substitutions
by giving a term in a type bulled back to their domain.
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}
  {\grm{\IISub{\epsilon}{\Gamma}{\cdot}}}
\qquad
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}} \\
  \grm{\Delta \vdash A} \\
  \grm{\Gamma \vdash t : A[\sigma]}}
  {\grm{\IISub{\sigma, t}{\Gamma, A}{\Delta}}}
\end{equation*}
Empty substituition and extension simplify by the following laws:
\begin{align*}
\grm{\sigma} &= \grm{\epsilon}
  &\text{ for all \grm{\IISub{\sigma}{\Gamma}{\cdot}}, and} \\
\grm{(\delta , t) \circ \sigma} &= \grm{(\delta \circ \sigma), t[\sigma]}
  &\text{ for \grm{\IISub{\delta}{\Gamma}{\Delta}}, \grm{\IISub{\sigma}{\Sigma}{\Gamma}}.}
\end{align*}
A substitution into an extended context allows us to project out
a ``shorter`` substitution and a term in the terminal component:
\begin{equation*}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta,A}}}
  {\grm{\IISub{\pi_1(\sigma)}{\Gamma}{\Delta}}}
\qquad
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta,A}}}
  {\grm{\Gamma \vdash \pi_2(\sigma) : A[\pi_1(\sigma)]}} \text{, with}
\end{equation*}
\begin{align*}
\grm{\pi_1(\sigma, t)} &= \grm{\sigma} \text{,} \\
\grm{\pi_2(\sigma, t)} &= \grm{t} \text{, and} \\
\grm{(\pi_1(\sigma), \pi_2(\sigma))} &= \grm{\sigma} \text{.}
\end{align*}
Finally, we also need rules that tell us, how the constructors of the universe
and the $\Pi$-type behave when pulled back along a substitution:
\begin{align*}
\grm{\UU[\sigma]} &= \grm{\UU} \text{,} \\
\grm{\El(a)[\sigma]} &= \grm{\El(a[\sigma])} \text{,} \\
\grm{\Pi(a, B)[\sigma]} &= \grm{\Pi(a[\sigma],B[\sigma \wedge \El(a)])} \text{, and} \\
\grm{\IIapp(t)[\sigma \wedge El(a)]} &= \grm{\IIapp(t[\sigma])} \text{.} %TODO use a better symbol than wedge
\end{align*}

\begin{defn}
Above, \grm{\sigma \wedge A} is one of several auxiliary constructions on the syntax
which are helpful when dealing with substitutions and which can be derived from
the other rules.

The first one is the operation known as \emph{weakening} which for any \grm{\Gamma \vdash A}
gives a substition \grm{\IISub{\wk}{\Gamma, A}{\Gamma}} from the extended into
the original context by \grm{\wk := \pi_1(\id)}.

Likewise, we can apply the second projection to the identity substitution such that
whenever \grm{\Gamma \vdash A}, we have the first \emph{variable} of the context
$\grm{\vz} := \grm{\pi_2(\id)}$ with \grm{\Gamma, A \vdash \vz : A[\wk]}.
Transporting a term \grm{\Gamma \vdash t : A} along the weakening substitution
defined above for any \grm{\Gamma \vdash B}, we get \grm{\Gamma, B : t[\wk] : A[\wk]}.
We will write $\grm{vs(t)} := \grm{t[\wk]}$ for this variable.
Together, \grm{\vz} and \grm{\vs} form \emph{typed de Bruijn indices} to select
variables from a context via numbering them with a zero (\grm{\vz}) and a
successor (\grm{\vs}).

For \grm{\IISub{\sigma}{\Gamma}{\Delta}} and \grm{\Gamma \vdash A} we can
``lift'' \grm{\sigma} along \grm{A} to get a substitution 
\grm{\IISub{\sigma \wedge A}{\Gamma, A[\sigma]}{\Delta, A}}.
This operation can be defined by
\begin{equation*}
\grm{\sigma \wedge A} := \grm{\sigma \circ \wk, \vz(A[\sigma])} \text{.}
\end{equation*}
At last, every term \grm{\Gamma \vdash t : A} gives rise to a substitution
\grm{\IISub{\langle t \rangle}{\Gamma}{\Gamma, A}}, representing the extension
of \grm{\Gamma} by \grm{t}, via
\begin{equation*}
\grm{\langle t \rangle} := \grm{id, t} \text{.}
\end{equation*}
\end{defn}

\begin{defn}[Application]
Most often, we want to use the application of the inductive function type in the
form where we give the function term and its input separately, as in the following
rule:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash f : \Pi(a, B)} \\
  \grm{\Gamma \vdash u : \El(a)}}
  {\grm{\Gamma \vdash f(u) : B[\sigma]}}
\text{,}
\end{equation*}
for some substitution \grm{\sigma}.
Now we know that we can define this substitution by
\begin{equation*}
\grm{f(u)} := \grm{\IIapp(f)[\langle u \rangle]} \text{,}
\end{equation*}
and $\grm{\sigma} = \grm{\langle u \rangle}$.
\end{defn}













