Inductive-Inductive Types are specified by giving a context in  a small type
theoretic syntax which we will refer to as \emph{source type theory}.

%TODO add waay more explanation
This idea originates from Ambrus Kaposi's work on the syntax of \emph{higher}
inductive-inductive types (~\cite{ambrussyntax}) which we adapt and rid of equality
constructors to only allow for inductive-inductive types.
In contrast to their presentation we will leave the context of the ambient type
theory implicit and, instead of highlighting syntax of the ambient type theory,
mark elements of the source type theory in \gr{green}.

\section{Signatures for Inductive-Inductive Types}\label{sec:ii-syntax}

We assume that the source type theory makes use of the standard syntax of type
theory, using contexts, types, terms, and variables.
Types and terms are uniquely ascribed to one of two \emph{kinds}:
Either their kind is \grm{\Sc} which indicates that the type contains sort
constructors, or their kind is \grm{\Pc} because elements of it describe
point constructors.
We will write \grm{\Gamma \vdash A :: k} to say that \grm{A} is a type of kind
\grm{k} and \grm{\Gamma \vdash t : A :: k} to state that \grm{t} is a term of the
type \grm{A} which in turn has kind \grm{k}.
Often, we will omit the annotation of the sort, meaning that a judgment is to
hold true for both \grm{\Sc} and \grm{\Pc}, or that the kind of a term's type
has already been specified.

It's important that contexts can be extended by sort and point types in any order
(see Example~\ref{ex:tmnil}) to be able to capture sorts which depend on previously
defined point constructors.
So we have the usual two rules for context formation:
\begin{equation*}
\inferrule{}{\grm{\vdash \cdot}}
\qquad
\inferrule{\grm{\Gamma \vdash A :: k}}
  {\grm{\vdash \Gamma, A}}
\end{equation*}

We need one atomic constructor for sort types:
For plain types we and the codomain we need a type \grm{\UU} which serves as a
token for the \emph{universe}.
We will call terms of this universe ``small types''.
Positiviy requires that these are the only (internal) types which are allowed in
the domain of functions.
An operation \grm{\El} reifies these small types to big types, making our version
of universe what is commonly referred to as ``Tarski-style universe'' (cf. ~\cite{luotarski}):
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}{\grm{\Gamma \vdash \UU :: \Sc}}
\qquad
\inferrule{\grm{\Gamma \vdash a : \UU}}{\grm{\Gamma \vdash \El(a) :: \Pc}}
\end{equation*}

For sorts which are type families over other sorts that we seek to define, and for
constructors which recursively refer to other constructors, we need $\Pi$-types
which have a small type as their codomain.
To distinguish them from other type formers we will refer to them as
\emph{recursive $\Pi$-types}.
Note that whether we want to build a sort or a point type only depends on the
kind of the \emph{codomain} of such a $\Pi$-type.
To eliminate from $\Pi$-types we want a rule for its \emph{application} which
turns a term of a $\Pi$-type into a term of its codomain:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash a : \UU} \\
  \grm{\Gamma, \El(a) \vdash B :: k}}
  {\grm{\Gamma \vdash \Pi(a, B) :: k}}
\qquad
\inferrule{\grm{\Gamma \vdash f : \Pi(a, B)}}
  {\grm{\Gamma, \El(a) \vdash \IIapp(f) : B}}
\end{equation*}

Additionally, we want sorts to be able to be parameterized by previously defined
types which are not part of the signature itself.
The same goes for point constructors.
Since this cannot be captured using the previous $\Pi$-type, we will do the obvious
and just introduce another type former for this occasion.
We will usuall call it \emph{external} or \emph{non-recursive} function type.
Note that external functions must have a fixed kind.
This is to prevent a function which, depending on the input returns sometimes
a sort and sometimes a point constructor.
\begin{equation*}
\inferrule{T : \UU \\
  (\bltau : T) \to \grm{\Gamma \vdash B(\bltau) :: k}}
  {\grm{\Gamma \vdash \ExtPi{T}{B} :: k}} \\
\qquad
\inferrule{\grm{\Gamma \vdash f : \ExtPi{T}{B}} \\
  \tau : T}
  {\grm{\Gamma \vdash f(\bltau) : B(\bltau)}}
\end{equation*}

Since we are working with explicit substitutions, we need to postulate a calculus
for substitutions \grm{\IISub{\sigma}{\Gamma}{\Delta}} between any two contexts
\grm{\Gamma} and \grm{\Delta}.
The substitutions should form a category as postulated by the following rules:
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}
  {\grm{\IISub{\id}{\Gamma}{\Gamma}}}
\qquad
\inferrule{\grm{\IISub{\sigma}{\Delta}{\Sigma}} \\
  \grm{\IISub{\delta}{\Gamma}{\Delta}}}
  {\grm{\IISub{\sigma \circ \delta}{\Gamma}{\Sigma}}}
\end{equation*}
\begin{align*}
\grm{\id \circ \sigma} &= \grm{\sigma} \\ %TODO change id typesetting
\grm{\sigma \circ \id} &= \grm{\sigma} \\
\grm{(\sigma \circ \delta) \circ \gamma} &= \grm{\sigma \circ (\delta \circ \gamma)}
\end{align*}

We can pull back types and terms along substitutions, and these pullbacks are functorial
in the categorical structure:
\begin{equation*}
\inferrule{\grm{\Delta \vdash A :: k} \\
  \grm{\IISub{\sigma}{\Gamma}{\Delta}}}
  {\grm{\Gamma \vdash A[\sigma] :: k}}
\qquad
\inferrule{\grm{\Delta \vdash t : A} \\
  \grm{\IISub{\sigma}{\Gamma}{\Delta}}}
  {\grm{\Gamma \vdash t[\sigma] : A[\sigma]}}
\end{equation*}
\begin{align*}
\grm{A[\id]} &= \grm{A} \\
\grm{A[\sigma \circ \delta]} &= \grm{A[\sigma][\delta]} \\
\grm{t[\id]} &= \grm{t} \\
\grm{t[\sigma \circ \delta]} &= \grm{t[\sigma][\delta]}
\end{align*}

We have a canonical substitution into the empty context and we can extend substitutions
by giving a term in a type bulled back to their domain.
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}
  {\grm{\IISub{\epsilon}{\Gamma}{\cdot}}}
\qquad
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}} \\
  \grm{\Delta \vdash A} \\
  \grm{\Gamma \vdash t : A[\sigma]}}
  {\grm{\IISub{\sigma, t}{\Gamma, A}{\Delta}}}
\end{equation*}
Empty substituition and extension simplify by the following laws:
\begin{align*}
\grm{\sigma} &= \grm{\epsilon}
  &\text{ for all \grm{\IISub{\sigma}{\Gamma}{\cdot}}, and} \\
\grm{(\delta , t) \circ \sigma} &= \grm{(\delta \circ \sigma), t[\sigma]}
  &\text{ for \grm{\IISub{\delta}{\Gamma}{\Delta}}, \grm{\IISub{\sigma}{\Sigma}{\Gamma}}.}
\end{align*}
A substitution into an extended context allows us to project out
a ``shorter'' substitution and a term in the terminal component:
\begin{equation*}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta,A}}}
  {\grm{\IISub{\pi_1(\sigma)}{\Gamma}{\Delta}}}
\qquad
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta,A}}}
  {\grm{\Gamma \vdash \pi_2(\sigma) : A[\pi_1(\sigma)]}} \text{, with}
\end{equation*}
\begin{align*}
\grm{\pi_1(\sigma, t)} &= \grm{\sigma} \text{,} \\
\grm{\pi_2(\sigma, t)} &= \grm{t} \text{, and} \\
\grm{(\pi_1(\sigma), \pi_2(\sigma))} &= \grm{\sigma} \text{.}
\end{align*}
Finally, we also need rules that tell us, how the constructors of the universe
and the $\Pi$-types behave when pulled back along an arbitrary substitution
\grm{\IISub{\sigma}{\Gamma}{\Delta}}:
\begin{align*}
\grm{\UU[\sigma]} &= \grm{\UU} \text{,} \\
\grm{\El(a)[\sigma]} &= \grm{\El(a[\sigma])} \text{,} \\
\grm{\Pi(a, B)[\sigma]} &= \grm{\Pi(a[\sigma],B[\sigma \wedge \El(a)])} \text{,} \\
\grm{\IIapp(f)[\sigma \wedge El(a)]} &= \grm{\IIapp(f[\sigma])} \text{,} \\ %TODO use a better symbol than wedge
\grm{\ExtPi{T}{B}[\sigma]} &= \grm{\ExtPi{T}{\blm{\lambda \tau. \grm{B(\bltau)[\sigma]}}}} \text{, and} \\
\grm{f(\bltau)[\sigma]} &= \grm{f[\sigma](\bltau)} \text{.}
\end{align*}

\begin{defn}
Above, \grm{\sigma \wedge A} is one of several auxiliary constructions on the syntax
which are helpful when dealing with substitutions and which can be derived from
the other rules.

The first one is the operation known as \emph{weakening} which for any \grm{\Gamma \vdash A}
gives a substition \grm{\IISub{\wk}{\Gamma, A}{\Gamma}} from the extended into
the original context by \grm{\wk := \pi_1(\id)}.

Likewise, we can apply the second projection to the identity substitution such that
whenever \grm{\Gamma \vdash A}, we have the first \emph{variable} of the context
$\grm{\vz} := \grm{\pi_2(\id)}$ with \grm{\Gamma, A \vdash \vz : A[\wk]}.
Transporting a term \grm{\Gamma \vdash t : A} along the weakening substitution
defined above for any \grm{\Gamma \vdash B}, we get \grm{\Gamma, B : t[\wk] : A[\wk]}.
We will write $\grm{\vs(t)} := \grm{t[\wk]}$ for this variable.
Together, \grm{\vz} and \grm{\vs} form \emph{typed de Bruijn indices} to select
variables from a context via numbering them with a zero (\grm{\vz}) and a
successor (\grm{\vs}).

For \grm{\IISub{\sigma}{\Gamma}{\Delta}} and \grm{\Gamma \vdash A} we can
``lift'' \grm{\sigma} along \grm{A} to get a substitution
\grm{\IISub{\sigma \wedge A}{\Gamma, A[\sigma]}{\Delta, A}}.
This operation can be defined by
\begin{equation*}
\grm{\sigma \wedge A} := \grm{\sigma \circ \wk, \vz(A[\sigma])} \text{.}
\end{equation*}
At last, every term \grm{\Gamma \vdash t : A} gives rise to a substitution
\grm{\IISub{\langle t \rangle}{\Gamma}{\Gamma, A}}, representing the extension
of \grm{\Gamma} by \grm{t}, via
\begin{equation*}
\grm{\langle t \rangle} := \grm{id, t} \text{.}
\end{equation*}
\end{defn}

\begin{defn}[Application]
Most often, we want to use the application of the inductive function type in the
form where we give the function term and its input separately, as in the following
rule:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash f : \Pi(a, B)} \\
  \grm{\Gamma \vdash u : \El(a)}}
  {\grm{\Gamma \vdash f(u) : B[\sigma]}}
\text{,}
\end{equation*}
for some substitution \grm{\sigma}.
Now we know that we can define this substitution by
\begin{equation*}
\grm{f(u)} := \grm{\IIapp(f)[\langle u \rangle]} \text{,}
\end{equation*}
and $\grm{\sigma} = \grm{\langle u \rangle}$.
\end{defn}

We will now look at a few example to make it clearer on how to encode inductive-inductive
declarations in the syntax presented above. %TODO more fluff
To see what the different function types are used for, consider the following two
examples:

\begin{example}[Natural numbers]\label{ex:ii-syntax-nat}
The encoding of the natural numbers as would correspond to the
following source type theory context using the first :
\begin{equation*}
\grm{
\cdot,\, \UU,\, \El(\vz),\, \ExtPi{\vs(\vz)}{\El(\vs(\vs(\vz)))}
}\text{.}
\end{equation*}
Often, we will, instead of denoting variables using de~Bruijn indices, use names
as binders in contexts and domains of $\Pi$-types to make example contexts more
legible.
Assuming we always use fresh names, this is not any more imprecise than restricting
ourselves to use \grm{\vz} and \grm{\vz} instead:
\begin{equation*}
\grm{
\cdot,\, \N : \UU,\, 0 : \El(\N),\, \mathop{S} : \ExtPi{n : \N}{\El(\N)}
}\text{.}
\end{equation*}
\end{example}

\begin{example}[Vectors]\label{ex:ii-syntax-vec}
The type of vectors over a type $A : \UU$ can be represented using the ``external''
natural numbers $\N$.
In the following, the constructor \grm{\mathop{cons}} uses both the non-inductive
and the inductive function type:
\begin{equation*}
\begin{gathered}
\grm{ \cdot,\, \mathop{vec} : \ExtPi{\N}{\lambda n.\, \UU},\, \mathop{nil} : \El(\mathop{vec}(\blm{0})),} \\
\grm{ \mathop{cons} : \ExtPi{A}{\blm{\lambda a.\,
  \grm{\ExtPi{\N}{\blm{\lambda n.\, \grm{\Pi(v : \mathop{vec}(\blm{n}),\, \El(\mathop{vec}(\blm{n + 1})))}}}}}}}
\end{gathered}
\end{equation*}
With de-Bruijn indices instead of names the signature \grm{\Gamma_{vec}} would be
\begin{equation*}
\begin{gathered}
\grm{ \cdot,\, \ExtPi{\N}{\lambda n.\, \UU},\, \El(\vz(\blm{0})),} \\
\grm{ \ExtPi{A}{\blm{\lambda a.\,
  \grm{\ExtPi{\N}{\blm{\lambda n.\, \grm{\Pi(\vs(\vz)(\blm{n}),\, \El(\vs(\vs(\vz))(\blm{n + 1})))}}}}}}}
\end{gathered}
\end{equation*}
%An example for a type which uses the third, small function type is the following
%definition of full $\omega$-ary rooted trees:
%\begin{equation*}
%\grm{
%\cdot,\, T : \UU,\, \mathop{leaf} : \underline{T},\,
%	\mathop{node} : (\blm{\N} \to T) \to \underline{T}
%} \text{.}
%\end{equation*}
\end{example}

\begin{example}[Type Theory Syntax]
The example of the syntax of type theory~\ref{ex:ttintt} is represented by the
following signature \grm{\Gamma_{ConTy}}:
\begin{equation*}
\begin{gathered}
\grm{\cdot,\, \mathop{Con} : \UU,\, \mathop{Ty} : \Pi(\Gamma : \mathop{Con},\, \UU),} \\
\grm{\mathop{nil} : \El(\mathop{Con}),} \\
\grm{\mathop{ext} : \Pi(\Gamma : \mathop{Con},\, \Pi(A : \mathop{Ty} ,\, \El(\mathop{Con}))),} \\
\grm{\mathop{unit} : \Pi(\Gamma : \mathop{Con},\, \El(\IIapp(\mathop{Ty}))),} \\
\grm{\mathop{pi} : \Pi(\Gamma : \mathop{Con},\, \Pi(A : \IIapp(\mathop{Ty}),\,
   \Pi(B : ?,\, ?)))} %TODO complete this after doing it in agda
\end{gathered}
\end{equation*}

\end{example}

\section{Algebras of Inductive-Inductive Types}

To give meaning to the codes expressed in the source type theory, we need to
interpret the contexts as a type in the ambient type theory whose elements are
the algebras of of the specified inductive-inductive type.
This means that the interpretation of our contexts must give the types of the
sort and point constructors they specify.

\begin{defn}[Algebra operator] %TODO name?
By structural recursion over the source syntax, we define an operation $-^\CC$
which assigns types to source contexts, fibrations over those to types, sections of
these fibrations to terms, and maps between types to substitutions:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma}}{\grm{\Gamma}^\CC : \UU_1}
\qquad
\inferrule{\grm{\Gamma \vdash A :: \Sc}}{\grm{A}^\CC : \grm{\Gamma}^\CC \to \UU_1}
\qquad
\inferrule{\grm{\Gamma \vdash A :: \Pc}}{\grm{A}^\CC : \grm{\Gamma}^\CC \to \UU_0}
\\[.7em]
\inferrule{\grm{\Gamma \vdash t : A}}
  {\grm{t}^\CC : (\gamma : \grm{\Gamma}^\CC) \to \grm{A}^\CC(\gamma)}
\qquad
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}}}
  {\grm{\sigma}^\CC : \grm{\Gamma}^\CC \to \grm{\Delta}^\CC}
\end{gathered}
\end{equation*}

We will give the construction on contexts, types, subsitutions and terms in the
same order as there were presented in Section~\ref{sec:ii-syntax}.
On contexts, the operation is defined by iterated $\Sigma$-types:
\begin{align*}
\grm{\cdot}^\CC &:\equiv \unit \text{ and} \\
\grm{(\Gamma,\,A)}^\CC &:\equiv (\gamma : \grm{\Gamma}^\CC) \times \grm{A}^\CC(\gamma)
\end{align*}

The universe in the syntax needs of course be mapped to the metatheoretic universe.
We chose $\UU_1$ as a target for context interpretation to make sure $\UU_0$ fits
in there.
The operation \grm{\El} is just there to make the conversation between small and
big types, which in turn is needed to ensure positivity of the constructors.
Since this distinction doesn't have any semantic meaning, \grm{\El} will just be
ignored by the algebra operator:
\begin{align*}
\grm{\UU}^\CC(\gamma) 			&:\equiv \UU_0 \\
\grm{(\El(a))}^\CC(\gamma)		&:\equiv \grm{a}^\CC(\gamma)
\end{align*}
Recursive $\Pi$-types become metatheoretic dependent function spaces, with \grm{\IIapp} the
usual function application:
\begin{align*}
\grm{\Pi(a, B)}^\CC(\gamma)		&:\equiv (\alpha : \grm{a}^\CC(\gamma)) \to \grm{B}^\CC(\gamma, \alpha) \\
\grm{\IIapp(t)}^\CC(\gamma, \alpha)	&:\equiv \grm{t}^\CC(\gamma, \alpha)
\end{align*}
Non-recursive $\Pi$-types also become functions, but here we have to apply the
external argument to the codomain to be able to evaluate its interpretation:
\begin{align*}
\grm{\ExtPi{T}{B}}^\CC(\gamma)		&:\equiv (\tau : T) \to B(\bltau)^\CC(\gamma) \\
\grm{f(\bltau)}^\CC(\gamma)		&:\equiv \grm{f}^\CC(\gamma, \tau)
\end{align*}

Unsurprisingly the category structure of substitution is achieved by interpreting
it into the one of metatheoretic functions between context interpretations:
\begin{align*}
\grm{\id}^\CC(\gamma)			&:\equiv \gamma \\
\grm{(\sigma \circ \delta)}^\CC(\gamma)	&:\equiv \grm{\sigma}^\CC(\grm{\delta}^\CC(\gamma))
\end{align*}
Pulling back a type or a term along a substitution means interpreting it after
applying the function which we get from interpreting the substitution:
\begin{align*}
\grm{A[\sigma]}^\CC(\gamma)		&:\equiv \grm{A}^\CC(\grm{\sigma}^\CC(\gamma)) \\
\grm{t[\sigma]}^\CC(\gamma)		&:\equiv \grm{t}^\CC(\grm{\sigma}^\CC(\gamma))
\end{align*}
The interpretation of the empty substitution is the unique map into the interpretation
of the empty context.
Extension of and projections from a substitution now justify their name by being
interpreted as the extension of a function and the projections of a $\sigma$-type:
\begin{align*}
\grm{\epsilon}^\CC(\gamma)		&:\equiv \star \\
\grm{(\sigma, t)}^\CC(\gamma)		&:\equiv (\grm{\sigma}^\CC(\gamma), \grm{t}^\CC(\gamma)) \\
\grm{\pi_1(\sigma)}^\CC(\gamma)		&:\equiv \pr_1(\grm{\sigma}^\CC(\gamma)) \\
\grm{\pi_2(\sigma)}^\CC(\gamma)		&:\equiv \pr_2(\grm{\sigma}^\CC(\gamma))
\end{align*}

All the rules of the substitution calculus which were mentioned in Section~\ref{sec:ii-syntax}
are preserved \emph{definitionally}, which, in the end, is due to types and
functions forming a \emph{strict} category. %TODO more explanation here

%\begin{align*}
%\grm{(t \app \blm{u})}^\CC(\gamma)	&:\equiv (\grm{t}^\CC(\gamma))(u) \text{.}
%\end{align*}

\end{defn}

\begin{example}[Natural numbers]
Strictly speaking, the algebra interpretation of the
context from our example of natrual numbers (Example~\ref{ex:ii-syntax-nat})
would compute to the following iterated $\Sigma$-type:
\begin{equation*}
\grm{\left(N' : (N : \top \times \UU) \times \pr_2(N)\right)
  \times \left(\pr_2(\pr_1(N')) \to \pr_2(\pr_1(N')) \right) } \text{.}
\end{equation*}
Obviously, this is unnecessarily complicated and we can easily transform this
type using equivalences to see that we can also express the algebras as being
elements of the type
\begin{equation*}
\grm{(N : \UU) \times N \times (N \to N)} \text{.}
\end{equation*}
\end{example}

%TODO more examples

\section{Morphisms of Algebras}

%TODO

%\section{Displayed Algebras and Sections}

%TODO

%\section{Existence of Inductive-Inductive Types}

%TODO

%\section{Initiality implies Elimination}

%TODO: use sigma construction for this, cite whoever's done this first








