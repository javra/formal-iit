Inductive-Inductive Types are specified by giving a context in  a small type
theoretic syntax which we will refer to as \emph{source type theory}.

%TODO add waay more explanation
This idea originates from Ambrus Kaposi's work on the syntax of \emph{higher}
inductive-inductive types (~\cite{ambrussyntax}) which we adapt and rid of equality
constructors to only allow for inductive-inductive types.
In contrast to their presentation we will leave the context of the ambient type
theory implicit and, instead of highlighting syntax of the ambient type theory,
mark elements of the source type theory in \gr{green}.

\section{Signatures for Inductive-Inductive Types}

We assume that the source type theory makes use of the standard syntax of type
theory, using contexts, types, terms, and variables.
Types and terms are uniquely ascribed to one of two \emph{kinds}:
Either their kind is \grm{\Sc} which indicates that the type contains sort
constructors, or their kind is \grm{\Pc} because elements of it describe
point constructors.
We will write \grm{\Gamma \vdash A :: k} to say that \grm{A} is a type of kind
\grm{k} and \grm{\Gamma \vdash t : A :: k} to state that \grm{t} is a term of the
type \grm{A} which in turn has kind \grm{k}.
Often, we will omit the annotation of the sort, meaning that a judgment is to
hold true for both \grm{\Sc} and \grm{\Pc}, or that the kind of a term's type
has already been specified.

It's important that contexts can be extended by sort and point types in any order
(see Example~\ref{ex:tmnil}) to be able to capture sorts which depend on previously
defined point constructors.
So we have the usual two rules for context formation:
\begin{equation*}
\inferrule{}{\grm{\vdash \cdot}}
\qquad
\inferrule{\grm{\Gamma \vdash A :: k}}
  {\grm{\vdash \Gamma, A}}
\end{equation*}

We need one atomic constructor for sort types:
For plain types we and the codomain we need a type \grm{\UU} which serves as a
token for the \emph{universe}.
We will call terms of this universe ``small types''.
Positiviy requires that these are the only (internal) types which are allowed in
the domain of functions.
An operation \grm{\El} reifies these small types to big types, making our version
of universe what is commonly referred to as ``Tarski-style universe'' (cf. ~\cite{luotarski}):
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}{\grm{\Gamma \vdash \UU :: \Sc}}
\qquad
\inferrule{\grm{\Gamma \vdash a : \UU}}{\grm{\Gamma \vdash \El(a) :: \Pc}}
\end{equation*}

For sorts which are type families over other sorts that we seek to define, and for
constructors which recursively refer to other constructors, we need $\Pi$-types
which have a small type as their codomain.
Note that whether we want to build a sort or a point type only depends on the
kind of the \emph{codomain} of such a $\Pi$-type.
To eliminate from $\Pi$-types we want a rule for its \emph{application} which
turns a term of a $\Pi$-type into a term of its codomain:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash a : \UU} \\ 
  \grm{\Gamma, \El(a) \vdash B :: k}}
  {\grm{\Gamma \vdash \Pi(a, B) :: k}}
\qquad
\inferrule{\grm{\Gamma \vdash t : \Pi(a, B)}}
  {\grm{\Gamma, \El(a) \vdash \IIapp(t) : B}}
\end{equation*}

Since we are working with explicit substitutions, we need to postulate a calculus
for substitutions \grm{\IISub{\sigma}{\Gamma}{\Delta}} between any two contexts
\grm{\Gamma} and \grm{\Delta}.
The substitutions should form a category as postulated by the following rules:
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}
  {\grm{\IISub{\id}{\Gamma}{\Gamma}}}
\qquad
\inferrule{\grm{\IISub{\sigma}{\Delta}{\Sigma}} \\
  \grm{\IISub{\delta}{\Gamma}{\Delta}}}
  {\grm{\IISub{\sigma \circ \delta}{\Gamma}{\Sigma}}}
\end{equation*}
\begin{align*}
\grm{\id \circ \sigma} &= \grm{\sigma} \\
\grm{\sigma \circ \id} &= \grm{\sigma} \\
\grm{(\sigma \circ \delta) \circ \gamma} &= \grm{\sigma \circ (\delta \circ \gamma)}
\end{align*}









