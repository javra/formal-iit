%TODO's as per thorsten july 9
%* code snippet besser teasern 

As we have already seen in the last chapter, sometimes it is helpful to allow
point constructors of a collection of inductive types to be \emph{mutually dependent}.
This means that to define several sorts simultaneously whose point constructors
may refer to the other types being defined.
We will refer to this class as \emph{inductive families}, though others might
call them, for example, mutual inductive types.
Inductive families are a class of inductive types which at first glance seems more
powerful than indexed W-types but less than inductive-inductive types --
sorts are \emph{not} allowed to depend on other sorts but only point constructors.

Previous specifications of mutual inductive families have taken different approaches:
Some are based on the notion of a polynomial functor
\citep{indexedcontainers, dybjer1999finite}
while others, like
the original \citet{dybjer94} description are based on a schematic description.


\section{Signatures for Inductive Families}

Applying the same principle as in the case of inductive-inductive types we want
to create a specification based on the contexts of type theory syntax.
We could imagine that we can obtain such a specification by just restricting the
syntax for inductive-inductive types to not use the recursive $\Pi$-type for sorts,
but this approach doesn't capture the full %TODO
extent of inductive families being a much simpler concept than inductive-inductive
types.
Given the strategy of our reduction we want the specification to capture at least
the following features of inductive families:
\begin{itemize}
\item Sorts are either types or functions over existing types.
\item Point constructors can also be indexed over existing (``external'') types.
\item Point constructors can refer to any sort being defined.
\end{itemize}

We will use {\color{Blue}blue font} to distinguish the new syntax from the ambient
type theory.
The first point above says that we want the \emph{sort types} \blm{\tqm{\Sc}}
to be inductively generated by a \emph{universe} token and a constructor
of external functions for sorts which are meant to be \emph{type families}:
\begin{equation*}
\begin{gathered}
\inferrule{ }{\tqm{\UU :: \Sc}}
\qquad
\inferrule{T : \UU \\ \tqm{B : \blm{T \to \tqm{\Sc}}}}{\tqm{\ExtPiS{T}{B :: \Sc}}}
\end{gathered}
\end{equation*}
For example, the sort of vectors over a type $A : \UU$ would be described by
\tqm{\ExtPiS{A}{\ExtPiS{\N}{\UU}}}.
Note that in contrast to the sort types of inductive-inductive definitions these
do not depend on a context.

Instead, we say that a \emph{sort context} is just a list of sort types without
any interdependencies:
\begin{equation*}
\begin{gathered}
\inferrule{}{\tqm{\SCon \cdot_\Sc}}
\qquad
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{B :: \Sc}}{\tqm{\SCon \Gamma_\Sc, B}}
\end{gathered}
\end{equation*}

In order to refer to sorts we introduce a simplified term calculus based on typed
de Bruijn indices for bound variables and an application operation for type families:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{B :: \Sc}}{\tqm{\Gamma_\Sc, B \SCon \var(\vz) : B}}
\qquad
\inferrule{\tqm{\Gamma_\Sc \SCon \var(v) : B}}{\tqm{\Gamma_\Sc, B' \SCon \var(\vs(v)) : B}}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon t : \ExtPiS{T}{B}} \\ \blm{\tau : T}}
  {\tqm{\Gamma_\Sc \SCon t(\blm{\tau}) : B(\blm{\tau})}}
\end{gathered}
\end{equation*}

Point constructors will be represented by \emph{point types} over a given sort
context.
This means that in contrast to inductive-inductive types, they cannot depend on
other point types.
The type formers we need are the element type for the universe \tqm{\UU}, an
external, non-recursive function type like the one we have for sorts, and an
internal function type used for recursive point constructors -- which are
\emph{non-dependent} since point constructors only depend on the \emph{sort context}:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma_\Sc \SCon a : \UU}}{\tqm{\Gamma_\Sc \SCon \El(a)}}
\qquad
\inferrule{\blm{T : \UU} \\ \blm{(\tau : T) \to \tqm{\Gamma_\Sc \SCon B(\blm{\tau})}}}
  {\tqm{\Gamma_\Sc \SCon \ExtPiP{T}{B}}}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon a : \UU} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\Gamma_\Sc \SCon a \Rightarrow_\Pc A}}
\end{gathered}
\end{equation*}

As a last building block of the syntax, we can now form contexts consisting
of point constructors over a given sort context.
Such a context \tqm{\Gamma} can be formed over a given sort context \tqm{\Gamma_\Sc}
which we will denote as a subscript to the turnstile or omit when inferrable.
%The empty context can be formed over the empty sort context, an extension of
%a context by a sort constructor happens in parallel to an extension of its sort
%context, and an extension by a point constructor leaves the sort context fixed:
The empty context can be formed over any sort context, and an extension by a point
constructor leaves the sort context fixed:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc}}{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
%\inferrule{}{\tqm{\vdash_{\cdot_\Sc} \cdot}}
\qquad
%\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{B : \Sc}}
%  {\tqm{\vdash_{\Gamma_\Sc, B} \Gamma, B}}
%\qquad
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\vdash_{\Gamma_\Sc} \Gamma, A}}
\end{gathered}
\end{equation*}

\begin{example}[Natural numbers, Vectors]\label{ex:if-natvec}
A common example for inductive types, the natural numbers, with one constructor for
zero and one for the successor function, are represented by the sort context
\tqm{\cdot_\Sc,\, \UU} and the points
\begin{equation*}
\tqm{\El(\var(\vz)), \var(\vz) \Rightarrow_\Pc \El(\var(\vz))} \text{.}
\end{equation*}

An example of a real indexed type would be the type family of vectors over a fixed
type \blm{A : \UU} which is defined over the sort context
\tqm{\cdot_\Sc,\, \ExtPiS{n : \N}{\UU}} by
\begin{equation*}
\begin{gathered}
\tqm{\cdot, \El(\var(\vz)(\blm{0})),}\\
\tqm{\ExtPiP{a : A}{\ExtPiP{n : \N}{\var(\vz)(\blm{n}) \Rightarrow_\Pc \El(\var(\vz)(\blm{n + 1}))}}} \text{.}
\end{gathered}
\end{equation*}

An easy example with non-trivial mutual dependency between the point constructors
is the predicate of evenness and oddness on natural numbers: The sorts are
represented by \tqm{\cdot_\Sc, \Pi_\Sc(\blm{\N}, \blm{\lambda n. \tqm{\UU}}), \Pi_\Sc(\blm{\N}, \blm{\lambda n. \tqm{\UU}})}
and the point constructors by
\begin{equation*}
\begin{gathered}
\tqm{\cdot , \El(\var(\vs(\vz))(\blm{0})),} \\
\tqm{\ExtPiP{n : \N}{\var(\vz)(\blm{n}) \Rightarrow_\Pc \El(\var(\vs(\vz))(\blm{n + 1}))},} \\
\tqm{\ExtPiP{n:\N}{\var(\vs(\vz))(\blm{n}) \Rightarrow_\Pc \El(\var(\vz)(\blm{n + 1}))}} \text{.}
\end{gathered}
\end{equation*}
Here, the first sort constructor represents evenness, the second one oddness,
the first point constructor the proof that \blm{0} is even and the other two the
proof that evenness implies oddness of the successor and vice versa.
\end{example}

\begin{defn}[Sort Substitutions]\label{def:if-sort-subs}
One component of the syntax which has completely gone missing are substitutions.
Since we cant refer to previous point constructors, we certainly don't need them
for the point contexts.
But since we also got rid of sort interdependencies, we could reduce the recursive
function types on points to a non-depenent one and thus don't need to use
substitutions in the definition of application.
It will still be helpful for syntax transformations to use substitutions
of the sort contexts which we define as generated by
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\IFSub{\epsilon}{\Gamma_\Sc}{\cdot_\Sc}}}
\quad\text{and}\quad
\inferrule{\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}} \\ 
  \tqm{\Gamma_\Sc \SCon t : B}}
  {\tqm{\IFSub{\sigma, t}{\Gamma_\Sc}{(\Delta_\Sc, B)}}}
\text{.}
\end{gathered}
\end{equation*}
These then allow us to substitute point types, point contexts, and sort terms via
the following ``pullback'' operations:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Delta_\Sc \SCon A} \\
  \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\Gamma_\Sc \SCon A[\sigma]}}
\qquad
\inferrule{\tqm{\Delta_\Sc \SCon t : B} \\
  \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\Gamma_\Sc \SCon t[\sigma] : B}}
\\[.7em]
\inferrule{\tqm{\vdash_{\Delta_\Sc} \Delta} \\
  \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\vdash_{\Gamma_\Sc} \Delta[\sigma]}}
\end{gathered}
\end{equation*}
given by the defining rules for substitution
\begin{align*}
\tqm{\ExtPiP{T}{A}[\sigma]}			&= \tqm{\ExtPiP{T}{\blm{\lambda \tau.\, \tqm{A(\blm{\tau})[\sigma]}}}} \text{,} \\
\tqm{\El(a)[\sigma]}				&= \tqm{\El(a[\sigma])} \text{,} \\
\tqm{(a \Rightarrow_\Pc A)[\sigma]}		&= \tqm{a[\sigma] \Rightarrow_\Pc A[\sigma]} \text{,} \\
\tqm{\var(\vz)[\sigma, t]}			&= \tqm{t} \text{,} \\
\tqm{\var(\vs(t))[\sigma, s]}			&= \tqm{\var(t)[\sigma]} & \text{ for \tqm{\Delta_\Sc \SCon \var(t) : B},} \\
\tqm{f(\bltau)[\sigma]}				&= \tqm{f[\sigma](\bltau)} & \text{ for \tqm{\Delta_\Sc \SCon f : \ExtPiS{T}{B}},}\\
\tqm{\cdot[\sigma]}				&= \tqm{\cdot} \text{, and} \\
\tqm{(\Gamma,\, A)[\sigma]}			&= \tqm{(\Gamma[\sigma],\, A[\sigma])} \text{.}
\end{align*}

We can derive from this the gadgets of the substitutional calculus which we
are already acquainted with from the syntax of inductive-inductive Types:
We can define the \emph{weakening} of a subsitution
\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}} to 
\tqm{\IFSub{\wk_\sigma}{\Gamma_\Sc, B}{\Delta_\Sc}} via recursion on \tqm{\sigma} by
\begin{align*}
\tqm{\wk_\epsilon} 				&:\equiv \tqm{\epsilon} \text{ and} \\
\tqm{\wk_{\sigma, t}}				&:\equiv \tqm{(\wk_\sigma, \vs(t))} \text{.}
\end{align*}
Using \tqm{\wk}, we can then recover the categorical structure of the substitutions
by defining the identity \tqm{\IFSub{\id_{\Gamma_\Sc}}{\Gamma_\Sc}{\Gamma_\Sc}}
by recursion of the context \tqm{\Gamma_\Sc}:
\begin{align*}
\tqm{\id_{(\cdot_\Sc)}}				&:\equiv \tqm{\epsilon} \text{ and} \\
\tqm{\id_{\Gamma_\Sc,\, B}}			&:\equiv \tqm{(\wk_{\id_{\Gamma_\Sc}},\, \vz)} \text{.}
\end{align*}
Composition \tqm{\IFSub{\sigma \circ \delta}{\Gamma_\Sc}{\Sigma_\Sc}} of substitutions
\tqm{\IFSub{\sigma}{\Delta_\Sc}{\Sigma_\Sc}} and \tqm{\IFSub{\delta}{\Gamma_\Sc}{\Delta_\Sc}}
is defined by recursion on the first context:
\begin{align*}
\tqm{\epsilon \circ \delta}			&:\equiv \tqm{\epsilon} \text{,} \\
\tqm{(\sigma, t) \circ \delta}			&:\equiv \tqm{(\sigma \circ \delta, t[\delta])} \text{.}
\end{align*}
Projections \tqm{\IFSub{\pi_1(\sigma)}{\Gamma_\Sc}{\Delta_\Sc}} and
\tqm{\Gamma_\Sc \SCon \pi_2(\sigma) : B} of a substitution
\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc, B}} can be defined as just that --
projections.
Any substitution between \tqm{\Gamma_\Sc} and \tqm{\Delta_\Sc,\, B} is of the form
\tqm{\sigma,\, t} and we can just set
\begin{align*}
\tqm{\pi_1(\sigma,\, t)}				&:\equiv \tqm{\sigma} \text{ and} \\
\tqm{\pi_2(\sigma,\, t)}				&:\equiv \tqm{t} \text{.}
\end{align*}
\end{defn}

%TODO address equalities

\section{Algebras of Inductive Families}\label{sec:if-alg}

Like for inductive-inductive types, we have to give a way to semantify the signatures
by stating what kind of data they should represent.

\begin{defn}[Algebra operator]
Again, sort contexts will be mapped to types, sort constructors to families over these
types, their terms to sections of these families.
Point contexts will give the same data, but depending on an interpretation of the sort
contexts:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{B :: \Sc}}
  {\tqm{B}^\CC : \UU}
\qquad
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\Gamma_\Sc}^\CC : \UU}
\qquad
\inferrule{\tqm{\Gamma_\Sc \SCon t : B :: \Sc}}
  {\tqm{t}^\CC : \tqm{\Gamma_\Sc}^\CC \to \tqm{B}^\CC}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon A :: \Pc}}
  {\tqm{A}^\CC : \tqm{\Gamma_\Sc}^\CC \to \UU}
\qquad
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
  {\tqm{\Gamma}^\CC : \UU}
\end{gathered}
\end{equation*}

Going through all of these translation in order, we first define the algebras
of sorts to be interpreted into functions over the universe:
\begin{align*}
\tqm{\UU}^\CC				&:\equiv \UU \\
\tqm{\ExtPiS{T}{B}}^\CC			&:\equiv (\tau : T) \to \tqm{B(\bltau)}^\CC
\end{align*}
Sort contexts become iterated product types -- note that we don't even need to
use $\Sigma$-types since there are no dependencies between sorts:
\begin{align*}
\tqm{\cdot_\Sc}^\CC			&:\equiv \unit \\
\tqm{(\Gamma_\Sc,\, B)}^\CC		&:\equiv \tqm{\Gamma_\Sc}^\CC \times \tqm{B}^\CC
\end{align*}
We use terms to navigate these iterated product via iterated projects, and to
apply function sorts:
\begin{align*}
\tqm{\var(\vz)}^\CC(\gamma, \alpha)	&:\equiv \alpha \\
\tqm{\var(\vs(t))}^\CC(\gamma, \alpha)	&:\equiv \tqm{\var(t)}^\CC(\gamma) \\
\tqm{t(\bltau)}^\CC(\gamma)		&:\equiv \tqm{t}^\CC(\gamma)(\bltau)
\end{align*}
For point constructors, we need to interpret both types of functions into functions
while erasing the element operator, since it does not have any semantic meaning:
\begin{align*}
\tqm{\El(a)}^\CC(\gamma)		&:\equiv \tqm{a}^\CC(\gamma) \\
\tqm{\ExtPiP{T}{A}}^\CC(\gamma)		&:\equiv (\tau : T) \to \tqm{A(\bltau)}^\CC(\gamma) \\
\tqm{(a \Rightarrow_\Pc A)}^\CC(\gamma)	&:\equiv \tqm{a}^\CC(\gamma) \to \tqm{A}^\CC(\gamma)
\end{align*}
Just like for the sort contexts, point contexts are interdependency-free lists
of point constructors and as such can be interpreted as simple products instead
of $\Sigma$-types:
\begin{align*}
\tqm{\cdot}^\CC(\gamma)			&:\equiv \unit \\
\tqm{(\Gamma,\, A)}^\CC(\gamma)		&:\equiv \tqm{\Gamma}^\CC(\gamma) \times \tqm{A}^\CC(\gamma)
\end{align*}
\end{defn}

\begin{example}[Natural numbers]
Looking at the signature of the natural numbers from Example~\ref{ex:if-natvec},
we see that the algebra interpretation of its sort context evaluates to
\begin{equation*}
\unit \times \UU
\end{equation*}
and given an element \blm{(\star, N) : \unit \times \UU}, the algebras of its
point contexts, evaluated at this point result in
\begin{equation*}
N \times (N \to N) \text{.}
\end{equation*}
%TODO vector example?
\end{example}

In the previous section, we introduced a substition calculus for the sort contexts.
Obviously, we might also want to consider algebras over these substitutions.

\begin{defn}[Algebras of substitutions]\label{def:if-alg-sub}
We can extend the algebra operator by defining it on substitutions by functions
between the interpretations of sort contexts:
\begin{equation*}
\inferrule{\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\sigma}^\CC : \tqm{\Gamma_\Sc}^\CC \to \tqm{\Gamma_\Sc}^\CC}
\end{equation*}
This is done by setting
\begin{align*}
\tqm{\epsilon}^\CC		&:\equiv \star \text{ and}\\
\tqm{(\sigma,\, t)}^\CC		&:\equiv (\tqm{\sigma}^\CC , \tqm{t}^\CC) \text{.}
\end{align*}
\end{defn}

\begin{lemma}
It's easy to check that this definition of algebras of a subtitution respects
the substitution calculus given in Definition~\ref{def:if-sort-subs} in the following
sense:
\begin{align*}
\tqm{A[\sigma]}^\CC(\gamma)		&= \tqm{A}^\CC(\tqm{\sigma}^\CC(\gamma)) \text{,} \\
\tqm{t[\sigma]}^\CC(\gamma)		&= \tqm{t}^\CC(\tqm{\sigma}^\CC(\gamma)) \text{,} \\
\tqm{\id}^\CC(\gamma)			&= \gamma \text{,} \\
\tqm{(\sigma \circ \delta)}^\CC(\gamma)	&= \tqm{\sigma}^\CC(\tqm{\delta}^\CC(\gamma)) \text{,} \\
\tqm{\wk_\sigma}^\CC(\gamma, \alpha)	&= \tqm{\sigma}^\CC(\gamma) \text{,} \\
\tqm{\pi_1(\sigma)}^\CC(\gamma)		&= \pr_1(\tqm{\sigma}^\CC(\gamma)) \text{, and } \\
\tqm{\pi_2(\sigma)}^\CC(\gamma)		&= \pr_2(\tqm{\sigma}^\CC(\gamma)) \text{.}
\end{align*}
\end{lemma}
\begin{proof}
We can prove the first rule by recursion on the point type \tqm{\Gamma_\Sc \SCon A :: \Pc},
the second rule by recursing on the term \tqm{\Gamma_\Sc \SCon t : B :: \Sc},
the third by induction on the context,
and all other by induction by the substitution.
\end{proof}

%Note that we never introduced substitutions between point constructors.
%While we don't need them to specify inductive families, they are still
%a useful tool, especially on the level of algebras.
%
%\begin{defn}[Point Substitution Algebras]\label{def:if-alg-lsub}
%For a sort substitution \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}} we can
%define a type of \emph{lifted point substitution algebras} $\LSub{\sigma}{\Gamma}{\Delta}$ between
%point contexts \tqm{\vdash_{\Gamma_\Sc} \Gamma} and
%\tqm{\vdash_{\Delta_\Sc} \Delta} inductively as generated by
%\begin{align*}
%\epsilon		&: \LSub{\sigma}{\Gamma}{\cdot} \text{ and} \\
%(\sigma_\Pc,\, \phi)	&: \LSub{\sigma}{\Gamma}{(\Delta,\, A)} \text{,}
%\end{align*}
%for $\sigma_\Pc : \LSub{\sigma}{\Gamma}{\Delta}$ and
%$\phi : \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\} \left(\gamma : \tqm{\Gamma}^\CC(\gamma_\Sc)\right) \to \tqm{A}^\CC(\sigma^\CC(\gamma_\Sc))$.
%\end{defn}

%TODO define calculus for lifted subs

\section{Displayed Algebras and their Sections}\label{sec:if-ds}

To represent the dependent eliminator, we need algebras which vary over other
algebras.
To get a feeling about what these should look like, let us first look at our
usual simplest example:

\begin{example}\label{ex:if-ds-nat}
Take algebras \blm{(\star, N) : \unit \times \UU} and
\blm{(\star, z, s) : \unit \times N \times (N \to N)} of
the the signature of natural numbers (Example~\ref{ex:if-natvec}).
A \emph{displayed algebra} over this should contain the data which the dependent
eliminator of the natural numbers takes as input:
A type family \blm{P : N \to \UU} together with a point \blm{p_z : P(z)}
and a family of functions \blm{p_s : (n : N) \to P(n) \to P(s(n))}.

A \emph{section} of this algebra would be a section \blm{f : (n : N) \to P(n)} of
\blm{P} respecting the other data by ensuring that \blm{f(z) = p_z}
and that for all \blm{n : N}, we have \blm{f(s(n)) = p_s(f(n))}.
%TODO add another example
\end{example}

Let's first concentrate on the first piece of data:
\begin{defn}[Displayed Algebra Operator]\label{def:if-ds}
As seen above, we want to map sorts to type families over the given algebra.
Sort context will likewise be type families over an algebra:
\begin{equation*}
\inferrule{\tqm{B :: \Sc}}
  {\tqm{B}^\DD : \tqm{B}^\CC \to \UU}
\qquad
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\Gamma_\Sc}^\DD : \tqm{\Gamma_\Sc}^\CC \to \UU}
\end{equation*}
Since sorts can themselves be interpreted as functions, we have to apply them
whenever we encounter a sort function.
Sort contexts will again be interpreted as iterated products.
\begin{align*}
\tqm{\UU}^\DD(\alpha)				&:\equiv \alpha \to \UU \\
\tqm{\ExtPiS{T}{B}}^\DD(\alpha)			&:\equiv (\tau : T) \to \tqm{B(\bltau)}^\DD(\alpha(\bltau)) \\
\tqm{\cdot_\Sc}^\DD(\star)			&:\equiv \unit \\
\tqm{(\Gamma_\Sc,\, B)}^\DD(\gamma, \alpha)	&:\equiv \tqm{\Gamma}^\DD(\gamma) \times \tqm{B}^\DD(\alpha)
\end{align*}

The interpretation of point constructors and of point contexts now not only depends
on the algebra, but also on the interpretation of the underlying sorts:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma_\Sc \SCon A :: \Pc}}
  {\tqm{A}^\DD : \{\gamma : \tqm{\Gamma_\Sc}^\CC\} \to \tqm{\Gamma_\Sc}^\DD(\gamma) 
    \to \tqm{A}^\CC(\gamma) \to \UU }
\\[.7em]
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
  {\tqm{\Gamma}^\DD : \{\gamma : \tqm{\Gamma_\Sc}^\CC\} \to \tqm{\Gamma_\Sc}^\DD(\gamma)
    \to \tqm{\Gamma}^\CC(\gamma) \to \UU }
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon t : B :: \Sc}}
  {\tqm{t}^\DD : \{\gamma : \tqm{\Gamma_\Sc}^\CC\} \to \tqm{\Gamma_\Sc}^\DD(\gamma)
    \to \tqm{B}^\DD(\tqm{t}^\CC(\gamma)) }
\end{gathered}
\end{equation*}
The definition on terms is almost the same as for fixed algebras:
\begin{align*}
\tqm{\var(\vz)}^\DD(\gamma^\DD, \alpha^\DD)
  &:\equiv \alpha^\DD \text{,} \\
\tqm{\var(\vs(t))}^\DD(\gamma^\DD, \alpha^\DD)
  &:\equiv \tqm{\var(t)}^\DD(\gamma^\DD) \text{, and} \\
\tqm{f(\bltau)}^\DD(\gamma^\DD)
  &:\equiv \tqm{f}^\DD(\gamma^\DD)(\tau) \text{.}
\end{align*}
Displayed algebras on point constructors are defined fiberwise, like the ones for
sorts:
\begin{align*}
\tqm{\El(a)}^\DD(\gamma_\Sc^\DD, \alpha)
  &:\equiv \tqm{a}^\DD(\gamma_\Sc^\DD, \alpha) \\
\tqm{\ExtPiP{T}{A}}^\DD(\gamma_\Sc^\DD, \pi)
  &:\equiv (\tau : T) \to \tqm{A(\bltau)}^\DD(\gamma_\Sc^\DD, \pi(\tau)) \\
\tqm{(a \Rightarrow_\Pc A)}^\DD(\gamma_\Sc^\DD, \pi)
  &:\equiv \{\alpha : \tqm{a}^\CC(\gamma_\Sc) \} \to \tqm{a}^\DD(\gamma_\Sc^\DD, \alpha)
    \to \tqm{A}^\DD(\gamma_\Sc^\DD, \pi(\alpha))
\end{align*}
Finally, point contexts are interpreted as iterated products again:
\begin{align*}
\tqm{\cdot}^\DD(\gamma_\Sc^\DD, \gamma)
  &:\equiv \unit \\
\tqm{(\Gamma,\, A)}^\DD(\gamma_\Sc^\DD, (\gamma, \alpha))
  &:\equiv \tqm{\Gamma}^\DD(\gamma_\Sc^\DD, \gamma) \times \tqm{A}^\DD(\gamma_\Sc^\DD, \alpha)
\end{align*}
\end{defn}

%TODO section fluff
\begin{defn}[Section Operator]
For sorts and sort contexts, we want the sections of a displayed algebra to be
the sections of the type family they represent:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{B :: \Sc}}
  {\tqm{B}^\SS : \{\alpha : \tqm{B}^\CC\} \to \tqm{B}^\DD(\alpha) \to \UU}
\\[.7em]
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\Gamma_\Sc}^\SS : \{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\} \to 
    \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc) \to \UU }
\end{gathered}
\end{equation*}
Both follow the structure of the underlying displayed algebra -- fibrewise for
sort functions and by iterated products on sort contexts:
\begin{align*}
\tqm{\UU}^\SS(\alpha^\DD)
  &:\equiv (x : \alpha) \to \alpha^\DD(x) \\
\tqm{\ExtPiS{T}{B}}^\SS(\pi^\DD)
  &:\equiv (\tau : T) \to \tqm{B(\bltau)}^\SS(\pi^\DD(\tau)) \\
\tqm{\cdot_\Sc}(\gamma_\Sc^\DD)
  &:\equiv \unit \\
\tqm{(\Gamma_\Sc, B)}^\SS(\gamma_\Sc^\DD, \alpha^\DD)
  &:\equiv \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD) \times \tqm{B}^\SS(\alpha^\DD)
\end{align*}

Sections of point constructors, point contexts, and sort terms will clearly
have to depend on a section of the underlying sort interpretation:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma_\Sc \SCon A :: k} \\
  \gamma_\Sc : \tqm{\Gamma_\Sc}^\CC \\
    \gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc) \\
    \gamma_\Sc^\SS : \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD)  }
  {\tqm{A}^\SS(\gamma_\Sc^\SS) : 
    \left\{\alpha : \tqm{A}^\CC(\gamma_\Sc)\right\}
    \left(\alpha^\DD : \tqm{A}^\DD(\gamma_\Sc^\DD, \alpha)\right)
    \to \UU }
\\[.7em]
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\
  \gamma_\Sc : \tqm{\Gamma_\Sc}^\CC \\
    \gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc) \\
    \gamma_\Sc^\SS : \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD) } 
  {\tqm{\Gamma}^\SS(\gamma_\Sc^\SS) : 
    \left\{\gamma : \tqm{\Gamma}^\CC(\gamma_\Sc)\right\}
    \left(\gamma^\DD : \tqm{\Gamma}^\DD(\gamma_\Sc^\DD, \gamma)
    \to \UU \right)}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon t : B :: \Sc} \\
    \gamma_\Sc : \tqm{\Gamma_\Sc}^\CC \\
    \gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc) \\
    \gamma_\Sc^\SS : \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD) }
  {\tqm{t}^\SS(\gamma_\Sc^\SS) : \tqm{B}^\SS\left(\tqm{t}^\DD(\gamma_\Sc^\DD)\right)}
\end{gathered}
\end{equation*}
For point types we again descent fibrewise, but what to do about the element
operator?
This is where the equations which we have seen in Example~\ref{ex:if-ds-nat}
come into play:
The element which we get out of the interpretation of the section must coincide
with the one we provided by giving the displayed algebra:
\begin{align*}
\tqm{\El(a)}^\SS(\gamma_\Sc^\SS, \alpha^\DD)
  &:\equiv \left(\tqm{a}^\SS(\gamma_\Sc^\SS, \alpha) = \alpha^\DD  \right) \\
\tqm{\ExtPiP{T}{A}}^\SS(\gamma_\Sc^\SS, \pi^\DD)
  &:\equiv (\tau : T) \to \tqm{A(\bltau)}^\SS(\gamma_\Sc^\SS, \pi^\DD(\tau)) \\
\tqm{(a \Rightarrow_\Pc A)}^\SS(\gamma_\Sc^\SS, \pi^\DD)
  &:\equiv (\alpha : \tqm{a}^\CC(\gamma_\Sc))
    \to \tqm{A}^\SS\left(\gamma_\Sc^\SS, \pi^\DD(\tqm{a}^\SS(a, \gamma_\Sc^\SS)(\alpha))\right)
\end{align*}
The definition of sections of point contexts is easier as it is, again,
just an iteration of products:
\begin{align*}
\tqm{\cdot}^\SS(\gamma_\Sc^\SS, \gamma^\DD)
  &:\equiv \unit \\
\tqm{(\Gamma,\, A)}^\SS(\gamma_\Sc^\SS, (\gamma^\DD, \alpha^\DD))
  &:\equiv \tqm{\Gamma}^\SS(\gamma_\Sc^\SS, \gamma^\DD)
    \times \tqm{A}^\SS(\gamma_\Sc^\SS, \alpha^\DD)
\end{align*}
At last, also terms follow the usual pattern of variables selecting sort interpretations
via projections of products and interpreting the application by metatheoretic application:
\begin{align*}
\tqm{\var(\vz)}^\SS(\gamma_\Sc^\SS, \alpha^\SS)
  &:\equiv \alpha^\SS \\
\tqm{\var(\vs(t))}^\SS(\gamma_\Sc^\SS, \alpha^\SS)
  &:\equiv \tqm{\var(t)}^\SS(\gamma_\Sc^\SS) \\
\tqm{f(\bltau)}^\SS(\gamma_\Sc^\SS)
  &:\equiv \tqm{f}^\SS(\gamma_\Sc^\SS)(\tau)
\end{align*}
\end{defn}

Later on, we will need that, following Definition~\ref{def:if-alg-sub}, we can
interpret sort substitutions with the means of displayed algebras, for which
we also need a definition of a section:
\begin{defn}[Displayed Algebras of Substitutions]
Given a sort substitution, its type of displayed algebras should be the type
of function between the displayed algebras of its domain and codomain, where in the
latter we have to apply the function which we get from the \emph{algebra} over
the substitution:
\begin{equation*}
\inferrule{\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\sigma}^\DD :
    \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\}
    \to \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc)
    \to \tqm{\Delta_\Sc}^\DD(\tqm{\sigma}^\CC(\gamma_\Sc))}
\end{equation*}
These are defined, like in the non-displayed case, by
\begin{align*}
\tqm{\epsilon}^\DD(\gamma_\Sc^\DD)
  &:\equiv \star \text{ and} \\
\tqm{(\sigma,\, t)}^\DD(\gamma_\Sc^\DD)
  &:\equiv \left(\tqm{\sigma}^\DD(\gamma_\Sc^\DD), \tqm{t}^\DD(\gamma_\Sc^\DD)\right) \text{.}
\end{align*}
\end{defn}

\begin{defn}[Sections of Substitutions]\label{def:if-ds-sub}
A section of a displayed algebra of a sort substitution is supposed to map
sections of its domain to sections of its codomain:
\begin{equation*}
\inferrule{\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\sigma}^\SS :
    \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\}
    \left\{\gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc)\right\}
    \to \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD)
    \to \tqm{\Delta_\Sc}^\SS(\tqm{\sigma}^\DD(\gamma_\Sc^\DD)) }
\end{equation*}
Again, this is happening componentwise:
\begin{align*}
\tqm{\epsilon}^\SS(\gamma_\Sc^\SS)
  &:\equiv \star \text{ and} \\
\tqm{(\sigma,\, t)}^\SS(\gamma_\Sc^\SS)
  &:\equiv \left(\tqm{\sigma}^\SS(\gamma_\Sc^\SS), \tqm{t}^\SS(\gamma_\Sc^\SS) \right) \text{.}
\end{align*}
\end{defn}

\section{Existence of Inductive Families}\label{sec:if-ex}

Having a specification for Inductive Families is not worth much if there is no
way to know what it means for a type theory to actually ``support'' types of this
specification.
The intended meaning of the signatures is clear from the definition of their algebras
as seen in \Cref{sec:if-alg} and as discussed in \Cref{sec:if-ds},
candidates for their eliminators and computation rules are specified in the definition
of sections displayed algebras.
This means that we can formally say what it means for inductive
families to exist in a type theory.
In this section, we will prove that any metatheory as premised in \Cref{sec:if-ex}
actually supports inductive families as specified here.
Since we make heavy use of indexed W-types, we can also see this endeavour as
\emph{reducing} inductive families to indexed W-types.

\begin{thm}[Existence of Inductive Families]\label{thm:if-ex}
For every signature of inductive families given by a sort context \tqm{\SCon \Omega_\Sc}
and a point context \tqm{\vdash_{\Omega_\Sc} \Omega}, there are are sort and point
\emph{constructors} in the form of
\begin{align*}
\IFconS{\Omega}		&: \tqm{\Omega_\Sc}^\CC \text{ and} \\
\IFcon{\Omega}		&: \tqm{\Omega}^\CC(\IFconS{\Omega})
\end{align*}
such that for each displayed algebra given by motives $\omega_\Sc^\DD : \tqm{\Omega_\Sc}^\DD(\IFconS{\Omega})$
and methods $\omega^\DD : \tqm{\Omega}^\DD(\omega_\Sc^\DD, \IFcon{\Omega})$
we can prove an \emph{eliminator} by the means of giving sections
\begin{align*}
\IFelimS{\Omega}{\omega^\DD}	&: \tqm{\Omega_\Sc}^\SS(\omega_\Sc^\DD) \text{ with} \\
\IFelim{\Omega}{\omega^\DD}	&: \tqm{\Omega}^\SS(\IFelimS{\Omega}{\omega^\DD}, \omega^\DD) \text{.}
\end{align*}
\end{thm}

Our strategy to prove this theorem is to first extend
our syntax with elements that have been missing: terms and substitutions for
point types.
For the extended syntax, we will than show that indexed W-types allow us
to find an \emph{internal representation} of the syntax (\Cref{sec:if-internal})
and then
construct a \emph{term model} using the internalization, which we can then
show to be the initial algebra (\Cref{sec:if-termmodel}).

\subsection{Internalization of the Syntax}\label{sec:if-internal}

At first, we will need to make up for some of the
short cuts and simplifications in our definition of signatures.
In the theory of semantics of type theory, which studies various models of different
type theories, the model which is initial in the category of all models
is usually called the \emph{term model}.
This is because in this model, a type get interpreted as the set of all of its
terms.
Since our signatures form -- or are at least strongly
inspired by -- a type theoretic syntax as well, we might hope to deploy the same
strategy for inductive families.
In the core of this interpretation is the issue of how to find an interpretation
for a given sort term \tqm{a} of the universe token \tqm{\UU}.
The interpretation of this ought to be the terms of the \emph{point type}
\tqm{\El(a)} associated with this sort term.
But our syntax does not mention terms of point types at all, since point constructor
are not interdependent!
So our solution is to retrofit the theory with terms, as well as substitutions
for the point contexts:

\begin{defn}[Point Substitution Calculus]\label{def:if-ex-subp}
Let us fix a sort context \tqm{\SCon {\Gamma_\Sc}}.
In total, there are four ways to construct reasonable terms of point types
in \tqm{\Gamma_\Sc}:
Via two constructors for de-Bruijn indices to navigate point contexts and
by an application constructor for each of the two kinds of $\Pi$-type present in
the syntax.
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\Gamma,\, A \vdash \var(\vz) : A :: \Pc}}
\qquad
\inferrule{\tqm{\Gamma_\Sc \SCon A} \\ \tqm{\Gamma_\Sc \SCon A'} \\
  \tqm{\Gamma \vdash \var(t) : A :: \Pc}}
  {\tqm{\Gamma,\, A' \vdash \var(\vs(t)) : A :: \Pc}}
\\[.7em]
\inferrule{\tqm{\Gamma \vdash f : (a \Rightarrow_\Pc A)} \\
  \tqm{\Gamma  \vdash t : \El(a)}}
  {\tqm{\Gamma \vdash f(t) : A :: \Pc}}
\\[.7em]
\inferrule{\tqm{\Gamma \vdash f : \ExtPiP{T}{A}} \\ \tau : T}
  {\tqm{\Gamma \vdash f(\bltau) : A(\bltau) :: \Pc}}
\end{gathered}
\end{equation*}
Like with the sort substitutions defined in \Cref{def:if-sort-subs}, we
define substitutions between point contexts over a fixed sort context
\tqm{\SCon \Gamma_\Sc} to be lists of point terms:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
  {\tqm{\IFSub{\epsilon_\Pc}{\Gamma}{\cdot}}}
\qquad
\inferrule{\tqm{\IFSub{\sigma_\Pc}{\Gamma}{\Delta}} \\
  \tqm{\Gamma \vdash t : A :: \Pc}}
  {\tqm{\IFSub{\sigma_\Pc,\, t}{\Gamma}{\Delta,\, A}}}
\end{gathered}
\end{equation*}
We can again define a pullback operation for terms -- this time for point terms --
along substitutions in the form of
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Delta \vdash_{\Gamma_\Sc} t : A :: \Pc} \\
  \tqm{\IFSub{\sigma_\Pc}{\Gamma}{\Delta}}}
  {\tqm{\Gamma \vdash_{\Gamma_\Sc} t[\sigma] : A :: \Pc}}
\end{gathered}
\end{equation*}
which is recursively defined by
\begin{align*}
\tqm{\var(\vz)[\sigma_\Pc,\, t_\Pc]}
  &:\equiv \tqm{t_\Pc} \text{,} \\
\tqm{\var(\vs(v_\Pc))[\sigma_\Pc,\, t_\Pc]}
  &:\equiv \tqm{\var(v_\Pc)[\sigma_\Pc]} \text{,} \\
\tqm{f(t)[\sigma_\Pc]}
  &:\equiv \tqm{f[\sigma_\Pc](t[\sigma_\Pc]) } \text{, and} \\
\tqm{f(\bltau)[\sigma_\Pc]}
  &:\equiv \tqm{f[\sigma_\Pc](\bltau)} \text{.}
\end{align*}
Analogously to \ref{def:if-sort-subs} we can define the weakening
\tqm{\IFSub{\wk_{\sigma_\Pc}}{\Gamma,\,A}{\Delta}} of a point substitution
\tqm{\IFSub{\sigma_\Pc}{\Gamma}{\Delta}} along a point type \tqm{\Gamma_\Sc \SCon A :: \Pc},
the identity substitution \tqm{\IFSub{\id_\Pc}{\Gamma}{\Gamma}}, and
the Composition \tqm{\IFSub{\sigma_\Pc \circ \delta_\Pc}{\Gamma}{\Sigma}} of substitutions
\tqm{\IFSub{\sigma_\Pc}{\Delta}{\Sigma}} and \tqm{\IFSub{\delta_\Pc}{\Gamma}{\Delta}}
causing the analogous effect when being used to pullback point terms:
\begin{align*}
\tqm{t_\Pc[\wk_{\sigma_\Pc}]}
  &= \tqm{\vs(t_\Pc[\sigma_\Pc])} \\
\tqm{t_\Pc[\id]}
  &= \tqm{t_\Pc} \\
\tqm{t_\Pc[\sigma_\Pc \circ \delta_\Pc]}
  &= \tqm{t_\Pc[\sigma_\Pc][\delta_\Pc]}
\end{align*}
\end{defn}

As an auxiliary construction for our existence proof we will furthermore need
notions of algebra, displayed algebras, and sections for the point terms and
point substitutions:

\begin{defn}[Algebras of Point Substitutions \& Terms]\label{def:if-ex-psub-a}
We can give semantic meaning to point types and point substitution by extending
the algebra operator with the following components, all over a fixed sort
context \tqm{\SCon \Gamma_\Sc}:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma \vdash_{\Gamma_\Sc} t_\Pc : A :: \Pc}}
  {\tqm{t_\Pc}^\CC :
   \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\} \to \tqm{\Gamma}^\CC(\gamma_\Sc) \to
   \tqm{A}^\CC(\gamma_\Sc)}
\\[.7em]
\inferrule{\tqm{\IFSub{\sigma_\Pc}{\Gamma}{\Delta}}}
  {\tqm{\sigma_\Pc}^\CC :
    \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\}
    \to \tqm{\Gamma}^\CC(\gamma_\Sc)
    \to \tqm{\Delta}^\CC(\gamma_\Sc)}
\end{gathered}
\end{equation*}
These components are, in essence, defined as iterated tuples and projections.
For point terms, these defining equations are
\begin{align*}
\tqm{\var(\vz)}^\CC(\gamma, \alpha)
  &:\equiv \alpha \text{,} \\
\tqm{\var(\vs(t))}^\CC(\gamma, \alpha)
  &:\equiv \tqm{\var(t)}^\CC(\gamma) \text{,} \\
\tqm{f(t)}^\CC(\gamma)
  &:\equiv \tqm{f}^\CC(\gamma)(\tqm{t}^\CC(\gamma)) \text{, and} \\
\tqm{f(\bltau)}^\CC(\gamma)
  &:\equiv \tqm{f}^\CC(\gamma)(\tau) \text{,}
\end{align*}
while for point contexts we have the usual
\begin{align*}
\tqm{\epsilon_\Pc}^\CC(\gamma)
  &:\equiv \star \text{ and} \\
\tqm{(\Gamma,\, A)}^\CC(\gamma)
  &:\equiv \left(\tqm{\Gamma}^\CC(\gamma), \tqm{A}^\CC(\gamma)\right) \text{.}
\end{align*}
Of course, apart from these defining equations, this definition of algebras is also
well-behaved under the other components of substitutional calculus:
\begin{align*}
\tqm{t_\Pc[\sigma_\Pc]}^\CC(\gamma)
  &= \tqm{t_\Pc}^\CC(\tqm{\sigma_\Pc}^\CC(\gamma)) \text{,} \\
\tqm{\vs(t_\Pc)}^\CC(\gamma, \alpha)
  &= \tqm{t_\Pc}^\CC(\gamma) \text{,} \\
\tqm{\wk_{\sigma_\Pc}}^\CC(\gamma, \alpha)
  &= \tqm{\sigma_\Pc}^\CC(\gamma) \text{,} \\
\tqm{\id_\Pc}^\CC(\gamma)
  &= \gamma \text{, and} \\
\tqm{(\sigma_\Pc \circ \delta_\Pc)}^\CC(\gamma)
  &= \tqm{\sigma_\Pc}^\CC(\tqm{\delta_\Pc}^\CC(\gamma)) \text{.}
\end{align*}
\end{defn}

\begin{defn}[Displayed Algebras of Point Terms \& Subsitutions]\label{def:if-ex-psub-ds}
Let us for this definition fix a sort context \tqm{\SCon \Gamma_\Sc} with an
algebra \tqm{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC} as well as a displayed
algebra \tqm{\gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc)} over \tqm{\gamma_\Sc}.
For the displayed version of these algebras, the interpretation of point terms
and of point substitutions needs to depend on these and, additionally, on
an algebra and displayed algebra of the underlying point context.
This leads to the addition of the following rules:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma \vdash_{\Gamma_\Sc} t_\Pc : A :: \Pc}}
  {\tqm{t_\Pc}^\DD :
    \left\{\gamma : \tqm{\Gamma}^\CC(\gamma_\Sc) \right\}
    \to \tqm{\Gamma}^\DD(\gamma_\Sc^\DD, \gamma)
    \to \tqm{A}^\DD(\gamma_\Sc^\DD, \tqm{t_\Pc}^\CC(\gamma))}
\\[.7em]
\inferrule{\tqm{\IFSub{\sigma_\Pc}{\Gamma}{\Delta}}}
  {\tqm{\sigma_\Pc}^\DD :
    \left\{\gamma : \tqm{\Gamma}^\CC(\gamma_\Sc) \right\}
    \to \tqm{\Gamma}^\DD(\gamma_\Sc^\DD, \gamma) 
    \to \tqm{\Delta}^\DD(\gamma_\Sc^\DD, \tqm{\sigma_\Pc}^\CC(\gamma))}
\end{gathered}
\end{equation*}
We define them by setting
\begin{align*}
\tqm{\var(\vz)}^\DD(\gamma^\DD, \alpha^\DD)
  &:\equiv \alpha^\DD \text{,} \\
\tqm{\var(\vs(t_\Pc))}^\DD(\gamma^\DD, \alpha^\DD)
  &:\equiv \tqm{\var(t_\Pc)}^\DD(\gamma^\DD) \text{,} \\
\tqm{f_\Pc(t_\Pc)}^\DD(\gamma^\DD)
  &:\equiv \tqm{f_\Pc}^\DD(\gamma^\DD)\left(\tqm{t_\Pc}^\CC(\gamma),\, \tqm{t_\Pc}^\DD(\gamma^\DD)\right) \text{, and} \\
\tqm{f_\Pc(\bltau)}^\DD(\gamma^\DD)
  &:\equiv \tqm{f_\Pc}^\DD(\gamma^\DD)(\tau) \text{ for terms, and} \\
\tqm{\epsilon_\Pc}^\DD(\gamma^\DD)
  &:\equiv \star \text{ and} \\
\tqm{(\sigma_\Pc,\, t_\Pc)}^\DD(\gamma^\DD)
  &:\equiv \left(\tqm{\sigma_\Pc}^\DD(\gamma^\DD), \tqm{t_\Pc}^\DD(\gamma^\DD) \right) \text{ for point substitutions.}
\end{align*}
Again, substitution rules analogous to the ones in \ref{def:if-ex-psub-a} hold:
\begin{align*}
\tqm{t_\Pc[\sigma_\Pc]}^\DD(\gamma^\DD)
  &= \tqm{t_\Pc}^\DD(\tqm{\sigma_\Pc}^\DD(\gamma^\DD)) \text{,} \\
\tqm{\vs(t_\Pc)}^\DD(\gamma^\DD, \alpha^\DD)
  &= \tqm{t_\Pc}^\DD(\gamma^\DD) \text{,} \\
\tqm{\wk_{\sigma_\Pc}}^\DD(\gamma^\DD, \alpha^\DD)
  &= \tqm{\sigma_\Pc}^\DD(\gamma^\DD) \text{,} \\
\tqm{\id_\Pc}^\DD(\gamma^\DD)
  &= \gamma^\DD \text{, and} \\
\tqm{(\sigma_\Pc \circ \delta_\Pc)}^\DD(\gamma^\DD)
  &= \tqm{\sigma_\Pc}^\DD(\tqm{\delta_\Pc}^\DD(\gamma^\DD)) \text{.}
\end{align*}
\end{defn}

%\begin{defn}[Sections of Point Terms \& Substitutions]
%I'm not sure if we need these...
%\end{defn}

As a next step after having extended our syntax and defined the semantics of this
extension, we will show that any type theory with indexed W-types is able
to represent the whole syntax for inductive families internally.

\begin{remark}\label{rmk:if-impl}
While for the signatures of inductive-inductive types, contexts, types, and terms
depend on each other, we can here define sort types, sort contexts, terms, point
types, and contexts in the presented order without referring to later constructions.
This means that unlike mentioned in \Cref{rmk:iit-qit}, we  can
internalize this syntax just using inductive families, as shown in the
following agda implementation:
\begin{agdacodebr}
data TyS : Set₁ where
  U  : TyS
  Π̂S : (T : Set) → (T → TyS) → TyS

data ConS : Set₁ where
  ∙c   : ConS
  _▶c_ : ConS → TyS → ConS

data VarS : ConS → TyS → Set₁ where
  vvz : ∀{Γc B} → Var (Γc ▶c B) B
  vvs : ∀{Γc B B'} → Var Γc B → Var (Γc ▶c B') B

data TmS (Γc : ConS) : TyS → Set₁ where
  var  : ∀{A} → Var Γc A → TmS Γc A
  _@S_ : ∀{T B} → TmS Γc (Π̂S T B) → (τ : T) → TmS Γc (B τ)

data TyP (Γc : ConS) : Set₁ where
  El   : TmS Γc U → TyP Γc
  Π̂P   : (T : Set) → (T → TyP Γc) → TyP Γc
  _⇒P_ : TmS Γc U → TyP Γc → TyP Γc

data Con (Γc : ConS) : Set₁ where
  ∙    : Con Γc
  _▶P_ : Con Γc → TyP Γc → Con Γc
\end{agdacodebr}
Note, that in the implementaion, variables and terms are defined in separate
types to allow for \tqm{\var(v)} to appear as a premise for the introduction rule
for \tqm{\vs(v)}.
The extension of the syntax by sort substitutions of Definition~\ref{def:if-sort-subs}
as well as the subsequent extension by point terms and point substitutions as presented in
Definition~\ref{def:if-ex-subp} is implementable as well:
\begin{agdacodebr}
data SubS : ConS → ConS → Set₁ where
  ε   : ∀{Γc} → SubS Γc ∙c
  _,_ : ∀{Γc Δc B} → SubS Γc Δc → TmS Γc B → SubS Γc (Δc ▶c B)

data VarP {Γc} : Con Γc → TyP Γc → Set₁ where
  vvzP : ∀{Γ A} → VarP (Γ ▶P A) A
  vvsP : ∀{Γ A B} → VarP Γ A → VarP (Γ ▶P B) A

data TmP {Γc}(Γ : Con Γc) : TyP Γc → Set₁ where
  varP : ∀{A} → VarP Γ A → TmP Γ A
  _@P_ : ∀{a A} → TmP Γ (a ⇒P A) → TmP Γ (El a) → TmP Γ A
  _^@P_ : ∀{T A} → TmP Γ (Π̂P T A) → (τ : T) → TmP Γ (A τ)

data SubP {Γc} : Con Γc → Con Γc → Set₁ where
  εP   : ∀{Γ} → SubP Γ ∙
  _,P_ : ∀{Γ Δ A} → SubP Γ Δ → TmP Γ A → SubP Γ (Δ ▶P A)
\end{agdacodebr}
\end{remark}

To make this proof of internalizability formal, we will present the exact definition
of all the parts of the extended syntax as indexed W-types.
This means giving a type ${Con_\Sc} : \UU$ of sort contexts,
a type ${Ty_\Sc} : \UU$ of sort types,
a family ${Var_\Sc} : {Con_\Sc} \to {Ty_\Sc} \to \UU$ of variables of a given
sort context and sort type,
extending the latter, a family $W_{Tm_\Sc} : {Con_\Sc} \to {Ty_\Sc} \to \UU$
of sort terms,
a family ${Ty_\Pc} : {Con_\Sc} \to \UU$ of point types in a given sort context,
and finally a type ${Con_\Pc} : {Con_\Sc} \to \UU$ of point contexts over a
given sort context.
Afterwards, we will give the same treatment to the extensions with
sort substitutions between two sort contexts, with variables
of a point type, terms of a point type and point substitution between two point
contexts over the same sort context in the form of
\begin{align*}
{Sub_\Sc}
  &: {Con_\Sc} \to {Con_\Sc} \to \UU \text{,} \\
{Var_\Pc}
  &: \{\Gamma_\Sc : {Con_\Sc}\} \to {Con_\Pc}(\Gamma_\Sc) \to {Ty_\Pc}(\Gamma_\Sc) \to \UU \text{,}\\
{Tm_\Pc}
  &: \{\Gamma_\Sc : {Con_\Sc}\} \to {Con_\Pc}(\Gamma_\Sc) \to {Ty_\Pc}(\Gamma_\Sc) \to \UU \text{, and}\\
{Sub_\Pc}
  &: \{\Gamma_\Sc : {Con_\Sc}\} \to {Con_\Pc}(\Gamma_\Sc) \to {Con_\Pc}(\Gamma_\Sc) \to \UU \text{.}
\end{align*}
In the following definition we will give all of these ten types and type families
in general by giving the respective input data for indexed W-types as described
in Chapter~\ref{sec:tt-w}.

\begin{defn}[IF-Syntax as W-Types]
We define the types mentioned above as follows:
\begin{align*}
\begin{split}
{Ty_\Sc}
  &:\equiv \IW{A_{Ty_\Sc}}{B_{Ty_\Sc}}{o_{Ty_\Sc}}{r_{Ty_\Sc}}(\star) \text{,} \\
{Con_\Sc}
  &:\equiv \IW{A_{Con_\Sc}}{B_{Con_\Sc}}{o_{Con_\Sc}}{r_{Con_\Sc}}(\star) \text{,} \\
{Var_\Sc}(\_, B)
  &:\equiv \IW{A_{Var_\Sc}(B)}{B_{Var_\Sc}(B)}{o_{Var_\Sc}(B)}{r_{Var_\Sc}(B)} \text{,} \\
W_{Tm_\Sc}(\Gamma_\Sc)
  &:\equiv \IW{A_{Tm_\Sc}(\Gamma_\Sc)}{B_{Tm_\Sc}(\Gamma_\Sc)}{o_{Tm_\Sc}(\Gamma_\Sc)}{r_{Tm_\Sc}(\Gamma_\Sc)} \text{,} \\
{Sub_\Sc}(\Gamma_\Sc)
  &:\equiv \IW{A_{Sub_\Sc}(\Gamma_\Sc)}{B_{Sub_\Sc}(\Gamma_\Sc)}{o_{Sub_\Sc}(\Gamma_\Sc)}{r_{Sub_\Sc}(\Gamma_\Sc)} \text{,}
\end{split}
\begin{split}
{Ty_\Pc}(\Gamma_\Sc)
  &:\equiv \IW{A_{Ty_\Pc}}{B_{Ty_\Pc}}{o_{Ty_\Pc}}{r_{Ty_\Pc}}(\star) \text{,} \\
{Con_\Pc}(\Gamma_\Sc)
  &:\equiv \IW{A_{Con_\Pc}}{B_{Con_\Pc}}{o_{Con_\Pc}}{r_{Con_\Pc}}(\star) \text{,} \\
{Var_\Pc}(\_, A)
  &:\equiv \IW{A_{Var_\Pc}(A)}{B_{Var_\Pc}(A)}{o_{Var_\Pc}(A)}{r_{Var_\Pc}(A)} \text{,} \\
{Tm_\Pc}(\Gamma)
  &:\equiv \IW{A_{Tm_\Pc}(\Gamma)}{B_{Tm_\Pc}(\Gamma)}{o_{Tm_\Pc}(\Gamma)}{r_{Tm_\Pc}(\Gamma)} \text{,} \\
{Sub_\Pc}(\Gamma)
  &:\equiv \IW{A_{Sub_\Pc}(\Gamma)}{B_{Sub_\Pc}(\Gamma)}{o_{Sub_\Pc}(\Gamma)}{r_{Sub_\Pc}(\Gamma)} \text{,}
\end{split}
\end{align*}
where the respective indices for the indexed W-types are given in Table~\ref{tbl:if-iws}.
\end{defn}

\begin{sidewaystable}\label{tbl:if-iws}
\centering
{\footnotesize$\begin{array}{r|lllll}
i & I_i : \UU & A_i : \UU & B_i : A_i \to \UU & o_i : A_i \to I_i & r_i : (a : A_i) \to B_i(a) \to I_i \\
\hline
Ty_\Sc
  & \unit
  & \makecell[cl]{\unit \\ + \UU}
  & \makecell[cl]{\inl(\star) \mapsto \emptytype \\ \inr(T) \mapsto T}
  & \_ \mapsto \star
  & \_ \mapsto \star \\
Con_\Sc
  & \unit
  & \makecell[cl]{\unit \\ + {Ty_\Sc}}
  & \makecell[cl]{\inl(\star) \mapsto \emptytype \\ \inr(B) \mapsto \unit}
  & \_ \mapsto \star
  & \_ \mapsto \star \\
Var_\Sc
  & {Con_\Sc}
  & \makecell[cl]{{Con_\Sc} \\ + {Con_\Sc} \times W_{Ty_{\Sc}} }
  & \makecell[cl]{\inl(\Gamma_\Sc) \mapsto \emptytype \\ \inr(\Gamma_\Sc, B') \mapsto \unit}
  & \makecell[cl]{\inl(\Gamma_\Sc) \mapsto \tqm{(\Gamma_\Sc,\,B)} \\ \inr(\Gamma_\Sc, B') \mapsto \tqm{(\Gamma_\Sc,\,B')} }
  & \makecell[cl]{ - \\ \inr(\Gamma_\Sc, B')(\star) \mapsto \Gamma_\Sc } \\
Tm_\Sc(\Gamma_\Sc)
  & {Ty_\Sc}
  & \makecell[cl]{{Ty_\Sc} \\ + (T : \UU) \times (T \to {Ty_\Sc}) \times T }
  & \makecell[cl]{\inl(B) \mapsto \emptytype \\ \inr(\_) \mapsto \unit}
  & \makecell[cl]{\inl(B) \mapsto \emptytype \\ \inr(T, B, \tau) \mapsto B(\tau) }
  & \makecell[cl]{ - \\ \inr(T, B, \tau)(\star) \mapsto \tqm{\ExtPiS{T}{B}} } \\
Sub_\Sc(\Gamma_\Sc)
  & \unit
  & \makecell[cl]{\unit \\ + (B : {Ty_\Sc}) \times W_{Tm_\Sc}(\Gamma_\Sc, B) }
  & \makecell[cl]{\inl(\star) \mapsto \emptytype \\ \inr(B, t) \mapsto \unit }
  & \_ \mapsto \star
  & \_ \mapsto \star \\
Ty_\Pc(\Gamma_\Sc)
  & \unit
  & \makecell[cl]{W_{Tm_\Sc}(\Gamma, \tqm{\UU}) \\ + \UU \\ + W_{Tm_\Sc}(\Gamma, \tqm{\UU})}
  & \makecell[cl]{\inl(a) \mapsto \emptytype \\ \inr(\inl(\tau)) \mapsto T \\ \inr(\inr(a)) \mapsto \unit }
  & \_ \mapsto \star
  & \_ \mapsto \star \\
Con_\Pc(\Gamma_\Sc)
  & \unit
  & \makecell[cl]{\unit \\ + W_{Ty_{\Pc}(\Gamma_\Sc)} }
  & \makecell[cl]{\inl(\star) \mapsto \emptytype \\ \inr(A) \mapsto \unit}
  & \_ \mapsto \star
  & \_ \mapsto \star \\
Var_\Pc(A)
  & {Con_\Pc}(\Gamma_\Sc)
  & \makecell[cl]{{Con_\Pc}(\Gamma_\Sc) \\ + {Con_\Pc}(\Gamma_\Sc) \times {Ty_\Pc}(\Gamma_\Sc)}
  & \makecell[cl]{\inl(\Gamma) \mapsto \emptytype \\ \inr(\Gamma, A') \mapsto \unit}
  & \makecell[cl]{\inl(\Gamma) \mapsto \tqm{(\Gamma,\,A)} \\ \inr(\Gamma,A') \mapsto \tqm{(\Gamma,\,A')}}
  & \makecell[cl]{ - \\ \inr(\Gamma, A')(\star) \mapsto \Gamma} \\
Tm_\Pc(\Gamma)
  & {Ty_\Pc}(\Gamma_\Sc)
  & \makecell[cl]{(A : {Ty_\Pc}(\Gamma_\Sc)) \times {Var_\Pc}(\Gamma, A)}
  & \makecell[cl]{\inl(A, v) \mapsto \emptytype \\ \inr(\inl(\_)) \mapsto \twotype \\ \\ \inr(\inr(\_)) \mapsto \unit }
  & \makecell[cl]{\inl(A, v) \mapsto A          \\ \inr(\inl(A, a)) \mapsto A      \\ \\ \inr(\inr(T, A, \tau)) \mapsto A(\tau)}
  & \makecell[cl]{ -                            \\ \inr(\inl(A,a))(0) \mapsto \tqm{(a \Rightarrow_\Pc A)} \\ \inr(\inl(A,a))(1) \mapsto \tqm{\El(a)}  \\ \inr(\inr(T, A, \tau))(\star) \mapsto \tqm{\ExtPiP{T}{A}} } \\
Sub_\Pc(\Gamma)
  & \unit
  & \makecell[cl]{\unit \\ + (A : {Ty_\Pc}(\Gamma_\Sc)) \times {Tm_\Pc}(\Gamma, A) }
  & \makecell[cl]{\inl(\star) \mapsto \emptytype \\ \inr(A, t) \mapsto \unit }
  & \_ \mapsto \star
  & \_ \mapsto \star
\end{array}$}
\caption{The input data for the indexed W-types representing the internalized
syntax for inductive families.}\label{tbl:if-iws}
\end{sidewaystable}

\subsection{Constructing the Term Model}\label{sec:if-termmodel}

For the remainder of this section, let us fix the sort context \tqm{\SCon \Omega_\Sc}
and the point context \tqm{\vdash_{\Omega_\Sc} \Omega} which we want to construct
by giving
\begin{align*}
\IFconS{\Omega}		&: \tqm{\Omega_\Sc}^\CC \text{ and} \\
\IFcon{\Omega}		&: \tqm{\Omega}^\CC(\IFconS{\Omega}) \text{.}
\end{align*}
Our definition of the constructor uses the trick %TODO cite whoever invented this trick
to index several of the constructions by a second sort or point context together
with a sort or point substitution from \tqm{\Omega_\Sc} or \tqm{\Omega}.
We can think of this second context as some sort of a ``sub-context'' of a fixed
context.

\begin{defn}[The Sort Constructor]\label{def:if-ex-cons}
The generalized sort constructor consists of the following data:
\begin{equation*}
\inferrule{\tqm{\SCon \Gamma_\Sc} \\
  \tqm{\IFSub{\sigma}{\Omega_\Sc}{\Gamma_\Sc}}}
  {\IFconS{\sigma} : \tqm{\Gamma_\Sc}^\CC }
\end{equation*}
We can define this recursively via
\begin{align*}
\IFconS{\epsilon}
  &:\equiv \star \text{ and} \\
\IFconS{\sigma,\, t}
  &:\equiv \left(\IFconS{\sigma},\, \IFconS{t}\right) \text{,}
\end{align*}
where on sort terms we will define a constructor operation yielding an algebra
of the respective sort type:
\begin{equation*}
\inferrule{\tqm{\Omega_\Sc \SCon t : B :: \Sc}}
  {\IFconS{t} : \tqm{B}^\CC }
\end{equation*}
This operation will on universe terms consist of the type of point terms, while
on external sort functions, it will return a function with constructor of the applied
term: %TODO formulation
\begin{align*}
\IFconS{a}
  &:\equiv {Tm_\Pc}(\tqm{\Omega}, \tqm{\El(a)})
  & \text{ for \tqm{\Omega_\Sc \SCon a : \UU :: \Sc} and} \\
\IFconS{f}
  &:\equiv \lambda \tau.\, \IFconS{f(\bltau)}
  & \text{ for \tqm{\Omega_\Sc \SCon f : \ExtPiS{T}{B} :: \Sc}.}
\end{align*}
\end{defn}

This construction is already enough to give the sort constructor required in
Theorem~\ref{thm:if-ex} by pinning the substitution to be the identity:
\begin{equation}\label{eq:if-ex-sorts}
\IFconS{\Omega} :\equiv \IFconS{\id_{\Omega_\Sc}} : \tqm{\Omega_\Sc}^\CC
\end{equation}
It is not immediately clear that the operation on substitutions and the operation
on sort terms is well-behaved under the pullback along substitutions.
We can, however, show that this is indeed the case.

\begin{lemma}[Coherence of the Sort Constructor]\label{lem:if-ex-cont}
For all subsitutions \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}} and sort terms
\tqm{\Gamma_\Sc \SCon t : B :: \Sc}, taking a constructor of \tqm{t} pulled back
along \tqm{\sigma} has the same effect as taking the term algebra over the context
algebra generated by the constructor on \tqm{\sigma}, i.\,e.
\begin{equation*}
\tqm{t}^\CC(\IFconS{\sigma}) = \IFconS{t[\sigma]} \text{.}
\end{equation*}
\end{lemma}

\begin{proof}
Let us first do a case distinction on the substitution.
If it is \tqm{\epsilon}, then $\tqm{\Gamma_\Sc} = \tqm{\cdot_\Sc} $,
and it is easy to see that there are no terms in the empty sort context.
Thus, we can assume the substitution to be of the form $\tqm{(\sigma,\, s)}$.
In this case, lets recurse on the term and see that
\begin{align*}
\tqm{\var(\vz)}^\CC(\IFconS{\sigma,\, s})
  &= \tqm{\var(\vz)}^\CC(\IFconS{\sigma}, \IFconS{s}) \\
  &= \IFconS{s} \\
  &= \IFconS{\var(\vz)[\sigma,\, s]} \text{,} \\[.7em]
\tqm{\var(\vs(t))}^\CC(\IFconS{\sigma,\, s})
  &= \tqm{\var(\vs(t))}^\CC(\IFconS{\sigma}, \IFconS{s}) \\
  &= \tqm{\var(t)}^\CC(\IFconS{\sigma}) \\
  &= \IFconS{\var(t)[\sigma]} & \text{ by induction} \\
  &= \IFconS{\var(\vs(t))[\sigma,\, s]} \text, & \text{ and lastly} \\[.7em]
\tqm{f(\bltau)}^\CC(\IFconS{\sigma,\, s})
  &= \tqm{f}^\CC(\IFconS{\sigma,\, s})(\bltau) \\
  &= \IFconS{f[\sigma,\, s]}(\bltau) & \text{ by induction} \\
  &= \IFconS{f(\bltau)[\sigma,\, s]} & \text{ for \tqm{f : \ExtPiS{T}{B}}.}
\end{align*}
\end{proof}

We can now use this lemma to be able to do a trick with $\IFcon{\Omega}$ similar
to the trick we did for $\IFconS{\Omega}$:
Replace the fixed point context with a variable one, together with a substitution
from \tqm{\Omega}, and define the constructor recursively on point types.

\begin{defn}[The Point Constructor]\label{def:if-ex-con}
We define operations on point contexts and point terms, resulting in algebras, in
the form of the following:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{\IFSub{\sigma_\Pc}{\Omega}{\Gamma}}}
  {\IFcon{\sigma_\Pc} : \tqm{\Gamma}^\CC(\IFconS{\Omega})}
\qquad
\inferrule{\tqm{\Omega \vdash_{\Omega\Sc} t_\Pc : A :: \Pc}}
  {\IFcon{t_\Pc} : \tqm{A}^\CC(\IFconS{\Omega}) }
\end{gathered}
\end{equation*}
The operation on point substitutions is defined recursively by
\begin{align*}
\IFcon{\epsilon_\Pc}
  &:\equiv \star \text{ and} \\
\IFcon{\sigma_\Pc,\, t_\Pc}
  &:\equiv \left(\IFcon{\sigma_\Pc}, \IFcon{t_\Pc} \right) \text{,}
\end{align*}
wheres for point terms, note that if \tqm{\Omega \vdash t_\Pc : \El(a) :: \Pc},
then by Lemma~\ref{lem:if-ex-cont}
\begin{equation*}
\tqm{t_\Pc} : \IFconS{a} \equiv \IFconS{a[\id]} = \tqm{a}^\CC(\IFconS{\id_{\Omega_\Sc}}) \equiv \tqm{\El(a)}^\CC(\IFconS{\Omega}) \text{,}
\end{equation*}
which allows us to define the constructor operator by
\begin{align*}
\IFcon{t_\Pc}
  &:\equiv \tqm{t_\Pc} & \text{ for \tqm{\Omega \vdash t_\Pc : \El(a)},} \\
\IFcon{f_\Pc}
  &:\equiv \lambda \tqm{t_\Pc}.\, \IFcon{f_\Pc(t_\Pc)} & \text{ for \tqm{\Omega \vdash f_\Pc : a \Rightarrow_\Pc A}, and} \\
\IFcon{f_\Pc}
  &:\equiv \lambda \tau.\, \IFcon{f_\Pc(\bltau)} & \text{ for \tqm{\Omega \vdash f_\Pc : \ExtPiP{T}{A}}.}
\end{align*}
\end{defn}

This concludes the definition of the constructors, since we can set, like for the
sort constructor
\begin{equation}
\IFcon{\Omega} :\equiv \IFcon{\id_\Omega} : \tqm{\Omega}^\CC(\IFconS{\Omega}) \text{.}
\end{equation}
Again, the construction comes with a property that makes it coherent under
pulled back point terms.
Analogously to Lemma~\ref{lem:if-ex-cont}, this coherence looks as follows:

\begin{lemma}[Coherence of the Point Constructor]\label{lem:if-ex-contp}
For all point subsitutions \tqm{\IFSub{\sigma_\Pc}{\Omega}{\Delta}} and
point terms \tqm{\Gamma \vdash_{\Omega_\Sc} t_\Pc : A :: \Pc}, pulling back has the 
same effect as the point constructor as in
\begin{equation}
\tqm{t_\Pc}^\CC(\IFcon{\sigma_\Pc}) = \IFcon{t_\Pc[\sigma_\Pc]} \text{.}
\end{equation}
\end{lemma}

\begin{proof}
Repeating the strategy of the proof of Lemma~\ref{lem:if-ex-cont}, we again see
that we can assume the substitution to be of an extended form \tqm{(\sigma_\Pc,\, s_\Pc)},
since there are no point terms in the empty point context.
Now, by recursion on the term we see that
\begin{align*}
\tqm{\var(\vz)}^\CC(\IFcon{\sigma_\Pc,\, s_\Pc})
  &= \tqm{\var(\vz)}^\CC(\IFcon{\sigma_\Pc}, \IFcon{s_\Pc}) \\
  &= \IFcon{s_\Pc} \\
  &= \IFcon{\var(\vz)[\sigma_\Pc,\, s_\Pc]} \text{,} \\[.7em]
\tqm{\var(\vs(t_\Pc))}^\CC(\IFcon{\sigma_\Pc,\, s_\Pc})
  &= \tqm{\var(\vs(t_\Pc))}^\CC(\IFcon{\sigma_\Pc}, \IFcon{s_\Pc}) \\
  &= \tqm{\var(t_\Pc)}^\CC(\IFcon{\sigma_\Pc}) \\
  &= \IFcon{\var(t_\Pc)[\sigma_\Pc]} & \text{ by induction} \\
  &= \IFcon{\var(\vs(t_\Pc))[\sigma_\Pc,\, s_\Pc]} \text{,} \\[.7em]
\tqm{f_\Pc(t_\Pc)}^\CC(\IFcon{\sigma_\Pc})
  &= \tqm{f_\Pc}^\CC(\IFcon{\sigma_\Pc})\left(\tqm{t_\Pc}^\CC(\IFcon{\sigma_\Pc})\right) \\
  &= \IFcon{f_\Pc[\sigma_\Pc]}(\IFcon{t_\Pc[\sigma_\Pc]}) & \text{ by induction} \\
  &= \IFcon{f_\Pc(t_\Pc)[\sigma_\Pc]} \text{, and} \\[.7em]
\tqm{f_\Pc(\bltau)}^\CC(\IFcon{\sigma_\Pc})
  &= \tqm{f_\Pc}^\CC(\IFcon{\sigma_\Pc})(\tau) \\
  &= \IFcon{f_\Pc[\sigma_\Pc]}(\tau) & \text{ by induction} \\
  &= \IFcon{f_\Pc(\tau)[\sigma_\Pc]} \text{.}
\end{align*}
\end{proof}

With the constructors defined let us move on the construction of the eliminator.
Let us from now on fix displayed algebras $\omega_\Sc^\DD : \tqm{\Omega_\Sc}^\DD(\IFconS{\Omega})$
and $\omega^\DD : \tqm{\Omega}^\DD(\omega_\Sc^\DD, \IFcon{\Omega})$.
We will proceed in the same order as for the constructors and start by generalizing
$\IFelimS{\Omega}{\omega^\DD}$ to arbitrary subcontexts of \tqm{\Omega} by giving constructions
on sort substitutions and sort terms.

\begin{defn}[The Eliminator]
The generalized eliminator will take substitutions or sort terms to give sections
of sort types or sort contexts, respectively:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{\IFSub{\sigma}{\Omega_\Sc}{\Gamma_\Sc}}}
  {\IFelimS{\sigma}{} : \tqm{\Gamma_\Sc}^\SS(\tqm{\sigma}^\DD(\omega_\Sc^\DD))}
\qquad
\inferrule{\tqm{\Omega_\Sc \SCon t : B :: \Sc}}
  {\IFelimS{t}{} : \tqm{B}^\SS(\tqm{t}^\DD(\omega_\Sc^\DD))}
\end{gathered}
\end{equation*}
The first rule is defined by recursion using the second construction as usual:
\begin{align*}
\IFelimS{\epsilon}{}
  &:\equiv \star \text{ and} \\
\IFelimS{\sigma,\,t}{}
  &:\equiv \left(\IFelimS{\sigma}{}, \IFelimS{t}{}\right) \text{.}
\end{align*}
For the sort terms, we observe that, by Lemmas~\ref{lem:if-ex-cont} and \ref{lem:if-ex-contp}, for
\tqm{\Omega_\Sc \SCon a : \UU} and \blm{\tqm{t_\Pc} : \tqm{a}^\CC(\IFconS{\Omega})} we have
\begin{equation*}
\begin{gathered}
%\tqm{a}^\CC(\IFconS{\Omega})
%  \equiv foo \text{, implying} \\
\tqm{\UU}^\SS(\tqm{a}^\DD(\omega_\Sc^\DD), \tqm{t_\Pc}^\CC(\IFcon{\Omega}))
  = \tqm{a}^\DD(\omega_\Sc^\DD, \tqm{t_\Pc})
\end{gathered}
\end{equation*}
and thus we can set, disregarding transports,
\begin{align*}
\IFelimS{a}{}
  &:\equiv \lambda \tqm{t_\Pc}.\, \tqm{t_\Pc}^\DD(\omega^\DD) & \text{ for \tqm{\Omega_\Sc \SCon a : \UU} and} \\
\IFelimS{f}{}
  &:\equiv \lambda \tau.\, \IFelimS{f(\bltau)}{} & \text{ for \tqm{\Omega_\Sc \SCon f : \ExtPiS{T}{B}}.}
\end{align*}
\end{defn}

Similar to Lemma~\ref{lem:if-ex-cont}, these definitions are coherent in the following
form:
\begin{lemma}\label{lem:if-ex-elimt}
Given a sort substitution \tqm{\IFSub{\sigma}{\Omega_\Sc}{\Gamma_\Sc}} and a sort
term \tqm{\Gamma_\Sc \SCon t : B :: \Sc}, the eliminator of a pulled back term
is the section of the term, evaluated at the eliminator on a substitution:
\begin{equation*}
\IFelimS{t[\sigma]}{} = \tqm{t}^\SS(\IFelimS{\sigma}{}) \text{.}
\end{equation*}
\end{lemma}

\begin{proof}
The proof strategy is exactly the same as for Lemma~\ref{lem:if-ex-cont}.
\end{proof}

As a last step, we still need to prove the computation rules for the eliminator,
consisting of section of given point contexts.
Consistent with~\ref{def:if-ex-cons}, we generalize them to arbitrary point
substitutions and point terms.

\begin{lemma}[Computation Rules]\label{lem:if-ex-elim}
We prove the computation rule for our eliminator $\IFelimS{\Omega}{}$ to be a
section of subcontexts of \tqm{\Omega} and on point terms of \tqm{\Omega}:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\vdash_{\Omega_\Sc} \Gamma} \\ \tqm{\IFSub{\sigma_\Pc}{\Omega}{\Gamma}}}
  {\IFelim{\sigma_\Pc}{} : \tqm{\Gamma}^\SS(\IFelimS{\Omega}{}, \tqm{\sigma_\Pc}^\DD(\omega^\DD))}
\\[.7em]
\inferrule{\tqm{\Omega \vdash_{\Omega_\Sc} t_\Pc : A :: \Pc}}
  {\IFelim{t_\Pc}{} : \tqm{A}^\SS(\IFelimS{\Omega}{}, \tqm{t_\Pc}^\DD(\omega^\DD))}
\end{gathered}
\end{equation*}
\end{lemma}

\begin{proof}
Using the second rule, the first one can be proved in a straightforward way by
recursion on the point substitution:
\begin{align*}
\IFelim{\epsilon_\Pc}{}
  &:\equiv \star \text{ and} \\
\IFelim{\sigma_\Pc,\, t_\Pc}{}
  &:\equiv \left( \IFelim{\sigma_\Pc}{}, \IFelim{t_\Pc}{} \right) \text{.}
\end{align*}
For the second rule we again need to consider the types needed for the element
case.
The previous lemmas tell us that for \tqm{\Omega \vdash t_\Pc : \El(a) :: \Pc} we
can prove the required rule by
\begin{align*}
  & \tqm{a}^\SS\left(\IFelimS{\id_{\Omega_\Sc}}{}, \tqm{t_\Pc}^\CC(\IFcon{\Omega})\right) \\
= & \tqm{a}^\SS(\IFelimS{\id_{\Omega_\Sc}}{}, \tqm{t_\Pc})
  & \text { by Lemma~\ref{lem:if-ex-contp}} \\
= & \IFelimS{a}{}(\tqm{t_\Pc})
  & \text { by Lemma~\ref{lem:if-ex-elimt}} \\
= & \tqm{t_\Pc}^\DD(\omega^\DD) \text{.}
%  & \text{ for \tqm{\Omega \vdash t_\Pc : \El(a)},} \\[.7em]
\end{align*}
For the case of \tqm{\Omega \vdash f_\Pc : \ExtPiP{T}{A}}, we see that we
can recursively define $\IFelim{f_\Pc}{}$ by proving $\IFelim{f_\Pc(\bltau)}{}$
for all $\tau : T$.
Likewise in the case of a recursive function term
\tqm{\Omega \vdash f_\Pc : a \Rightarrow_\Pc A}, we prove
$\IFelim{f_\Pc}{}$ recursively by $\IFelim{f_\Pc(t_\Pc)}{}$. %TODO more detail?
\end{proof}

\begin{proof}[Proof of Theorem~\ref{thm:if-ex}]
Lemma~\ref{lem:if-ex-elim} completes the construction of the eliminator and
setting
\begin{align*}
\IFelimS{\Omega}{\omega^\DD}
  &:\equiv \IFelimS{\id_{\Omega_\Sc}}{} \text{ and} \\
\IFelim{\Omega}{\omega^\DD}
  &:\equiv \IFelim{\id_\Omega}{}
\end{align*}
completes the existence proofs for our specification of inductive families.
\end{proof}




