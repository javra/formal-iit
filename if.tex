\section{Signatures for Inductive Families}

Previous specifications of mutual inductive families have taken different approaches:
Some are based on the notion of a polynomial functor while others...

Applying the same principle as in the case of inductive-inductive types we want
to create a specification based on the contexts of type theory syntax.
We already saw that we can obtain such a specification by just restricting the
syntax for inductive-inductive types to not use the recursive $\Pi$-type for sorts,
but this approach doesn't capture the full %TODO
extent of inductive families being a much simpler concept than inductive-inductive
types.
Given the strategy of our recursion we want the specification to capture at least
the following features of inductive families:
\begin{itemize}
\item Sorts are either types of funcions over existing types.
\item Point constructor can also be indexed over existing (``external'') types.
\item Point constructors can refer to any sort being defined.
\end{itemize}

The first point above says that we want the type of \emph{sort types} \blm{\tqm{\Sc} : \UU}
to be inductively generated by a \emph{universe} token \tqm{\UU : \Sc} and a constructor
of external functions for sorts which are meant to be \emph{type families}:
\tqm{\Pi_\Sc(\blm{T}, B) : \Sc} for a type \blm{T : \UU} and a function
\tqm{B : \blm{T \to \tqm{\Sc}}}.
Note that in contrast to the sort types of inductive-inductive definitions these
do not depend on a context.

Instead, we say that a \emph{sort context} is just a list of sort types without
any interdependencies:
\begin{equation*}
\begin{gathered}
\inferrule{}{\tqm{\SCon \cdot_\Sc}}
\qquad
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{B : \Sc}}{\tqm{\SCon \Gamma_\Sc, B}}
\end{gathered}
\end{equation*}

In order to refer to sorts we introduce a simplified term calculus based on typed
de Bruijn indices for bound variables and an application operation for type families:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{B : \Sc}}{\tqm{\Gamma_\Sc, B \SCon \var(\vz) : B}}
\qquad
\inferrule{\tqm{\Gamma_\Sc \SCon \var(v) : B}}{\tqm{\Gamma_\Sc, B' \SCon \var(\vs(v)) : B}}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon t : \Pi_\Sc(\blm{T}, B)} \\ \blm{\tau : T}}
  {\tqm{\Gamma_\Sc \SCon t(\blm{\tau}) : B(\blm{\tau})}}
\end{gathered}
\end{equation*}

Point constructors will be represented by \emph{point types} over a given sort
context.
This means that opposite to inductive-inductive types, they cannot depend on
other point types.
The type formers we need are the element type for the universe \tqm{\UU}, an
external, non-recursive function type like the one we have for sorts, and an
internal function type used for recursive point constructors:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma_\Sc \SCon a : \UU}}{\tqm{\Gamma_\Sc \SCon \El(a)}}
\qquad
\inferrule{\blm{T : \UU} \\ \blm{(\tau : T) \to \tqm{\Gamma_\Sc \SCon B(\blm{\tau})}}}
  {\tqm{\Gamma_\Sc \SCon \ExtPiP{T}{B}}}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon a : \UU} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\Gamma_\Sc \SCon a \Rightarrow_\Pc A}}
\end{gathered}
\end{equation*}

As a last building block of the syntax, we can now form full contexts consisting
of sort and point constructors.
Such a context \tqm{\Gamma} can be formed over a given sort context \tqm{\Gamma_\Sc}
which we will denote as a subscript to the turnstile or omit when inferrable.
%The empty context can be formed over the empty sort context, an extension of
%a context by a sort constructor happens in parallel to an extension of its sort
%context, and an extension by a point constructor leaves the sort context fixed:
The empty context can be formed over any sort context, and an extension by a point
constructor leaves the sort context fixed:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc}}{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
%\inferrule{}{\tqm{\vdash_{\cdot_\Sc} \cdot}}
\qquad
%\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{B : \Sc}}
%  {\tqm{\vdash_{\Gamma_\Sc, B} \Gamma, B}}
%\qquad
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\vdash_{\Gamma_\Sc} \Gamma, A}}
\end{gathered}
\end{equation*}

\begin{remark}
While for the signatures of inductive-inductive types, contexts, types, and terms
depend on each other we can here define sort types, sort contexts, terms, point
types, and contexts in the presented order without referring to later constructions.
This means that unlike mentioned in Remark~\ref{rmk:iit-syntax}, we  can %TODO cite remark
internalize this syntax just using inductive families.

An Agda formalization of the syntax looks as follows, with variables and terms
separated:
\begin{agdacode}
data TyS : Set₁ where
  U  : TyS
  Π̂S : (T : Set) → (T → TyS) → TyS

data SCon : Set₁ where
  ∙c   : SCon
  _▶c_ : SCon → TyS → SCon

data Var : SCon → TyS → Set₁ where
  vvz : ∀{Γc B} → Var (Γc ▶c B) B
  vvs : ∀{Γc B B'} → Var Γc B → Var (Γc ▶c B') B

data Tm (Γc : SCon) : TyS → Set₁ where
  var  : ∀{A} → Var Γc A → Tm Γc A
  _\$S_ : ∀{T B} → Tm Γc (Π̂S T B) → (α : T) → Tm Γc (B α)

data TyP (Γc : SCon) : Set₁ where
  El   : Tm Γc U → TyP Γc
  Π̂P   : (T : Set) → (T → TyP Γc) → TyP Γc
  _⇒P_ : Tm Γc U → TyP Γc → TyP Γc

data Con (Γc : SCon) : Set₁ where
  ∙    : Con Γc
  _▶P_ : Con Γc → (B : TyP Γc) → Con Γc
\end{agdacode}
%TODO remove backslash
\end{remark}

\begin{example}[Natural numbers, Vectors]\label{ex:if-natvec}
A common example for inductive types, the natural numbers, with one constructor for
zero and one for the successor function, are represented by the sort context
\tqm{\cdot_\Sc, \UU} and the points
\begin{equation*}
\tqm{\El(\var(\vz)), \var(\vz) \Rightarrow_\Pc \El(\var(\vz))} \text{.}
\end{equation*}

An example of a real indexed type would be the type family of vectors over a fixed
type \blm{A : \UU} which is defined over the sort context
\tqm{\cdot_\Sc, \Pi_\Sc(\blm{\N}, \blm{\lambda n. \tqm{\UU}})} by
\begin{equation*}
\begin{gathered}
\tqm{\cdot, \El(\var(\vz)(\blm{0})),}\\
\tqm{\Pi_\Pc(A, \lambda a. \Pi_\Pc(\N, \lambda n. \var(\vz)(n) \Rightarrow_\Pc \El(\var(\vz)(n + 1)))} \text{.}
\end{gathered}
\end{equation*}

An easy example with non-trivial mutual dependency between the point constructors
is the predicate of evenness and oddness on natural numbers: The sorts are
represented by \tqm{\cdot_\Sc, \Pi_\Sc(\blm{\N}, \blm{\lambda n. \tqm{\UU}}), \Pi_\Sc(\blm{\N}, \blm{\lambda n. \tqm{\UU}})}
and the point constructors by
\begin{equation*}
\begin{gathered}
\tqm{\cdot , \El(\var(\vs(\vz))),} \\
\tqm{\Pi_\Pc(\blm{\N}, \lambda n. \var(\vz)(n) \Rightarrow_\Pc \El(\var(\vs(\vz))(n + 1)),} \\
\tqm{\Pi_\Pc(\blm{\N}, \lambda n. \var(\vs(\vz))(n) \Rightarrow_\Pc \El(\var(\vz)(n + 1))} \text{.}
\end{gathered}
\end{equation*}
Here, the first sort constructor represents evenness, the second one oddness,
the first point constructor the proof that \blm{0} is even and the other two the
proof that evenness implies oddness of the successor and vice versa.
\end{example}

\begin{defn}[Sort Substitutions] \label{def:if-sort-subs}
One component of the syntax which has completely gone missing are substitutions.
Since we cant refer to previous point constructors, we certainly don't need them
for the point contexts.
But since we also got rid of sort interdependencies, we could reduce the recursive
function types on points to a non-depenent one and thus don't need to use
substitutions in the definition of application.
It may still be helpful for syntax transformations to use substitutions \tqm{\mathsf{Sub}}
of the sort contexts which we define as generated by
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\IFSub{\epsilon}{\Gamma_\Sc}{\cdot_\Sc}}}
\quad\text{and}\quad
\inferrule{\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}} \\ 
  \tqm{\Gamma_\Sc \SCon t : B}}
  {\tqm{\IFSub{\sigma, t}{\Gamma_\Sc}{(\Delta_\Sc, B)}}}
\text{.}
\end{gathered}
\end{equation*}
These then allow us to substitute point types, point contexts, and sort terms via
the following ``pullback'' operations:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Delta_\Sc \SCon A} \\
  \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\Gamma_\Sc \SCon A[\sigma]}}
\qquad
\inferrule{\tqm{\Delta_\Sc \SCon t : B} \\
  \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\Gamma_\Sc \SCon t[\sigma] : B}}
\\[.7em]
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\
  \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\vdash_{\Delta_\Sc} \Gamma[\sigma]}}
\end{gathered}
\end{equation*}
given by the defining rules for substitution
\begin{align*}
\tqm{\ExtPiP{T}{A}[\sigma]}			&= \tqm{\ExtPiP{T}{\blm{\lambda \tau. \tqm{A(\blm{\tau})[\sigma]}}}} \text{,} \\
\tqm{\El(a)[\sigma]}				&= \tqm{El(a[\sigma])} \text{,} \\
\tqm{(a \Rightarrow_\Pc A)[\sigma]}		&= \tqm{a[\sigma] \Rightarrow_\Pc A[\sigma]} \text{,} \\
\tqm{\var(\vz)[\sigma, t]}			&= \tqm{t} \text{,} \\
\tqm{\var(\vs(t))[\sigma, s]}			&= \tqm{\var(t)[\sigma]} \text{,} \\
\tqm{t(\bltau)[\sigma]}				&= \tqm{t[\sigma](\bltau)} \text{,} \\
\tqm{\cdot[\sigma]}				&= \tqm{\cdot} \text{, and} \\
\tqm{(\Gamma,\, A)[\sigma]}			&= \tqm{(\Gamma[\sigma],\, A[\sigma])} \text{.}
\end{align*}

We can derive from this the gadgets of the substitutional calculus which we
are already acquainted with from the syntax of inductive-inductive Types:
We can define the \emph{weakening} of a subsitution
\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}} to 
\tqm{\IFSub{\wk_\sigma}{\Gamma_\Sc, B}{\Delta_\Sc}} via recursion on \tqm{\sigma} by
\begin{align*}
\tqm{\wk_\epsilon} 				&:\equiv \tqm{\epsilon} \text{ and} \\
\tqm{\wk_{\sigma, t}}				&:\equiv \tqm{(\wk_\sigma, \vs(t))} \text{.}
\end{align*}
Using \tqm{\wk}, we can then recover the categorical structor of the substitutions
by defining the identity \tqm{\IFSub{\id_{\Gamma_\Sc}}{\Gamma_\Sc}{\Gamma_\Sc}}
by recursion of the context \tqm{\Gamma_\Sc}:
\begin{align*}
\tqm{\id_{(\cdot_\Sc)}}				&:\equiv \tqm{\epsilon} \text{ and} \\
\tqm{\id_{\Gamma_\Sc,\, B}}			&:\equiv \tqm{(\wk_{\id_{\Gamma_\Sc}},\, \vz)} \text{.}
\end{align*}
Composition \tqm{\IFSub{\sigma \circ \delta}{\Gamma_\Sc}{\Sigma_\Sc}} of substitutions
\tqm{\IFSub{\sigma}{\Delta_\Sc}{\Sigma_\Sc}} and \tqm{\IFSub{\delta}{\Gamma_\Sc}{\Delta_\Sc}}
is defined by recursion on the first context:
\begin{align*}
\tqm{\epsilon \circ \delta}			&:\equiv \tqm{\epsilon} \text{,} \\
\tqm{(\sigma, t) \circ \delta}			&:\equiv \tqm{(\sigma \circ \delta, t[\delta])} \text{.}
\end{align*}
Projections \tqm{\IFSub{\pi_1(\sigma)}{\Gamma_\Sc}{\Delta_\Sc}} and
\tqm{\Gamma_\Sc \SCon \pi_2(\sigma) : B} of a substitution
\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc, B}} can be defined as just that --
projections.
Any substitution between \tqm{\Gamma_\Sc} and \tqm{\Delta_\Sc,\, B} is of the form
\tqm{\sigma,\, t} and we can just set
\begin{align*}
\tqm{\pi_1(\sigma,\, t)}				&:\equiv \tqm{\sigma} \text{ and} \\
\tqm{\pi_2(\sigma,\, t)}				&:\equiv \tqm{t} \text{.}
\end{align*}
\end{defn}

%TODO address equalities

\section{Algebras of Inductive Families}\label{sec:if-alg}

Like for inductive-inductive types, we have to give a way to semantify the signatures
by stating what kind of data they should represent.

\begin{defn}[Algebra operator]
Again, sort contexts will be mapped to types, sort constructors to families over these
types, their terms to sections of these families.
Point contexts will give the same data, but depending on an interpretation of the sort
contexts:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{B :: \Sc}}
  {\tqm{B}^\CC : \UU}
\qquad
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\Gamma_\Sc}^\CC : \UU}
\qquad
\inferrule{\tqm{\Gamma_\Sc \SCon t : B :: \Sc}}
  {\tqm{t}^\CC : \tqm{\Gamma_\Sc}^\CC \to \tqm{B}^\CC}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon A :: \Pc}}
  {\tqm{A}^\CC : \tqm{\Gamma_\Sc}^\CC \to \UU}
\qquad
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
  {\tqm{\Gamma}^\CC : \UU}
\end{gathered}
\end{equation*}

Going through all of these translation in order, we first define the algebras
of sorts to be interpreted into functions over the universe:
\begin{align*}
\tqm{\UU}^\CC				&:\equiv \UU \\
\tqm{\ExtPiS{T}{B}}^\CC			&:\equiv (\tau : T) \to \tqm{B(\bltau)}^\CC
\end{align*}
Sort contexts become iterated product types -- note that we don't even need to
use $\Sigma$-types since there are no dependencies between sorts:
\begin{align*}
\tqm{\cdot_\Sc}^\CC			&:\equiv \unit \\
\tqm{(\Gamma_\Sc,\, B)}^\CC		&:\equiv \tqm{\Gamma_\Sc}^\CC \times \tqm{B}^\CC
\end{align*}
We use terms to navigate these iterated product via iterated projects, and to
apply function sorts:
\begin{align*}
\tqm{\var(\vz)}^\CC(\gamma, \alpha)	&:\equiv \alpha \\
\tqm{\var(\vs(t))}^\CC(\gamma, \alpha)	&:\equiv \tqm{\var(t)}^\CC(\gamma) \\
\tqm{t(\bltau)}^\CC(\gamma)		&:\equiv \tqm{t}^\CC(\gamma, \bltau)
\end{align*}
For point constructors, we need to interpret both types of functions into functions
while erasing the element operator, since it does not have any semantic meaning:
\begin{align*}
\tqm{\El(a)}^\CC(\gamma)		&:\equiv \tqm{a}^\CC(\gamma) \\
\tqm{\ExtPiP{T}{A}}^\CC(\gamma)		&:\equiv (\tau : T) \to \tqm{A(\bltau)}^\CC(\gamma) \\
\tqm{(a \Rightarrow_\Pc A)}^\CC(\gamma)	&:\equiv \tqm{a}^\CC(\gamma) \to \tqm{A}^\CC(\gamma)
\end{align*}
Just like for the sort contexts, point contexts are interdependency-free lists
of point constructors and as such can be interpreted as simple products instead
of $\Sigma$-types:
\begin{align*}
\tqm{\cdot}^\CC(\gamma)			&:\equiv \unit \\
\tqm{(\Gamma,\, A)}^\CC(\gamma)		&:\equiv \tqm{\Gamma}^\CC(\gamma) \times \tqm{A}^\CC(\gamma)
\end{align*}
\end{defn}

\begin{example}[Natural numbers]
Looking at the signature of the natural numbers from Example~\ref{ex:if-natvec},
we see that the algebra interpretation of its sort context evaluates to
\begin{equation*}
\unit \times \UU
\end{equation*}
and given an element \blm{(\star, N) : \unit \times \UU}, the algebras of its
point contexts, evaluated at this point result in
\begin{equation*}
N \times (N \to N) \text{.}
\end{equation*}
%TODO vector example?
\end{example}

In the previous section, we introduced a substition calculus for the sort contexts.
Obviously, we might also want to consider algebras over these substitutions.

\begin{defn}[Algebras of substitutions]\label{def:if-alg-sub}
We can extend the algebra operator by defining it on substitutions by functions
between the interpretations of sort contexts:
\begin{equation*}
\inferrule{\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\sigma}^\CC : \tqm{\Gamma_\Sc}^\CC \to \tqm{\Gamma_\Sc}^\CC}
\end{equation*}
This is done by setting
\begin{align*}
\tqm{\epsilon}^\CC		&:\equiv \star \text{ and}\\
\tqm{(\sigma,\, t)}^\CC		&:\equiv (\tqm{\sigma}^\CC , \tqm{t}^\CC) \text{.}
\end{align*}
\end{defn}

\begin{lemma}
It's easy to check that this definition of algebras of a subtitution respects
the substitution calculus given in Definition~\ref{def:if-sort-subs} in the following
sense:
\begin{align*}
\tqm{A[\sigma]}^\CC(\gamma)		&= \tqm{A}^\CC(\tqm{\sigma}^\CC(\gamma)) \text{,} \\
\tqm{t[\sigma]}^\CC(\gamma)		&= \tqm{t}^\CC(\tqm{\sigma}^\CC(\gamma)) \text{,} \\
\tqm{\id}^\CC(\gamma)			&= \gamma \text{,} \\
\tqm{(\sigma \circ \delta)}^\CC(\gamma)	&= \tqm{\sigma}^\CC(\tqm{\delta}^\CC(\gamma)) \text{,} \\
\tqm{\wk_\sigma}^\CC(\gamma, \alpha)	&= \tqm{\sigma}^\CC(\gamma) \text{,} \\
\tqm{\pi_1(\sigma)}^\CC(\gamma)		&= \pr_1(\tqm{\sigma}^\CC(\gamma)) \text{, and } \\
\tqm{\pi_2(\sigma)}^\CC(\gamma)		&= \pr_2(\tqm{\sigma}^\CC(\gamma)) \text{.}
\end{align*}
\end{lemma}
\begin{proof}
We can proof the first rule by recursion on the point type \tqm{\Gamma_\Sc \SCon A :: \Pc},
the second rule by recursing on the term \tqm{\Gamma_\Sc \SCon t : B :: \Sc},
the third by induction on the context,
and all other by induction by the substitution.
\end{proof}

Note that we never introduced substitutions between point constructors.
While we don't need them to specify inductive families, they are still
a useful tool, especially on the level of algebras.

\begin{defn}[Point Substitution Algebras]\label{def:if-alg-lsub}
For a sort substitution \tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}} we can
define a type of \emph{lifted point substitution algebras} $\LSub{\sigma}{\Gamma}{\Delta}$ between
point contexts \tqm{\vdash_{\Gamma_\Sc} \Gamma} and
\tqm{\vdash_{\Delta_\Sc} \Delta} inductively as generated by
\begin{align*}
\epsilon		&: \LSub{\sigma}{\Gamma}{\cdot} \text{ and} \\
(\sigma_\Pc,\, \phi)	&: \LSub{\sigma}{\Gamma}{(\Delta,\, A)} \text{,}
\end{align*}
for $\sigma_\Pc : \LSub{\sigma}{\Gamma}{\Delta}$ and
$\phi : \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\} \left(\gamma : \tqm{\Gamma}^\CC(\gamma_\Sc)\right) \to \tqm{A}^\CC(\sigma^\CC(\gamma_\Sc))$.
\end{defn}

%TODO define calculus for lifted subs

\section{Displayed Algebras and their Sections}\label{sec:if-ds}

To represent the dependent eliminator, we need algebras which vary over other
algebras.
To get a feeling about what these should look like, let us first look at our
usual simplest example:

\begin{example}\label{ex:if-ds-nat}
Take algebras \blm{(\star, N) : \unit \times \UU} and
\blm{(\star, z, s) : \unit \times N \times (N \to N)} of
the the signature of natural numbers (Example~\ref{ex:if-natvec}).
A \emph{displayed algebra} over this should contain the data which the dependent
eliminator of the natural numbers takes as input:
A type family \blm{P : N \to \UU} together with a point \blm{p_z : P(z)}
and a family of functions \blm{p_s : (n : N) \to P(n) \to P(s(n))}.

A \emph{section} of this algebra would be a section \blm{f : (n : N) \to P(n)} of
\blm{P} respecting the other data by ensuring that \blm{f(z) = p_z}
and that for all \blm{n : N}, we have \blm{f(s(n)) = p_s(f(n))}.
%TODO add another example
\end{example}

Let's first concentrate on the first piece of data:
\begin{defn}[Displayed Algebra Operator]
As seen above, we want to map sorts to type families over the given algebra.
Sort context will likewise be type families over an algebra:
\begin{equation*}
\inferrule{\tqm{B :: \Sc}}
  {\tqm{B}^\DD : \tqm{B}^\CC \to \UU}
\qquad
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\Gamma_\Sc}^\DD : \tqm{\Gamma_\Sc}^\CC \to \UU}
\end{equation*}
Since sorts can themselves be interpreted as functions, we have to apply them
whenever we encounter a sort function.
Sort contexts will again be interpreted as iterated products.
\begin{align*}
\tqm{\UU}^\DD(\alpha)				&:\equiv \alpha \to \UU \\
\tqm{\ExtPiS{T}{B}}^\DD(\alpha)			&:\equiv (\tau : T) \to \tqm{B(\bltau)}^\DD(\alpha(\bltau)) \\
\tqm{\cdot_\Sc}^\DD(\star)			&:\equiv \unit \\
\tqm{(\Gamma_\Sc,\, B)}^\DD(\gamma, \alpha)	&:\equiv \tqm{\Gamma}^\DD(\gamma) \times \tqm{B}^\DD(\alpha)
\end{align*}

The interpretation of point constructors and of point contexts now not only depends
on the algebra, but also on the interpretation of the underlying sorts:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma_\Sc \SCon A :: \Pc}}
  {\tqm{A}^\DD : \{\gamma : \tqm{\Gamma_\Sc}^\CC\} \to \tqm{\Gamma_\Sc}^\DD(\gamma) 
    \to \tqm{A}^\CC(\gamma) \to \UU }
\\[.7em]
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
  {\tqm{\Gamma}^\DD : \{\gamma : \tqm{\Gamma_\Sc}^\CC\} \to \tqm{\Gamma_\Sc}^\DD(\gamma)
    \to \tqm{\Gamma}^\CC(\gamma) \to \UU }
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon t : B :: \Sc}}
  {\tqm{t}^\DD : \{\gamma : \tqm{\Gamma_\Sc}^\CC\} \to \tqm{\Gamma_\Sc}^\DD(\gamma)
    \to \tqm{B}^\DD(\tqm{t}^\CC(\gamma)) }
\end{gathered}
\end{equation*}
The definition on terms is almost the same as for fixed algebras:
\begin{align*}
\tqm{\var(\vz)}^\DD(\gamma^\DD, \alpha^\DD)
  &:\equiv \alpha^\DD \text{,} \\
\tqm{\var(\vs(t))}^\DD(\gamma^\DD, \alpha^\DD)
  &:\equiv \tqm{\var(t)}^\DD(\gamma^\DD) \text{, and} \\
\tqm{f(\bltau)}^\DD(\gamma^\DD)
  &:\equiv \tqm{f}^\DD(\gamma^\DD)(\tau) \text{.}
\end{align*}
Displayed algebras on point constructors are defined fiberwise, like the ones for
sorts:
\begin{align*}
\tqm{\El(a)}^\DD(\gamma_\Sc^\DD, \alpha)
  &:\equiv \tqm{a}^\DD(\gamma_\Sc^\DD, \alpha) \\
\tqm{\ExtPiP{T}{A}}^\DD(\gamma_\Sc^\DD, \pi)
  &:\equiv (\tau : T) \to \tqm{A(\bltau)}^\DD(\gamma_\Sc^\DD, \pi(\tau)) \\
\tqm{(a \Rightarrow_\Pc A)}^\DD(\gamma_\Sc^\DD, \pi)
  &:\equiv \{\alpha : \tqm{a}^\CC(\_) \} \to \tqm{a}^\DD(\gamma_\Sc^\DD, \alpha)
    \to \tqm{A}^\DD(\gamma_\Sc^\DD, \pi(\alpha))
\end{align*}
Finally, contexts are interpreted as iterated products again:
\begin{align*}
\tqm{\cdot}^\DD(\gamma_\Sc^\DD, \gamma)
  &:\equiv \unit \\
\tqm{(\Gamma,\, A)}^\DD(\gamma_\Sc^\DD, (\gamma, \alpha))
  &:\equiv \tqm{\Gamma}^\DD(\gamma_\Sc^\DD, \gamma) \times \tqm{A}^\DD(\gamma_\Sc^\DD, \alpha)
\end{align*}
\end{defn}

%TODO section fluff
\begin{defn}[Section Operator]
For sorts and sort contexts, we want the sections of a displayed algebra to be
the sections of the type family they represent:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{B :: \Sc}}
  {\tqm{B}^\SS : \{\alpha : \tqm{B}^\CC\} \to \tqm{B}^\DD(\alpha) \to \UU}
\\[.7em]
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\Gamma_\Sc}^\SS : \{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\} \to 
    \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc) \to \UU }
\end{gathered}
\end{equation*}
Both follow the structure of the underlying displayed algebra -- fibrewise for
sort functions and by iterated products on sort contexts:
\begin{align*}
\tqm{\UU}^\SS(\alpha^\DD)
  &:\equiv (x : \_) \to \alpha^\DD(x) \\
\tqm{\ExtPiS{T}{B}}^\SS(\pi^\DD)
  &:\equiv (\tau : T) \to \tqm{B(\bltau)}^\SS(\pi^\DD(\tau)) \\
\tqm{\cdot_\Sc}(\gamma_\Sc^\DD)
  &:\equiv \unit \\
\tqm{(\Gamma_\Sc, B)}^\SS(\gamma_\Sc^\DD, \alpha^\DD)
  &:\equiv \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD) \times \tqm{B}^\SS(\alpha^\DD)
\end{align*}

Sections of point constructors, point contexts, and sort terms will clearly
have to depend on a section of the underlying sort interpretation:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma_\Sc \SCon A :: k}}
  {\tqm{A}^\SS : \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\}
    \left\{\gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc)\right\}
    \left(\gamma_\Sc^\SS : \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD)\right) \\
    \left\{\alpha : \tqm{A}^\CC(\gamma_\Sc)\right\}
    \left(\alpha^\DD : \tqm{A}^\DD(\gamma_\Sc^\DD, \alpha)\right)
    \to \UU }
\\[.7em]
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
  {\tqm{\Gamma}^\SS : 
    \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\}
    \left\{\gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc)\right\}
    \left(\gamma_\Sc^\SS : \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD)\right) \\
    \left\{\gamma : \tqm{\Gamma}^\CC(\gamma_\Sc)\right\}
    \left(\gamma^\DD : \tqm{\Gamma}^\DD(\gamma_\Sc^\DD, \gamma)
    \to \UU \right)}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon t : B :: \Sc}}
  {\tqm{t}^\SS :
    \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\}
    \left\{\gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc)\right\}
    \left(\gamma_\Sc^\SS : \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD)\right)
  \to \tqm{B}^\SS\left(\tqm{t}^\DD(\gamma_\Sc^\DD)\right)}
\end{gathered}
\end{equation*}
For point types we again descent fibrewise, but what to do about the element
operator?
This is where the equations which we have seen in Example~\ref{ex:if-ds-nat}
come into play:
The element which we get out of the interpretation of the section must coincide
with the one we provided by giving the displayed algebra:
\begin{align*}
\tqm{\El(a)}^\SS(\gamma_\Sc^\SS, \alpha^\DD)
  &:\equiv \left(\tqm{a}^\SS(\gamma_\Sc^\SS, \_) = \alpha^\DD  \right) \\
\tqm{\ExtPiP{T}{A}}^\SS(\gamma_\Sc^\SS, \pi^\DD)
  &:\equiv (\tau : T) \to \tqm{A(\bltau)}^\SS(\gamma_\Sc^\SS, \pi^\DD(\tau)) \\
\tqm{(a \Rightarrow_\Pc A)}^\SS(\gamma_\Sc^\SS, \pi^\DD)
  &:\equiv (\alpha : \tqm{a}^\CC(\_))
    \to \tqm{A}^\SS\left(\gamma_\Sc^\SS, \pi^\DD(\tqm{a}^\SS(a, \gamma_\Sc^\SS)(\alpha))\right)
\end{align*}
The definition of sections of point contexts is easier as it is, again,
just an iteration of products:
\begin{align*}
\tqm{\cdot}^\SS(\gamma_\Sc^\SS, \gamma^\DD)
  &:\equiv \unit \\
\tqm{(\Gamma,\, A)}^\SS(\gamma_\Sc^\SS, (\gamma^\DD, \alpha^\DD))
  &:\equiv \tqm{\Gamma}^\SS(\gamma_\Sc^\SS, \gamma^\DD)
    \times \tqm{A}^\SS(\gamma_\Sc^\SS, \alpha^\DD)
\end{align*}
At last, also terms follow the usual pattern of variables selecting sort interpretations
via projects of products and interpreting the application by metatheoretic application:
\begin{align*}
\tqm{\var(\vz)}^\SS(\gamma_\Sc^\SS, \alpha^\SS)
  &:\equiv \alpha^\SS \\
\tqm{\var(\vs(t))}^\SS(\gamma_\Sc^\SS, \alpha^\SS)
  &:\equiv \tqm{\var(t)}^\SS(\gamma_\Sc^\SS) \\
\tqm{f(\bltau)}^\SS(\gamma_\Sc^\SS)
  &:\equiv \tqm{f}^\SS(\gamma_\Sc^\SS)(\tau)
\end{align*}
\end{defn}

Sometimes, we will need that, following Definition~\ref{def:if-alg-sub}, we can
interpret sort substitutions with the means of displayed algebras, for which
we also need a definition of a section:
\begin{defn}[Displayed Algebras of Substitutions]
Given a sort substitution, its type of displayed algebras should be the type
of function between the displayed algebras of its domain and codomain, where in the
latter we have to apply the function which we get from the \emph{algebra} over
the substitution:
\begin{equation*}
\inferrule{\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\sigma}^\DD :
    \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\}
    \to \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc)
    \to \tqm{\Delta_\Sc}^\DD(\tqm{\sigma}^\CC(\gamma_\Sc))}
\end{equation*}
These are defined, like in the non-displayed case, by
\begin{align*}
\tqm{\epsilon}^\DD(\gamma_\Sc^\DD)
  &:\equiv \star \text{ and} \\
\tqm{(\sigma,\, t)}^\DD(\gamma_\Sc^\DD)
  &:\equiv \left(\tqm{\sigma}^\DD(\gamma_\Sc^\DD), \tqm{t}^\DD(\gamma_\Sc^\DD)\right) \text{.}
\end{align*}
\end{defn}

\begin{defn}[Sections of Substitutions]
A section of a displayed algebra of a sort substitution is supposed to map
sections of its domain to sections of its codomain:
\begin{equation*}
\inferrule{\tqm{\IFSub{\sigma}{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\sigma}^\DD :
    \left\{\gamma_\Sc : \tqm{\Gamma_\Sc}^\CC\right\}
    \left\{\gamma_\Sc^\DD : \tqm{\Gamma_\Sc}^\DD(\gamma_\Sc)\right\}
    \to \tqm{\Gamma_\Sc}^\SS(\gamma_\Sc^\DD)
    \to \tqm{\Delta_\Sc}^\SS(\tqm{\sigma}^\DD(\gamma_\Sc^\DD)) }
\end{equation*}
Again, this is happening componentwise:
\begin{align*}
\tqm{\epsilon}^\SS(\gamma_\Sc^\SS)
  &:\equiv \star \text{ and} \\
\tqm{(\sigma,\, t)}^\SS(\gamma_\Sc^\SS)
  &:\equiv \left(\tqm{\sigma}^\SS(\gamma_\Sc^\SS), \tqm{t}^\SS(\gamma_\Sc^\SS) \right) \text{.}
\end{align*}
\end{defn}

\section{Existence of Inductive Families}

Having a specification for Inductive Families is not worth much if there is no
way to know what it means for a type theory to actually ``support'' types of this
specification.
The intended meaning of the signatures is clear from the definition of their algebras
as seen in Section~\ref{sec:if-alg} and as discussed in Section~\ref{sec:if-ds},
candidates for their eliminators and computation rules are specified in the definition
of sections displayed algebras.
This means that we can formally say what the requirements are for inductive
families to exist.
In this section, we will prove that any metatheory as premised in Section~\ref{sec:meta}
actually supports inductive families as specified here.

\begin{thm}[Existence of Inductive Families]
For every signature of inductive families given by a sort context \tqm{\SCon \Omega_\Sc}
and a point context \tqm{\vdash_{\Omega_\Sc} \Omega}, there are are sort and point
\emph{constructors} in the form of
\begin{align*}
\IFconS{\Omega}		&: \tqm{\Omega_\Sc}^\CC \text{ and} \\
\IFcon{\Omega}		&: \tqm{\Omega}^\CC(\IFconS{\Omega})
\end{align*}
such that for each displayed algebra given by motives $\omega_\Sc^\DD : \tqm{\Omega_\Sc}^\DD(\IFconS{\Omega})$
and methods $\omega^\DD : \tqm{\Omega}^\DD(\omega_\Sc^\DD, \IFcon{\Omega})$
we can prove an \emph{eliminator} in the by the means of sections
\begin{align*}
\IFelimS{\Omega}{\omega^\DD}	&: \tqm{\Omega_\Sc}^\SS(\omega_\Sc^\DD) \text{ with} \\
\IFelim{\Omega}{\omega^\DD}	&: \tqm{\Omega}^\SS(\IFelimS{\Omega}{\omega^\DD}, \omega^\DD) \text{.}
\end{align*}
\end{thm}

To prove this theorem in our setting, we will need to make up for some of the
short cuts and simplifications in our definition of signatures.
In the theory of semantics of type theory, which studies various models of different
type theories, the model which is initial in the category of all models
is usually called the \emph{term model}.
This is because in this model, a type get interpreted as the set of all of its
terms.
Since our signatures form -- or are at least strongly
inspired by -- a type theoretic syntax as well, we might hope to deploy the same
strategy for inductive families.
In the core of this interpretation is the issue of how to find an interpretation
for a given sort term \tqm{a} of the universe toke \tqm{\UU}.
The interpretation of this ought to be the terms of the \emph{point type}
\tqm{\El(a)} associated with this sort term.
But our syntax does not mention terms of point types at all, since point constructor
are not interdependent!
So our solution is to retrofit the theory with terms, as well as substitutions
for the point contexts:

\begin{defn}[Point Substitution Calculus]
It turns out that there are four ways to construct reasonable terms of point types:
Via two constructors for de-Bruijn indices to navigate point contexts and
by an application constructor for each of the two kinds of $\Pi$-type present in
the syntax.
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma \vdash_{\Gamma_\Sc}} \\
  \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\Gamma,\, A \vdash \var(\vz) : A :: \Pc}}
\qquad
\inferrule{\tqm{\Gamma_\Sc \SCon A} \\ \tqm{\Gamma_\Sc \SCon A'} \\
  \tqm{\Gamma \vdash \var(t) : A :: \Pc}}
  {\tqm{\Gamma,\, A' \vdash \var(\vs(t)) : A :: \Pc}}
\\[.7em]
\inferrule{\tqm{\Gamma \vdash f : (a \Rightarrow_\Pc A)} \\
  \tqm{\Gamma  \vdash t : \El(a)}}
  {\tqm{\Gamma \vdash f(t) : A :: \Pc}}
\\[.7em]
\inferrule{\tqm{\Gamma \vdash f : \ExtPiP{T}{A}} \\ \tau : T}
  {\tqm{\Gamma \vdash f(\bltau) : A(\bltau) :: \Pc}}
\end{gathered}
\end{equation*}
\end{defn}

\begin{itemize}
\item point terms
\item lifted substitution
\item kripke trick
\end{itemize}





