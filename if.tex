\section{Signatures for Inductive Families}

Previous specifications of mutual inductive families have taken different approaches:
Some are based on the notion of a polynomial functor while others...

Applying the same principle as in the case of inductive-inductive types we want
to create a specification based on the contexts of type theory syntax.
We already saw that we can obtain such a specification by just restricting the
syntax for inductive-inductive types to not use the recursive $\Pi$-type for sorts,
but this approach doesn't capture the full %TODO
extent of inductive families being a much simpler concept than inductive-inductive
types.
Given the strategy of our recursion we want the specification to capture at least
the following features of inductive families:
\begin{itemize}
\item Sorts are either types of funcions over existing types.
\item Point constructor can also be indexed over existing (``external'') types.
\item Point constructors can refer to any sort being defined.
\end{itemize}

The first point above says that we want the type of \emph{sort types} \blm{\tqm{\Sc} : \UU}
to be inductively generated by a \emph{universe} token \tqm{\UU : \Sc} and a constructor
of external functions for sorts which are meant to be \emph{type families}:
\tqm{\Pi_\Sc(\blm{T}, B) : \Sc} for a type \blm{T : \UU} and a function
\tqm{B : \blm{T \to \tqm{\Sc}}}.
Note that in contrast to the sort types of inductive-inductive definitions these
do not depend on a context.

Instead, we say that a \emph{sort context} is just a list of sort types without
any interdependencies:
\begin{equation*}
\begin{gathered}
\inferrule{}{\tqm{\SCon \cdot_\Sc}}
\qquad
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{B : \Sc}}{\tqm{\SCon \Gamma_\Sc, B}}
\end{gathered}
\end{equation*}

In order to refer to sorts we introduce a simplified term calculus based on typed
de Bruijn indices for bound variables and an application operation for type families:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{B : \Sc}}{\tqm{\Gamma_\Sc, B \SCon \var(\vz) : B}}
\qquad
\inferrule{\tqm{\Gamma_\Sc \SCon \var(v) : B}}{\tqm{\Gamma_\Sc, B' \SCon \var(\vs(v)) : B}}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon t : \Pi_\Sc(\blm{T}, B)} \\ \blm{\tau : T}}
  {\tqm{\Gamma_\Sc \SCon t(\blm{\tau}) : B(\blm{\tau})}}
\end{gathered}
\end{equation*}

Point constructors will be represented by \emph{point types} over a given sort
context.
This means that opposite to inductive-inductive types, they cannot depend on
other point types.
The type formers we need are the element type for the universe \tqm{\UU}, an
external, non-recursive function type like the one we have for sorts, and an
internal function type used for recursive point constructors:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma_\Sc \SCon a : \UU}}{\tqm{\Gamma_\Sc \SCon \El(a)}}
\qquad
\inferrule{\blm{T : \UU} \\ \blm{(\tau : T) \to \tqm{\Gamma_\Sc \SCon B(\blm{\tau})}}}
  {\tqm{\Gamma_\Sc \SCon \Pi_\Pc(\blm{T}, B)}}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon a : \UU} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\Gamma_\Sc \SCon a \Rightarrow_\Pc A}}
\end{gathered}
\end{equation*}

As a last building block of the syntax, we can now form full contexts consisting
of sort and point constructors.
Such a context \tqm{\Gamma} can be formed over a given sort context \tqm{\Gamma_\Sc}
which we will denote as a subscript to the turnstile or omit when inferrable.
%The empty context can be formed over the empty sort context, an extension of
%a context by a sort constructor happens in parallel to an extension of its sort
%context, and an extension by a point constructor leaves the sort context fixed:
The empty context can be formed over any sort context, and an extension by a point
constructor leaves the sort context fixed:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc}}{\tqm{\vdash_{\Gamma_\Sc} \Gamma}}
%\inferrule{}{\tqm{\vdash_{\cdot_\Sc} \cdot}}
\qquad
%\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{B : \Sc}}
%  {\tqm{\vdash_{\Gamma_\Sc, B} \Gamma, B}}
%\qquad
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\vdash_{\Gamma_\Sc} \Gamma, A}}
\end{gathered}
\end{equation*}

\begin{remark}
While for the signatures of inductive-inductive types, contexts, types, and terms
depend on each other we can here define sort types, sort contexts, terms, point
types, and contexts in the presented order without referring to later constructions.
This means that unlike mentioned in Remark~\ref{rmk:iit-syntax}, we  can %TODO cite remark
internalize this syntax just using inductive families.

An Agda formalization of the syntax looks as follows, with variables and terms
separated:
\begin{agdacode}
data TyS : Set₁ where
  U  : TyS
  Π̂S : (T : Set) → (T → TyS) → TyS

data SCon : Set₁ where
  ∙c   : SCon
  _▶c_ : SCon → TyS → SCon

data Var : SCon → TyS → Set₁ where
  vvz : ∀{Γc B} → Var (Γc ▶c B) B
  vvs : ∀{Γc B B'} → Var Γc B → Var (Γc ▶c B') B

data Tm (Γc : SCon) : TyS → Set₁ where
  var  : ∀{A} → Var Γc A → Tm Γc A
  _\$S_ : ∀{T B} → Tm Γc (Π̂S T B) → (α : T) → Tm Γc (B α)

data TyP (Γc : SCon) : Set₁ where
  El   : Tm Γc U → TyP Γc
  Π̂P   : (T : Set) → (T → TyP Γc) → TyP Γc
  _⇒P_ : Tm Γc U → TyP Γc → TyP Γc

data Con (Γc : SCon) : Set₁ where
  ∙    : Con Γc
  _▶P_ : Con Γc → (B : TyP Γc) → Con Γc
\end{agdacode}
%TODO remove backslash
\end{remark}

\begin{example}
A common example for inductive types, the natural numbers, with one constructor for
zero and one for the successor function, are represented by the sort context
\tqm{\cdot_\Sc, \UU} and the points
\begin{equation*}
\tqm{\El(\var(\vz)), \var(\vz) \Rightarrow_\Pc \El(\var(\vz))} \text{.}
\end{equation*}

An example of a real indexed type would be the type family of vectors over a fixed
type \blm{A : \UU} which is defined over the sort context
\tqm{\cdot_\Sc, \Pi_\Sc(\blm{\N}, \blm{\lambda n. \tqm{\UU}})} by
\begin{equation*}
\begin{gathered}
\tqm{\cdot, \El(\var(\vz)(\blm{0})),}\\
\tqm{\Pi_\Pc(A, \lambda a. \Pi_\Pc(\N, \lambda n. \var(\vz)(n) \Rightarrow_\Pc \El(\var(\vz)(n + 1)))} \text{.}
\end{gathered}
\end{equation*}

An easy example with non-trivial mutual dependency between the point constructors
is the predicate of evenness and oddness on natural numbers: The sorts are
represented by \tqm{\cdot_\Sc, \Pi_\Sc(\blm{\N}, \blm{\lambda n. \tqm{\UU}}), \Pi_\Sc(\blm{\N}, \blm{\lambda n. \tqm{\UU}})}
and the point constructors by
\begin{equation*}
\begin{gathered}
\tqm{\cdot , \El(\var(\vs(\vz))),} \\
\tqm{\Pi_\Pc(\blm{\N}, \lambda n. \var(\vz)(n) \Rightarrow_\Pc \El(\var(\vs(\vz))(n + 1)),} \\
\tqm{\Pi_\Pc(\blm{\N}, \lambda n. \var(\vs(\vz))(n) \Rightarrow_\Pc \El(\var(\vz)(n + 1))} \text{.}
\end{gathered}
\end{equation*}
Here, the first sort constructor represents evenness, the second one oddness,
the first point constructor the proof that \blm{0} is even and the other two the
proof that evenness implies oddness of the successor and vice versa.
\end{example}

One component of the syntax which has completely gone missing are substitutions.
Since we cant refer to previous point constructors, we certainly don't need them
for the point contexts.
But since we also got rid of sort interdependencies, we could reduce the recursive
function types on points to a non-depenent one and thus don't need to use
substitutions in the definition of application.
It may still be helpful for syntax transformations to use substitutions \tqm{\mathsf{Sub}}
of the sort contexts which we define as generated by
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc}}
  {\tqm{\epsilon : \IFSub{\Gamma_\Sc}{\cdot_\Sc}}}
\quad\text{and}\quad
\inferrule{\tqm{\sigma : \IFSub{\Gamma_\Sc}{\Delta_\Sc}} \\ 
  \tqm{\Gamma_\Sc \SCon t : B}}
  {\tqm{(\sigma, t) : \IFSub{\Gamma_\Sc}{(\Delta_\Sc, B)}}}
\text{.}
\end{gathered}
\end{equation*}
These then allow us to substitute point types and sort terms via
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Delta_\Sc \SCon A} \\
  \tqm{\sigma : \IFSub{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\Gamma_\Sc \SCon A[\sigma]}}
\quad\text{and}\quad
\inferrule{\tqm{\Delta_\Sc \SCon t : B} \\
  \tqm{\sigma : \IFSub{\Gamma_\Sc}{\Delta_\Sc}}}
  {\tqm{\Gamma_\Sc \SCon t[\sigma] : B}}
\text{,}
\end{gathered}
\end{equation*}
obeying the usual rules for substitution
\begin{align*}
\tqm{\Pi_\Pc(\blm{T}, A)[\sigma]} &= \tqm{\Pi(\blm{T}, \blm{\lambda \tau. \tqm{A(\blm{\tau})[\sigma]}})} \text{,} \\
\tqm{\El(a)[\sigma]} &= \tqm{El(a[\sigma])} \text{,} \\
\tqm{(a \Rightarrow_\Pc A)[\sigma]} &= \tqm{a[\sigma] \Rightarrow_\Pc A[\sigma]} \text{,} \\
\tqm{\var(\vz)[\sigma, t]} &= \tqm{t} \text{,} \\
\tqm{\var(\vs(t))[\sigma, s]} &= \tqm{\var(t)[\sigma]} \text{, and} \\
\tqm{t(\tau)[\sigma]} &= \tqm{t[\sigma](\tau)} \text{.}
\end{align*}

\section{Algebras of Inductive Families}


