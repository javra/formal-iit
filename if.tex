\section{Signatures for Inductive Families}

Previous specifications of mutual inductive families have taken different approaches:
Some are based on the notion of a polynomial functor while others...

Applying the same principle as in the case of inductive-inductive types we want
to create a specification based on the contexts of type theory syntax.
We already saw that we can obtain such a specification by just restricting the
syntax for inductive-inductive types to not use the recursive $\Pi$-type for sorts,
but this approach doesn't capture the full %TODO
extent of inductive families being a much simpler concept than inductive-inductive
types.
Given the strategy of our recursion we want the specification to capture at least
the following features of inductive families:
\begin{itemize}
\item Sorts are either types of funcions over existing types.
\item Point constructor can also be indexed over existing (``external'') types.
\item Point constructors can refer to any sort being defined.
\end{itemize}

The first point above says that we want the type of \emph{sort types} \blm{\tqm{\Sc} : \UU}
to be inductively generated by a \emph{universe} token \tqm{\UU : \Sc} and a constructor
of external functions for sorts which are meant to be \emph{type families}:
\tqm{\Pi_\Sc(\blm{T}, B) : \Sc} for a type \blm{T : \UU} and a function
\tqm{B : \blm{T \to \tqm{\Sc}}}.
Note that in contrast to the sort types of inductive-inductive definitions these
do not depend on a context.

Instead, we say that a \emph{sort context} is just a list of sort types without
any interdependencies:
\begin{equation*}
\begin{gathered}
\inferrule{}{\tqm{\SCon \cdot_\Sc}}
\qquad
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{B : \Sc}}{\tqm{\SCon \Gamma_\Sc, B}}
\end{gathered}
\end{equation*}

In order to refer to sorts we introduce a simplified term calculus based on typed
de Bruijn indices for bound variables and an application operation for type families:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\SCon \Gamma_\Sc} \\ \tqm{B : \Sc}}{\tqm{\Gamma_\Sc, B \SCon \var(\vz) : B}}
\qquad
\inferrule{\tqm{\Gamma_\Sc \SCon \var(v) : B}}{\tqm{\Gamma_\Sc, B' \SCon \var(\vs(v)) : B}}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon t : \Pi_\Sc(\blm{T}, B)} \\ \blm{\tau : T}}
  {\tqm{\Gamma_\Sc \SCon t(\blm{\tau}) : B(\blm{\tau})}}
\end{gathered}
\end{equation*}

Point constructors will be represented by \emph{point types} over a given sort
context.
This means that opposite to inductive-inductive types, they cannot depend on
other point types.
The type formers we need are the element type for the universe \tqm{\UU}, an
external, non-recursive function type like the one we have for sorts, and an
internal function type used for recursive point constructors:
\begin{equation*}
\begin{gathered}
\inferrule{\tqm{\Gamma_\Sc \SCon a : \UU}}{\tqm{\Gamma_\Sc \SCon \El(a)}}
\qquad
\inferrule{\blm{T : \UU} \\ \blm{(\tau : T) \to \tqm{\Gamma_\Sc \SCon B(\blm{\tau})}}}
  {\tqm{\Gamma_\Sc \SCon \Pi_\Pc(\blm{T}, B)}}
\\[.7em]
\inferrule{\tqm{\Gamma_\Sc \SCon a : \UU} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\Gamma_\Sc \SCon a \Rightarrow_\Pc A}}
\end{gathered}
\end{equation*}

As a last building block of the syntax, we can now form full contexts consisting
of sort and point constructors.
Such a context \tqm{\Gamma} can be formed over a given sort context \tqm{\Gamma_\Sc}
which we will denote as a subscript to the turnstile or omit when inferrable.
The empty context can be formed over the empty sort context, an extension of
a context by a sort constructor happens in parallel to an extension of its sort
context, and an extension by a point constructor leaves the sort context fixed:
\begin{equation*}
\begin{gathered}
\inferrule{}{\tqm{\vdash_{\cdot_\Sc} \cdot}}
\qquad
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{B : \Sc}}
  {\tqm{\vdash_{\Gamma_\Sc, B} \Gamma, B}}
\qquad
\inferrule{\tqm{\vdash_{\Gamma_\Sc} \Gamma} \\ \tqm{\Gamma_\Sc \SCon A}}
  {\tqm{\vdash_{\Gamma_\Sc} \Gamma, A}}
\end{gathered}
\end{equation*}

\begin{remark}
While for the signatures of inductive-inductive types, contexts, types, and terms
depend on each other we can here define sort types, sort contexts, terms, point
types, and contexts in the presented order without referring to later constructions.
This means that unlike mentioned in Remark~\ref{rmk:iit-syntax}, we  can %TODO cite remark
internalize this syntax just using inductive families.

An Agda formalization of the syntax looks as follows, with variables and terms
separated:
\begin{agdacode}
data TyS : Set₁ where
  U  : TyS
  Π̂S : (T : Set) → (T → TyS) → TyS

data SCon : Set₁ where
  ∙c   : SCon
  _▶c_ : SCon → TyS → SCon

data Var : SCon → TyS → Set₁ where
  vvz : ∀{Γc}{B} → Var (Γc ▶c B) B
  vvs : ∀{Γc}{B}{B'} → Var Γc B → Var (Γc ▶c B') B

data Tm : SCon → TyS → Set₁ where
  var  : ∀{Γc}{A} → Var Γc A → Tm Γc A
  _\$S_ : ∀{Γc}{T}{B} → Tm Γc (Π̂S T B) → (α : T) → Tm Γc (B α)

data TyP : SCon → Set₁ where
  El   : ∀{Γc} → Tm Γc U → TyP Γc
  Π̂P   : ∀{Γc}(T : Set) → (T → TyP Γc) → TyP Γc
  _⇒P_ : ∀{Γc} → Tm Γc U → TyP Γc → TyP Γc

data Con : SCon → Set₁ where
  ∙    : Con ∙c
  _▶S_ : ∀{Γc} → Con Γc → (A : TyS) → Con (Γc ▶c A)
  _▶P_ : ∀{Γc} → Con Γc → (B : TyP Γc) → Con Γc
\end{agdacode}
%TODO remove backslash
\end{remark}


