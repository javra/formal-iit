We have seen in the previous chapter that the encode-decode method can be used
in a variety of cases when we want to make statements about the equality
types -- or \emph{path spaces} -- of higher inductive types.
Going through all necessary steps of such a proof can be somewhat tedious, but
part of it is very mechanical work.
One main goal of this chapter is to present a different method to
directly work with equality types of coequalizers and pushouts
(and construction based on these):
Since elimination rules such as one for coequalizers characterize only
the points  of the type, but in the constructors we create points
and equalities simultaeously, we believe that it is natural to hope for
an ``induction principle for equalities'' which is reminiscent of an elimination
rule.
More concretely, for our case of a coequalizer $\quot : \UU$ of a type $A : \UU$
and typal relation $\_\sim\_ : A \to A \to \UU$,
let us assume we are given a type family
\begin{equation*}
Q: \{a, b : A\} \to [a] = [b] \to \UU \text{.}
\end{equation*}
Is it possible to have simple-to-check conditions which are sufficient to
conclude $Q(q)$ for a general $q$ (instead of just $glue(s)$ for some $s : a \sim b$)?

\begin{remark}
Note that $Q$ above quantifies over two elements of $A$ and an equality of $\quot$.
If instead we asked the same question for a type family
\begin{equation*}
S: (x, y : \quot) \to x = y \to \UU \text{,}
\end{equation*}
the answer would be that we could the J-rule to populate this family by giving
$S(\refl_x)$.
The principle we want for the applications we presented is the version
where endpoints are ``restricted'' as above.
\end{remark}

It turns out that, like for the J-rule, there is a generalization of the above question.
We get this generalization by switching from an \emph{unbased} (or \emph{global}) type family
to a \emph{based} (or \emph{local}) one:
We can fix one of the two endpoints to be $[a_0] : \quot$ and replace $Q$
by a family which is indexed only \emph{once} over $A$:
\begin{equation}
P : (b : A) \to [a_0] = [b] \to \UU \text{.}
\end{equation}
Like for the two versions of the J-rule, a principle answering the based version
of the question also answers the unbased one, which is why we will focus
exclusively on the former.

In order to get some intuition for the subtleties of the equality types,
let us first look at a hypothetical principle which turns out to be wrong.
Usually, induction principles contain one case for every constructor,
the standard equality constructor is $\refl$ and with \textsc{Coeq-Intro2}, we
have one further path constructor $\glue$.
Thus, we might try whether it is sufficient to assume terms
\begin{align*}
r &: P(\refl_{[a_0]}) \text{ and}\\
p &: (b : A)(s : a_0 \sim b) \to P(\glue(s))
\end{align*}
to conclude that $(b : A)(q : [a_0] = [b]) \to P(q)$?
It turns out that this attempt fails:
Consider the relation $\sim$ on the natural numbers defined by
\begin{equation*}
(m \sim n) :\equiv m + 1 = n \text{.}
\end{equation*}
We can look at the coequalizer $\specialquot{\N}$.
Let us take $1 : \N$ as the base point and $P : (n : \N) \to ([0] = [n]) \to \UU$
defined by $P(n,q) :\equiv (n \geq 1)$.
The terms $r$ and $p$ are constructed easily, but at the same time, it is clear
that $P(0, \glue(k)\inv)$ is empty (where $k$ is a proof for $0 + 1 = 1$).

The above naïve suggestion was easy to disprove, but let us try to understand
why it was insufficient.
Equalities that come from $A$ can, by the J-rule, be assumed to be $\refl$;
these are sufficiently covered.
However this is not true for equalities that are generated using the $\glue$ constructor.
The counterexample uses the fact that we have not explicitely closed them under symmetry
and similarity -- we could have also used that we have not closed them
under transitivity.

How could we fix this? Given an equality $q$ in $\quot$, we can compose it
with $\glue(s)$ assuming the endpoints match.
This suggests that the induction principle we are looking for should assume
$Q(q) \to Q(q \ct \glue(s))$.
But we can also compose with $\glue(s)\inv$,
suggesting that we also need a function $Q(q)  \to Q(q \ct \glue(s)\inv)$.
The operations of composing with $\glue(s)$ and its inverse should furthermore
be inverse to each other,
wich motivates us to ask for only \emph{one} of them and require this one to be
an equivalence, i.\,e. $Q(q) \simeq Q(q \ct \glue(s))$.
This finally leads us to a valid induction principle, which is short, useful, and
comes with two $\beta$-rules.
Proving this princple is the main result of this chapter:

%\begin{restatable}[Induction for Coequalizer Equality]{thm}{main-thm}
\begin{thm}[Induction for Coequalizer Equality]\label{thm:paths-main-thm}
Assume $A$ and $\sim$ as before, a point $a_0 : A$, and we are further given
a type family
\begin{equation*}
P : (b : A) \to [a_0] = [b] \to \UU \text{,}
\end{equation*}
together with terms
\begin{align*}
r &: P(\refl_{[a_0]}) \text{ and} \\
e &: \{b, c : A\}(q : [a_0] = [b])(s : b \sim c) \to P(q) \simeq P(q \ct \glue(s)) \text{.}
\end{align*}
The we can counstruct a dependent function
\begin{equation*}
\ind_{r, e} : \{b : A\}(q : [a_0] = [b]) \to P(q)
\end{equation*}
with the following equalities reminiscent of $\beta$-rules:
\begin{align}
\ind_{r,e} (\refl_{[a_0]}) &= r \label{eq:paths-thm-based-first-beta} \\
\ind_{r,e}(q \ct \glue(s)) &= e (q,s, \mathsf{ind}_{r,e}(q)) \label{eq:paths-thm-based-second-beta} \text{.}
\end{align}
\end{thm}

\begin{remark}
The theorem can be proved in a way which makes the first $\beta$-rule hold judgmentally.
This is what we have done in our formalization, but we will refrain from checking
whether equalities hold strictly in this chapter.
\end{remark}

In the following sections we will first prove this main result (Chapter~\ref{sec:paths-main}),
then modify it to obtain a version for pushouts (Chapter~\ref{sec:paths-pushout}),
and present a few smaller applications (Chapter~\ref{sec:paths-applications})
by characterizing the loop space of the circle and proving that
pushouts preserve embeddings,
before applying the approach to state a version of the Seifert-van Kampen theorem
which instead of groupoids refers to \emph{higher} fundamental groupoids
(Chapter~\ref{sec:paths-svk}).
Most of the contents have been formalized in Lean, an effort which we will
comment on in Chapter~\ref{sec:paths-lean}.

\section{The Main Theorem: Path Spaces in Coequalizers}\label{sec:paths-main}

We will first formulate and prove the non-dependent version of the main result,
by developing the corresponding categorical framework inside type theory.
This then allows us to derive the induction principle as stated in Theorem~\ref{thm:paths-main-thm}.

Using categorical ideas to structure constructions and reason inside type
theory is standard.
The dependent elimination principle can usually equivalently be formulated
as a recursion (or \emph{non-dependent} elimination) principle together
with a uniqueness principle,
often phrased as a \emph{universal property}.
A principled way of doing this is to define objects and morphisms of a
category; the statement then is that the inductive type in question is
(homotopy) initial in this category.
For the specific case of homotopy type theory, the connection between
induction and initiality has been shown by
\cite{awodeyGamSoja_hoAlgs} for inductive types,
and by \cite{DBLP:journals/corr/Sojakova14} for some higher inductive types.

However, category theory in homotopy type theory is subtle.
The ``obvious'' naïve definition of a category without imposing any
truncation levels on objects and morphisms (sometimes called a
\emph{wild category}) is not always a well-behaved notion.
For example the slice of a wild category is not a wild category anymore.
The underlying reason is that the identity and associativity
equalities do now behave like laws (or properties) but like higher morphisms
in a \emph{higher category} where additional coherences are required.
One approach to higher categories in homotopy type theory
is discussed by~\cite{Capriotti2017}.
Alternatively, the \emph{univalent categories} by~\cite{ahrens_rezk}
restrict the truncation levels to avoid the issue.
For us,
truncating is not a suitable strategy since it would not allow us to prove our general result.

Although not well-behaved in general, wild categories are still a useful tool
for us.
We do \emph{not} think of them as ``bad ordinary categories'' but instead
as an approximation to $(\infty,1)$-categories, where most of the
higher data is omitted.
However, since none of our constructions require us to actually \emph{use}
the omitted data, we are able to get away with this.
Most importantly,
we can talk about the concept of homotopy initiality without ever referring
to higher morphisms.
Technically, we do not even need associativity -- it could be excluded from the
following definition without consequences for the rest of the paper.

\begin{defn}[Wild Categories]
A \textbf{wild category} $\CatA$, for simplicity henceforth simply
\textbf{category}, consists of a type $\bproj{\CatA} : \UU$ of objects; for
objects $X, Y : \bproj \CatA$ a type $\CatA(X, Y)$ of morphisms;
a composition operator $\circ$ and identities of the following obvious types
\begin{align*}
\_\circ\_ &: \{X, Y, Z : \bproj \CatA\} \to \CatA(Y, Z) \to \CatA(X, Y) \to \CatA(X, Z) \text{,} \\
\id &: \{X : \proj \CatA\} \to \CatA(X, X) \text{,}
\end{align*}
together with the two standard equalities for the identities and
one equality which states that $\circ$ is associative:
\begin{align*}
\id \circ f &= f \text{,}\\
f \circ \id &= f \text{, and}\\
(f \circ g) \circ h &= f \circ (g \circ h) \text{.}
\end{align*}
\end{defn}

Initiality in wild categories is one of the few notions which are still well-behaved
in wild categories:
We can define them in terms of contractability.
\begin{defn}[Initiality]
An object $X$ of a category $\CatA$ is called \textbf{initial} if for every other
object $Y$ the type of morphisms $\CatA(X, Y)$ is contractible.
\end{defn}

\section{Equality in Pushouts}\label{sec:paths-pushout}

\section{First Applications}\label{sec:paths-applications}

\section{Free Groupoids and a Higher Seifert-van Kampen Theorem}\label{sec:paths-svk}

\section{Formalization in Lean}\label{sec:paths-lean}






