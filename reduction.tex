\begin{sidewaysfigure}
\centering
\tikzset{
    state/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           minimum height=2em,
           inner sep=2pt,
           text centered,
           },
}
\begin{tikzpicture}[->, >=stealth]
\node[state](IIT){
  \color{ForestGreen}
  \begin{tabular}{l}
  \textbf{Inductive-Inductive Syntax} \\
  \hline
  $\UU$, $\El$, $\Pi$, $\hat{\Pi}$
  \end{tabular}
};
\node[state,
  node distance=6\diagx,
  right of=IIT](IF)
{
  \color{Blue}
  \begin{tabular}{l}
  \textbf{Inductive-Inductive Syntax} \\
  \hline
  Sorts $\hat{\Pi}_\Sc$, $\UU$ \\
  \hdashline
  Points $\El$, $\hat{\Pi}_\Pc$, $\Rightarrow_\Pc$
  \end{tabular}
};
\node[state,
  node distance=3\diagy,
  xshift=3\diagx,
  below of=IIT](TTT)
{
  \begin{tabular}{l}
  \textbf{Target Type Theory} \\
  \hline
  $\emptytype, \unit, \twotype, \Sigma, \Pi, \mathsf{IW}$
  \end{tabular}
};
\path (IIT) edge node[anchor=south,above]{$\tqm{\grm{\Gamma}^\EE}, \tqm{\grm{\Gamma}^\WW}(\blgamma), 
  \tqm{\grm{\Gamma}^\RR}(\gamma, \gamma^\CC) $} (IF);
\path (IIT) edge[bend right=20]
  node[anchor=south,left]{${\grm{\Gamma}^\CC}, {\grm{\Gamma}^\MM}(\blgamma, \delta), 
  {\grm{\Gamma}^\Sg}(\gamma, \delta) $} (TTT);
\path (IF) edge[bend left=20]
  node[anchor=south,right]{${\tqm{\Gamma}^\CC}, {\tqm{\Gamma}^\MM},
    \tqm{\Gamma}^\DD, \tqm{\Gamma}^\SS $} (TTT);
\path (TTT) edge[bend left=20, dashed]
  node[anchor=south,left]{Provides domain for \tqm{\hat{\Pi}}, \grm{\hat{\Pi}}} (IF);
\path (TTT) edge[bend right=20, dashed] (IIT);
\end{tikzpicture}
\caption{The Type Theories used in this Chapter.}\label{fig:red-schema}
\end{sidewaysfigure}

We have now learned how we can express all inductive-inductive types
and all inductive family by the means of signature consisting of the contexts
of type theories which are made specifically for this purpose.
Now we want to pursue the question of whether every inductive-inductive type
can be represented in a type theory that only supports indexed W-types, and thus
inductive families.

To explore how we can transform an inductive-inductive signature into a sequence
of constructions in inductive families, we will have to deal with four type theories:
We imagine that we live in an \emph{ambient type theory} in which all of our constructions
will take place.
This type theory must be powerful enough to represent the syntaxes of the other
type theory we use, and thus should support quotient inductive types (cf. Remark TODO).
Then, we have what we call \emph{target type theory}, which is the language in
which the reduced types should be available.
This language must at least contain indexed W-types.
At last, we also have the two ``domain specific'' type theories which we use
to encode inductive-inductive types and inductive families.
A graphical overview of the relations between these last three type theories
can be seen in \Cref{fig:red-schema}

\section{Example: Type Theory Syntax}\label{sec:red-ex}

Before we explain the reduction in the general case, it is useful to first
look at how it works in a special case.
As a prime example we chose Example~\ref{ex:ttintt} which describes
the contexts and types of a type theoretic syntax with a base type and $\Pi$-types.
To recall the specifics of the example: We want to define a type
$Con : \UU$ of contexts and a type family $Ty : Con \to \UU$ which gives the
type of types over a context.
These are populated by constructors, providing the empty context,
context extension, the base type former and the type former for the $\Pi$-types:
\begin{align*}
nil &: Con \text{,} \\
ext &: (\Gamma : Con) \to Ty(\Gamma) \to Con \text{,} \\
unit &: (\Gamma : Con) \to Ty(\Gamma) \text{, and} \\
pi &: (\Gamma : Con) (A : Ty(\Gamma)) \to Ty(ext(\Gamma, A)) \to Ty(\gamma) \text{.}
\end{align*}

Since the dependency between the two sorts $Con$ and $Ty$ can not be represented
directly with inductive families, we might, as a first approximation, simply forget
about all the indices of the sort -- that is, the $Con$-index in $Ty$ --
and adapt the point constructors accordingly:
Let $Con' : \UU$ and $Ty' : \UU$ be plain types generated by the following four
mutually dependent constructors:
\begin{align*}
nil' &: Con' \text{,} \\
ext' &: Con' \to Ty' \to Con' \text{,} \\
unit' &: Con' \to Ty' \text{, and} \\
pi' &: Con' \to Ty' \to Ty' \to Ty' \text{.}
\end{align*}

But this transformation, which we will call \emph{type erasure} loses important
information about the constructed types:
In the syntax generated by $Con'$ and $Ty'$, all types exist in the same context.
There is no way to tell that the codomain of the $\Pi$-types may depend on its domain,
and that the $\Pi$-type itself exists in the same context as its domain.
This justifies that we might call the above types the \emph{presyntax} associated
to the syntax given by $Con$ and $Ty$, consisting of \emph{precontexts} and
\emph{pretypes}.

To counteract this shortcoming, we reintroduce the \emph{typing relation} as a pair of
predicates over the presyntax.
These inductively defined predicates capture whether an instance of $Con'$ or $Ty'$ is \emph{wellformed} according to the original typing.
For the contexts, this is a simple property $w_{Con} : Con' \to \UU$, while for
types, it needs to state what precontext a pretype is wellformed in:
$w_{Ty} : Con' \to Ty' \to \UU$.
Note that these are inductive families since the definition of all indexing types
is concluded at the point of the definition of $W_{Con}$ and $W_{Ty}$.
The point constructors for the wellformedness predicates simply state that
is preserved by all constructors of $Con'$ and $Ty'$, in the case of $Ty'$ given the
correct index:
\begin{align*}
w_{nil} &: W_{Con}(nil') \text{,} \\
w_{ext} &: \{\Gamma : Con'\} \{A : Ty'\}
    \to W_{Con}(\Gamma) \to W_{Ty}(\Gamma, A) \\
  & \qquad \to W_{Con}(ext'(\Gamma, A)) \text{,}\\
w_{unit} &: \{\Gamma : Con'\} \to W_{Con}(\Gamma) \to W_{Ty}(unit'(\Gamma)) \text{, and}\\
w_{pi} &: \{\Gamma : Con'\} \{A, B : Ty'\} \to
    W_{Con}(\Gamma) \\
  & \qquad \to W_{Ty}(\Gamma, A) \to W_{Ty}(ext'(\Gamma, A), B)
    \to W_{Ty}(\Gamma, pi'(\Gamma, A, B)) \text{.}
\end{align*}

Now we can use the predicates to cut out the correct subset of $Con'$ and
$Ty'$ which we deem correct:
A context is a precontext together with a proof of its wellformedness just
as a type is a pretype together with a welltypedness witness:
\begin{align*}
Con &:\equiv (\Gamma : Con') \times W_{Con}(\Gamma) \text{ and}\\
Ty(\Gamma) &:\equiv (A : Ty') \times W_{Ty}(\pr_1(\Gamma), A) \text{.}
\end{align*}
The four point constructors are then easy to define as pairs:
\begin{align*}
nil &:\equiv (nil', w_{nil}) \text{,}\\
ext(\Gamma, A) &:\equiv \left(ext'(\pr_1(\Gamma),
    \pr_1(A)), w_{ext}(\pr_2(\Gamma), \pr_2(A)) \right) \text{,}\\
unit(\Gamma) &:\equiv \left(unit'(\pr_1(\Gamma)),
    w_{unit}(\pr_2(\Gamma)) \right) \text{, and}\\
pi(\Gamma, A, B) &:\equiv \left(pi'(\pr_1(\Gamma), \pr_1(A), \pr_1(B)),
   w_{pi}(\pr_2(\Gamma), \pr_2(A), \pr_2(B)) \right) \text{.}
\end{align*}

This definition clearly has the correct type signature but for it to be the correct
replacement for the intended inductive-inductive type,
we also need to construct its eliminator:
For any given $C : \UU$ and $T : C \to \UU$ with
\begin{align*}
n &: C \text{,} \\
e &: (\gamma : C) \to T(\gamma) \to C \text{,} \\
u &: (\gamma : C) \to T(\gamma) \text{, and} \\
p &: (\gamma : C) (a : T(\gamma)) \to T(e(\gamma, a)) \to T(\gamma) \text{,}
\end{align*}
we need to construct functions $\rec^{Con} : Con \to C$ and 
$\rec^{Ty} : \{\Gamma : Con\} \to Ty(\Gamma) \to T(\rec^{Con}(\Gamma))$ such
that the preservation of the point constructors is manifested in the
following $\beta$-rules:
\begin{align*}
\rec^{Con}(nil)
  &= n \text{,} \\
\rec^{Con}(ext(\Gamma, A))
  &= e(\rec^{Con}(\Gamma), \rec^{Ty}(A)) \text{,} \\
\rec^{Ty}(unit(\Gamma))
  &= u(\rec^{Con}(\Gamma)) \text{, and} \\
\rec^{Ty}(pi(\Gamma, A, B))
  &= p(\rec^{Con}(\Gamma), \rec^{Ty}(A), \rec^{Ty}(B)) \text{.}
\end{align*}

It is difficult to define these functions straight away, but it turns out that
we will be able to define an \emph{eliminator relation} between the presyntax
$(Con', Ty')$ and the motive $(C, T)$ which we can show restricts to the graph
of a function on the wellformed parts of the syntax.
Just like the wellformedness predicate, this relation is defined inductively
as a type family over the presyntax.
The signature of this relation is $R_{Con} : Con' \to C \to \UU$ for contexts
and $R_{Ty} : (\Gamma : Ty') \{\gamma : C\} \to T(\gamma) \to \UU$ and the
constructors for the relation state that relatedness is preserved by each
constructor of the presyntax:
\begin{align*}
r_{nil} 
  &: R_{Con}(nil', n) \text{,} \\
r_{ext}(\Gamma, A, \gamma, a) 
  &: R_{Con}(\Gamma, \gamma) \to R_{Ty}(A, a)
    \to R_{Con}(ext'(\Gamma, A), e(\gamma, a)) \text{,}\\
r_{unit}(\Gamma, \gamma)
  &: R_{Con}(\Gamma, \gamma) \to R_{Ty}(unit'(\Gamma), u(\gamma)) \text{, and} \\
r_{pi}(\Gamma, A, B, \gamma, a, b)
  &: R_{Con}(\Gamma, \gamma) \to R_{Ty}(A, a) \to R_{Ty}(B, b) \\
  & \qquad \to R_{Ty}(pi'(\Gamma, A, B), p(\gamma, a, b)) \text{.}
\end{align*}

Since we want a morphism to the model $(C, T, n, e, u, p)$ instead of a relation,
we now need to prove that the relation is in fact the graph of a function --
i.\,e. it is right-unique and left-total.

\begin{lemma}\label{lem:red-ex-right-unique}
The relation is right-unique on contexts and types. That is, for
$\gamma, \gamma' : C$ with $R_{Con}(\Gamma, \gamma)$ and $R_{Con}(\Gamma, \gamma')$,
we have $\gamma = \gamma'$, and, regarding types, for $\gamma : C$ and
$a, a' : T(\gamma)$, with $R_{Ty}(A, a)$ and $R_{Ty}(A, a')$,
we have $a = a'$.
\end{lemma}

\begin{proof}
Let us first apply induction on the presyntactic variables $\Gamma$ and $A$,
respectively.
This leaves us to consider the cases of the four constructors of $Con'$ and $Ty'$.
For the case of $nil'$, we observe that the only constructor resulting in
$R_{Con}(nil', \gamma)$ for some $\gamma$ is $r_{nil} : R_{Con}(nil, n)$ and we
can conclude that both $\gamma$ and $\gamma'$ must be equal to $n$.
The reasoning analogously applies to the other cases as well:
There is only one relatedness constructor for each of the constructors of the
presyntax, so we can always obtain the right-uniqueness for all arguments via
the induction hypothesis and, by congruence, infer that the uniqueness carries
over to the constructor in consideration.
As an example, in the case of $\delta$ and $\delta'$ with $R_{Con}(ext'(\Gamma, A), \delta)$
and $R_{Con}(ext'(\Gamma, A), \delta')$, we first conclude that
$\delta = e(\gamma, a)$ and $\delta' = e(\gamma', a')$ for some $\gamma$, $\gamma'$,
$a$, and $a'$, we see that for these $R_{Con}(\Gamma, \gamma)$, $R_{Con}(\Gamma, \gamma')$,
$R_{Ty}(A, a)$, and $R_{Ty}(A, a')$ have to hold and from this we infer
that $\gamma = \gamma'$ as well as $a = a'$ and thus $\delta = \delta'$.
\end{proof}

\begin{lemma}\label{lem:red-ex-total}
The eliminator relation is left-total on wellformed presyntax:
For $\Gamma : Con'$ with $W_{Con}(\Gamma)$ there is $\gamma : C$
such that $R_{Con}(\Gamma, \gamma)$.
Analogously, for $A : Ty'(\Gamma)$ with $W_{Ty}(\Gamma, A)$
and $\gamma : C$ with $R_{Con}(\Gamma, \gamma)$
there is $a : T(\gamma)$
such that $R_{Ty}(A, a)$.
\end{lemma}

\begin{proof}
Again, we first perform induction on the presyntactic argument to the statement
-- that is, $\Gamma$ or $A$.
The case of $nil'$ is trivial by providing $n$ and $r_{nil}$.
So let us look at the case of $ext'(\Gamma, A)$.
From the induction hypothesis, we get witnesses for the wellformedness of the
arguments in the form of $W_{Con}(\Gamma)$ and $W_{Ty}(\Gamma, A)$,
as well as related data from the algebra:
$\gamma : C$ with $R_{Con}(\Gamma, \gamma)$, and
$a : T(\gamma)$ with $R_{Ty}(A, a)$.
But this is all the input to use $r_{ext}$ to obtain $R_{Con}(ext'(\Gamma, A), e(\gamma, a))$.
The other two cases can be proved analogously.
\end{proof}

The left-totality will suffice to define the recursor functions by simply setting
$\rec^{Con}(\Gamma)$ and $\rec^{Ty}(A)$ to be the respective witnesses gained from
Lemma~\ref{lem:red-ex-total}.
This means that the $\beta$-rule for the non-recursive constructor $nil$ will be
definitional, while to prove $\beta$-rules for the recursive constructors will
require the use of Lemma~\ref{lem:red-ex-right-unique}:

To prove, for example, that $\rec^{Con}(ext(\Gamma, A))
= e(\rec^{Con}(\Gamma), \rec^{Ty}(A))$ holds, we observe that both the left-hand side
and the right-hand side provide elements in $C$ which by $R_{Con}$ are related
to $ext'(\Gamma, A)$, so the lemma give us the desired equality.

\section{Type Erasure}\label{sec:red-e}

As seen in the example, the first step to prove the reducability is to formally
define the operation which we will call \emph{flattening} or -- inspired by
the syntax example -- \emph{type erasure}.
This operation strips away any dependencies between the sorts of a signature
as well as all external indices to sorts.
The operation should take arbitrary inductive-inductive signatures (contexts) and
return signatures for inductive families.
Let us look at what type erasure should do with our running examples:

\begin{example}[Natural Numbers]\label{ex:red-e-nat}
Since the inductive-inductive signature of the \emph{natural numbers}~\ref{ex:ii-syntax-nat} doesn't
contain any indexed sorts, type erasure should ``do nothing'' with it.
That is, returning the sort context and point context of the inductive family
syntax which looks like a obvious correspondence to it (cf. Example~\ref{ex:if-natvec})
while ignoring all entries of the other kind:
Let
\begin{equation*}
\grm{\Gamma_{nat}} 
  :\equiv \grm{(\cdot,\, \UU,\, \El(\vz),\, \Pi\left(\vs(\vz),\, \El(\vs(\vs(\vz)))\right))}
  \text{.}
\end{equation*}
We want to have the following split into sort types and point types:
\begin{align*}
\tqm{\grm{\Gamma_{nat}}^\EE_\Sc}
 &= \tqm{(\cdot_\Sc,\, \UU)} \text{ and} \\
\tqm{\grm{\Gamma_{nat}}^\EE}
 &= \tqm{(\cdot,\, \El(\var(\vz)),\, \var(\vz) \Rightarrow_\Pc \El(\var(\vz)))} \text{.}
\end{align*}
\end{example}

\begin{example}[Vectors]\label{ex:red-e-vec}
In the example of vectors \ref{ex:ii-syntax-vec} we need to erase the natural numbers
index of the only sort under consideration:
\begin{align*}
\tqm{\grm{\Gamma_{vec}}^\EE_\Sc}
 &= \tqm{(\cdot_\Sc,\, \UU)} \text{ and} \\
\tqm{\grm{\Gamma_{vec}}^\EE}
  &= \tqm{(\cdot,\, \El(\var(\vz)),\, 
    \ExtPiP{a : A}{\ExtPiP{n : \N}{
    \var(\vz) \Rightarrow_\Pc \El(\var(\vz))}})} \text{.}
\end{align*}
Note that the erasure of the vectors does not coincide with the vectors represented
as an inductive family (Example~\ref{ex:if-natvec}), because its sort lacks the
indexing over the natural numbers.
In fact, it's easy to see that the algebras of this signature would not be isomorphic
to the type of lists over the type \blm{A \times \N}.
\end{example}

\begin{example}[Type Theory Syntax]
In our syntax we will now see why the operation is called ``type erasure'':
%TODO
\end{example}

To go from examples to the general case, we will present the different components
of the type erasure operation in roughly the same order in which they appear in
Section~\ref{sec:ii-syntax}, most often needing to distinguish between sort
and point constructors.

\begin{defn}[Type Erasure]
First of all, each context will need to be split into a sort context and a point
context:
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}
  {\tqm{\SCon \grm{\Gamma}^\EE_\Sc}}
\qquad
\inferrule{\grm{\vdash \Gamma}}
  {\tqm{\vdash_{\grm{\Gamma}^\EE_\Sc} \grm{\Gamma}^\EE }}
\end{equation*}
To descent down the components of the contexts, we will need to define the operation
on types as well.
Since we are erasing all information from the sorts, we will only need this for
point types, though.
Unsurprisingly, we want them to be translated to point types in the appropriate
sort context:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash A :: \Pc}}
  {\tqm{\grm{\Gamma}^\EE_\Sc \SCon \grm{A}^\EE :: \Pc}}
\end{equation*}
Using this we will be able to define the operation creating sort contexts by
\begin{align*}
\tqm{\grm{\cdot}^\EE_\Sc}
  &:\equiv\tqm{\cdot_\Sc} \text{,} \\
\tqm{\grm{(\Gamma,\, B)}^\EE_\Sc}
  &:\equiv \tqm{\left(\grm{\Gamma}^\EE_\Sc,\, \grm{\UU}^\EE_\Sc\right)} \text{ for \grm{B :: \Sc}, and} \\
\tqm{\grm{(\Gamma,\, A)}^\EE_\Sc}
  &:\equiv \tqm{\grm{\Gamma}^\EE_\Sc} \text{ for \grm{A :: \Pc}.}
\end{align*}
The generated point context over this sort context has to be extended in the case
where the input is an extension by a point type.
In the case where it is an extension by a sort type, we want to return the
unextended context, but to make up for the definition above, we need to weaken
to account for the extension of the resulting sort context:
\begin{align*}
\tqm{\grm{\cdot}^\EE}
  &:\equiv\tqm{\cdot} \text{,} \\
\tqm{\grm{(\Gamma,\, B)}^\EE}
  &:\equiv \tqm{\grm{\Gamma}^\EE[\wk_{\id}]} \text{ for \grm{B :: \Sc}, and} \\
\tqm{\grm{(\Gamma,\, A)}^\EE}
  &:\equiv \tqm{\left(\grm{\Gamma}^\EE,\, \grm{A}^\EE\right)} \text{ for \grm{A :: \Pc}.}
\end{align*}
So how do we define \tqm{\grm{A}^\EE} for a point type \grm{A}?
The fact the we have to recurse on \grm{\El(a)} makes it clear that we will have
to extend our operation to terms of sort types at least.
That is, together with \tqm{\grm{A}^\EE} we also need the following:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash t : B :: \Sc}}
  {\tqm{\grm{\Gamma}^\EE_\Sc \SCon \grm{t}^\EE : \UU}}
\end{equation*}
And indeed, with this we can set
\begin{align*}
\tqm{\grm{\El(a)}^\EE}
  &:\equiv \tqm{\El(\grm{a}^\EE)} \text{.}
\end{align*}
For recursive $\Pi$-types, we need only care about the ones yielding point types.
Note that the operation turns a $\Pi$-type into a non-dependent function type!
\begin{align*}
\tqm{\grm{\Pi(a, A)}^\EE}
  &:\equiv \tqm{\grm{a}^\EE \Rightarrow_\Pc \grm{A}^\EE}
\end{align*}
Since we forgot about the indexing of sort types, erasure of sort-kinded application terms
is just erasure of its $\Pi$-type term:
\begin{align*}
\tqm{\grm{\IIapp(f)}^\EE}
  &:\equiv \tqm{\grm{f}^\EE} \text{ for \grm{\Gamma \vdash f : \Pi(a, B) :: \Sc}.}
\end{align*}
External $\Pi$-types convert directly into their
respective counterparts in the syntax of inductive families.
For application of terms of sort-kinded $\Pi$-types we need to erase the argument
since we erased the $\Pi$-type itself.
\begin{align*}
\tqm{\grm{\ExtPi{T}{A}}^\EE}
  &:\equiv \tqm{\ExtPiP{T}{\blm{\lambda \tau.\, }\grm{A(\bltau)}^\EE}} \text{, and} \\
\tqm{\grm{f(\bltau)}^\EE}
  &:\equiv \tqm{\grm{f}^\EE} \text{ for \grm{\Gamma \vdash f : \ExtPi{T}{B} : \Sc}}
\end{align*} %TODO this is a bit confusing since the application is for sorts and the types for points
Defining the erasure on point types and sort terms pulled back along a substitution,
we see that we will also need to erase entire sort substitutions.
This is achieved by extending the operation as follows:
\begin{equation*}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}}}
  {\tqm{\IISub{\grm{\sigma}^\EE_\Sc}{\grm{\Gamma}^\EE_\Sc}{\grm{\Delta}^\EE_\Sc}}}
\end{equation*}
We will then be able to use this in a straight forward way to define the pullbacks:
\begin{align*}
\tqm{\grm{A[\sigma]}^\EE}
  &:\equiv \tqm{\grm{A}^\EE[\grm{\sigma}^\EE_\Sc]}
  & \text{ for \grm{\Gamma \vdash A :: \Pc} and} \\
\tqm{\grm{t[\sigma]}^\EE}
  &:\equiv \tqm{\grm{t}^\EE[\grm{\sigma}^\EE_\Sc]}
  & \text{ for \grm{\Gamma \vdash t : B :: \Sc}.}
\end{align*}
Erasure of substitutions is built recursively, ignoring point types.
Likewise, the first projection will ignore point types:
\begin{align*}\label{eq:red-e-sub}
\tqm{\grm{\id}^\EE_\Sc}
  &:\equiv \tqm{\id} \text{,}
  & \\
\tqm{\grm{(\sigma \circ \delta)}^\EE_\Sc}
  &:\equiv \tqm{\grm{\sigma}^\EE_\Sc \circ \grm{\delta}^\EE_\Sc} \text{,}
  & \\
\tqm{\grm{\epsilon}^\EE_\Sc}
  &:\equiv \tqm{\epsilon} \text{,}
  & \\
\tqm{\grm{(\sigma,\, t)}^\EE_\Sc}
  &:\equiv \tqm{(\grm{\sigma}^\EE_\Sc,\, \grm{t}^\EE)}
  & \text{ for \grm{\Gamma \vdash t : B[\sigma] :: \Sc},} \\
\tqm{\grm{(\sigma,\, t)}^\EE_\Sc}
  &:\equiv \tqm{\grm{\sigma}^\EE_\Sc}
  & \text{ for \grm{\Gamma \vdash t : A[\sigma] :: \Pc},} \\
\tqm{\grm{\pi_1(\sigma)}^\EE_\Sc}
  &:\equiv \tqm{\pi_1(\grm{\sigma}^\EE_\Sc)}
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, B :: \Sc)}},} \\
\tqm{\grm{\pi_1(\sigma)}^\EE_\Sc}
  &:\equiv \tqm{\grm{\sigma}^\EE_\Sc}
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, A :: \Pc)}}, and} \\
\tqm{\grm{\pi_2(\sigma)}^\EE}
  &:\equiv \tqm{\pi_2(\grm{\sigma}^\EE_\Sc)} \text{.}
  &
\end{align*} %TODO laws
This concludes the definition of the erasure operation.
\end{defn} %TODO example derivations

For the steps that follow it will be necessary to equip the \emph{algebras}
of the resulting signatures with a substitution calculus that also considers
point contexts instead of only sort contexts.
To this end, we extend the operation of type erasure by assigning a map between
the types of algebras of the erasure to each substitution.
To be able to build these maps, we furthermore need to find a way how to get an
element of the algebra of point type for any given term of this type.

\begin{defn}[Erasure for Point Substitutions]\label{def:red-e-points}
We define the following operation on substitutions and terms of point types:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc}^\AA }
  {\grm{\sigma}^\EE : \tqm{\grm{\Gamma}^\EE}^\AA(\gamma_\Sc)
    \to \tqm{\grm{\Delta}^\EE}^\AA\left(\grm{\sigma}^\EE_\Sc(\gamma_\Sc)\right)}
\\[.7em]
\inferrule{\grm{\Gamma \vdash t : A :: \Pc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc}^\AA }
  {\grm{t}^\EE: \tqm{\grm{\Gamma}^\EE}^\AA(\gamma_\Sc) \to \tqm{\grm{A}^\EE}^\CC(\gamma_\Sc)}
\end{gathered}
\end{equation*}
While in for \tqm{\grm{\sigma}^\EE_\Sc} we ignored point constructors,
this time we will to the opposite and ignore all sort constructors:
\begin{align*}
\grm{\id}^\EE(\gamma)
  &:\equiv \gamma \text{,} \\
\grm{\sigma \circ \delta}^\EE(\gamma)
  &:\equiv \grm{\sigma}^\EE\left(\grm{\delta}^\EE(\gamma)\right) \text{,} \\
\grm{\epsilon}^\EE(\gamma)
  &:\equiv \star \text{,} \\
\grm{(\sigma,\, t)}^\EE(\gamma)
  &:\equiv \grm{\sigma}^\EE(\gamma)
  & \text{ for \grm{\Gamma \vdash t : B[\sigma] :: \Sc },} \\
\grm{(\sigma,\, t)}^\EE(\gamma)
  &:\equiv \left(\grm{\sigma}^\EE(\gamma), \grm{t}^\EE(\gamma)\right)
  & \text{ for \grm{\Gamma \vdash t : A[\sigma] :: \Pc},} \\
\grm{\pi_1(\sigma)}^\EE(\gamma)
  &:\equiv \grm{\sigma}^\EE(\gamma)
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, B :: \Sc)}},} \\
\grm{\pi_1(\sigma)}^\EE(\gamma, \alpha)
  &:\equiv \grm{\sigma}^\EE(\gamma)
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, A :: \Pc)}}.}
\end{align*}
On point constructors we descend recursively by following the structure of the
respective algebra:
\begin{align*}
\grm{\IIapp(f)}^\EE(\gamma, \alpha)
  &:\equiv \grm{f}^\EE(\gamma)(\alpha)
  & \text{ for \grm{\Gamma \vdash f : \Pi(a, A :: \Pc)},} \\
\grm{f(\bltau)}^\EE(\gamma)
  &:\equiv \grm{f}^\EE(\gamma)(\tau)
  & \text{ for \grm{\Gamma \vdash f : \ExtPiP{T}{A}},} \\
\grm{t[\sigma]}^\EE(\gamma)
  &:\equiv \grm{t}^\EE(\grm{\sigma}^\EE(\gamma))
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{\Delta}}, and} \\
\grm{\pi_2(\sigma)}(\gamma)
  &:\equiv \pr_2(\grm{\sigma}^\EE(\gamma))
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, A :: \Pc)}}.}
\end{align*}
\end{defn}

\section{The Wellformedness Predicate}\label{sec:red-w}

To remove the ambiguity created by the type erasure we will now have to find
a way to select those instances of the types which are ``wellformed'' in the
sense that the lie in the correct fibers of dependent sorts.
This predicate will be a proposition dependent on a realization of the erased
signature, i.\,e. on contexts, it will be a function on the type of algebras
of the erasure.
It is important keep this dependencies and not only to use the initial such
algebra, since when we will recursively define this wellformedness predicate,
the corresponding piece of signature will not always be initial
-- in the same way in which a projection of an initial algebra is not necessarily
initial anymore.

\begin{example}[Natural Numbers]\label{ex:red-w-nat}
Taking up the example of \grm{\Gamma_{nat}} from \ref{ex:red-e-nat},
we observe that algebras of \tqm{\grm{\Gamma_{nat}}^\EE_\Sc} take the form of
$(\star, N)$ with $N : \UU$ and, given $N$, those of
\tqm{\grm{\Gamma_{nat}}^\EE} are of the form $(\star, z, s)$ with
$z : N$ and $s : N \to N$.
Our wellformedness predicate in this case will encode a type family on $N$, inductively
populated by elements ``over'' $z$ and $n$.
The code for its sort and point constructors looks as follows:
\begin{align*}
\tqm{\grm{\Gamma_{nat}}^\WW_\Sc}(\star, z, s)
  &= \tqm{\left( \cdot_\Sc,\, \ExtPiS{N}{\UU} \right)} \text{ and} \\
\tqm{\grm{\Gamma_{nat}}^\WW}(\star, z, s)
  &= \tqm{\left( \cdot,\,  \El(\var(\vz)(\blm{z})),\,
    \ExtPiP{n : N}{\var(\vz)(\blm{n}) \Rightarrow_\Pc \El(\var(\vz)(\blm{s(n)}))} \right)}
\end{align*} %TODO
It's easy to see that the initial algebra of this signature is nothing more than
the trivial (final) type family on $N$.
\end{example}

\begin{example}[Vectors]\label{ex:red-w-vec}
For vectors on a type $A : \UU$, the duties of the wellformedness predicate are less trivial:
We have to add back the length information which we erased, as described in
\ref{ex:red-e-vec}:
Empty vectors should have length zero and appending an element should increase its
length by one.
This can be achieved by, given the data from an erasure algebra in the form of
$V : \UU$, $n: V$, and $c : A \to \N \to V \to V$,
having a predicate encoded by
\begin{equation*}
\tqm{\grm{\Gamma_{vec}}^\WW_\Sc}(\star, n, c)
  = \tqm{\left(\cdot_\Sc,\, \ExtPiS{n : \N}{\ExtPiS{v : V}{\UU}} \right)} \text{,}
\end{equation*}
with point constructors that ensure the correct lengh by setting $\tqm{\grm{\Gamma_{vec}}^\WW}(\star, n, c)$ to be the point context
\begin{equation*}
\begin{gathered}
\tqm{\cdot,\, \El(\var(\vz)(\blm{0}, \blm{n})),\,} \\
\tqm{\ExtPiP{a: A}{\ExtPiP{n : \N}{\ExtPiP{v : V}{\var(\vz)(\blm{n}, \blm{v}) \Rightarrow_\Pc 
  \El(\var(\vz)(\blm{n + 1}, \blm{c(a, n, v)}) ) } } } } \text{.}
\end{gathered}
\end{equation*}
\end{example}

Like for the type erasure, we will now proceed to generalize this to arbitrary
inductive-inductive types.

\begin{defn}[Wellformedness Predicates]
Again, we start by considering the resulting type on contexts.
Clearly, we want the operation to result in the sort context and the point context
of another signature of an inductive family.
As we have alredy seen in the previous exapmles,
there needs to be a dependency on an erasure algebra which leads to the following
rules:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) }
  {\tqm{\SCon \grm{\Gamma}^\WW_\Sc(\blm{\gamma})} }
\\[.7em]
\inferrule{\grm{\vdash \Gamma} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) }
  {\tqm{\vdash_{\grm{\Gamma}^\WW_\Sc(\blm{\gamma})} \grm{\Gamma}^\WW(\blm{\gamma}) }}
\end{gathered}
\end{equation*}

To be able to do recursion we will again need to provide a suitable operation
on types.
We need to distinguish between sort and point types.
For sort types, note that we don't have an erasure operation of which we could take
an algebra, but since, implicitly, every input sort turns into the inductive-family
universe token \tqm{\UU}, we know that we can act as if its universe is a plain type.
Also, we need to know the interpretation of the erasure of the context the type is based on.
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\Gamma \vdash B :: \Sc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \alpha : \UU }
  {\tqm{\SCon \grm{B}^\WW(\blgamma, \blalpha) :: \Sc }}
\\[.7em]
\inferrule{\grm{\Gamma \vdash A :: \Pc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \alpha : \tqm{\grm{A}^\EE}^\CC(\gamma_\Sc) }
  {\tqm{\grm{\Gamma}^\WW_\Sc(\blm{\gamma}) \SCon \grm{A}^\WW(\blgamma, \blalpha) :: \Pc}}
\end{gathered}
\end{equation*}
The recursion of the context then looks very much like the on in the definition
of type erasure:
Extending the sort context whenever we encounter a sort type in the 
inductive-inductive signature and extending the point case for each point type.
Again, we can not leave the point context fixed ``on the nose'' when encountering
a sort type since we need to weaken it to account for the new sort:
\begin{align*}
\tqm{\grm{\cdot}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\cdot_\Sc} \\
\tqm{\grm{(\Gamma,\, B :: \Sc)}^\WW_\Sc\{\gamma_\Sc, \alpha\}(\blgamma)}
  &:\equiv \tqm{\left( \grm{\Gamma}^\WW_\Sc(\blgamma)
    ,\, \grm{B}^\WW(\blgamma, \blalpha)\right)} \\
\tqm{\grm{(\Gamma,\, A :: \Pc)}^\WW_\Sc(\blgamma, \blalpha)}
  &:\equiv \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma) } \\[.7em]
\tqm{\grm{\cdot}^\WW(\blgamma)}
  &:\equiv \tqm{\cdot} \\
\tqm{\grm{(\Gamma,\, B :: \Sc)}^\WW(\blgamma)}
  &:\equiv \tqm{\grm{\Gamma}^\WW(\blgamma)[\wk_\id]} \\
\tqm{\grm{(\Gamma,\, A :: \Pc)}^\WW(\blgamma, \blalpha)}
  &:\equiv \tqm{\left(\grm{\Gamma}^\WW(\blgamma),\, \grm{A}^\WW(\blgamma, \blalpha)\right) }
\end{align*}

Like in the definition of type erasure, recursing on \grm{\El(a)} makes it
necessary to extend the definition at least to sort types.
So we will also give an operation producing the following data:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash t : B :: \Sc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc)}
  {\tqm{\grm{\Gamma}^\WW_\Sc(\blgamma) \SCon \grm{t}^\WW(\blgamma)
    : \grm{B}^\WW(\blgamma, \blm{\tqm{\grm{t}^\EE}^\CC(\gamma_\Sc)})}}
\end{equation*}

Let us now proceed to give the definition on all type formers.
The each sort of the input signature should become a predicate.
Since a predicate is the same as a type family with propositional values,
we set the wellformedness on the universe to be a type family, the domain of which
is given by the set we obtain from the algebra of the erased context.
Not that this type family is a non-dependent, \emph{non-recursive} $\Pi$-type.
The interpretation of \grm{\El(a)} has to make up for this shift by applying
to the wellformedness predicate corresponding the sort term \grm{a} the
element we get from the erasure of \grm{\El(a)}: %TODO this still reads horrible
\begin{align*}
\tqm{\grm{\UU}^\WW(\blgamma, \blalpha)}
  &:\equiv \tqm{\ExtPiS{x : \blalpha}{\UU}} \text{ and} \\
\tqm{\grm{\El(a)}^\WW(\blgamma, \blalpha)}
  &:\equiv \tqm{\El\left(\grm{a}^\WW(\blgamma)(\blalpha)\right)} \text{.}
\end{align*}

For sort-kinded, recursive $\Pi$-types, we again need to remember that in the
definition of type erasure, we turned them into instances of \tqm{\UU}, so to
add the information back which we erased, the wellformedness has to turn them into
non-recursive $\Pi$-types over the erasure of sort term which is the domain of the
$\Pi$-type we started with.
The iterpretation of application terms has to follow this step accordingly:
\begin{align*}
\tqm{\grm{\Pi(a, B :: \Sc)}^\WW\{\blm{\gamma_\Sc}\}(\blgamma, \blphi)}
  &:\equiv \tqm{\ExtPiS{\blalpha : \tqm{\grm{a}^\EE}^\CC(\gamma_\Sc)}
    {\grm{B}^\WW((\blgamma, \blalpha), \blphi)}} \text { and} \\
\tqm{\grm{\IIapp(f)}^\WW(\blgamma, \blalpha)}
  &:\equiv \tqm{\grm{f}^\WW(\blgamma)(\blalpha)}
  \text{ for \grm{\Gamma \vdash f : \Pi(a, B :: \Sc)}.}
\end{align*}

The treatment of $\Pi$-types in point constructors is arguably the trickiest part
of the definition.
A non-technical description of the effect of the wellformedness operation on
these $\Pi$-types is the following:
For each bit of input data from an algebra of the erasure, wellformedness of this
input data should imply wellformedness of the result.
\begin{equation*}
\tqm{\grm{\Pi(a, A :: \Pc)}^\WW\{\blm{\gamma_\Sc}\}(\blgamma, \blphi)}
  :\equiv \tqm{\ExtPiP{\blalpha : \tqm{\grm{a}^\EE}^\CC(\gamma_\Sc)}
    { \grm{a}^\WW(\blgamma)(\blalpha)
      \Rightarrow_\Pc \grm{A}^\WW((\gamma, \alpha), \phi(\alpha))}}
%\tqm{\grm{\IIapp(f)}^\WW\{\blm{\gamma_\Sc}\}
%  \{\blgamma, \blphi\}(\blm{\gamma^\WW}, \blm{\phi^\WW}) }
%  &:\equiv \tqm{\grm{f}^\WW(\blm{\gamma^\WW})(\blphi)(\blm{\phi^\WW}) }
%  \text{ for \grm{\Gamma \vdash f : \Pi(a, A :: \Pc)}.} TODO this belongs to extra constr
\end{equation*}

Let us next look at the non-recursive function types.
Since we erased them just like the recursive ones, they are processed similar to
the definitions above, with the difference that for point constructors, there is
no wellformedness of the domain that we have to presuppose to infer wellformedness
of the codomain:
\begin{align*}
\tqm{\grm{\ExtPi{T}{B :: \Sc}}^\WW(\blgamma, \blphi)}
  &:\equiv \tqm{\ExtPiS{\tau : T}{\grm{B(\bltau)}^\WW(\blgamma, \blphi)}} \text{,} \\
\tqm{\grm{\ExtPi{T}{A :: \Pc}}^\WW(\blgamma, \blphi)}
  &:\equiv \tqm{\ExtPiP{\tau : T}{\grm{A(\bltau)}^\WW(\blgamma, \blm{\phi(\tau)})}}
  \text{, and} \\
\tqm{\grm{f(\bltau)}^\WW(\blgamma)}
  &:\equiv \tqm{\grm{f}^\WW(\blgamma)(\bltau) } \text{.}
\end{align*}

Again, we need to extend the definition to substitutions to be able to specify
it on pulled back types and terms:
\begin{equation*}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}}\\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc)}
  {\tqm{\IFSub{\grm{\sigma}^\WW_\Sc(\blgamma)}{\grm{\Gamma}^\WW_\Sc(\blgamma)}
    {\grm{\Delta}^\WW_\Sc(\blgamma)}}}
\end{equation*}
Their category structure is a direct translation to the sort substitutions of
the inductive family syntax.
Note that here, we need to refer to \ref{def:red-e-points} to carry the
algebra of the erase point context along the substitution:
\begin{align*}
\tqm{\grm{\id}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\id} \text{ and} \\
\tqm{\grm{(\sigma \circ \delta)}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\grm{\sigma}^\WW_\Sc(\blm{\grm{\delta}^\EE(\gamma)})
    \circ \grm{\delta}^\WW_\Sc(\blgamma)} \text{.}
\end{align*}
The pullback operations can afterwards defined by
\begin{align*}
\tqm{\grm{B[\sigma]}^\WW(\blgamma, \blalpha)}
  &:\equiv \tqm{\grm{B}^\WW(\blm{\grm{\sigma}^\EE(\gamma)}, \blalpha)} \text{,} \\
\tqm{\grm{A[\sigma]}^\WW(\blgamma)}
  &:\equiv \tqm{\grm{A}^\WW(\blgamma, \blalpha)
    [\grm{\sigma}^\WW_\Sc(\blgamma)]} \text{, and} \\
\tqm{\grm{t[\sigma]}^\WW(\blgamma)}
  &:\equiv \tqm{\grm{t}^\WW(\blm{\grm{\sigma}^\EE(\gamma)})
    [\grm{\sigma}^\WW_\Sc(\blgamma)] } \text{ for \grm{\Gamma \vdash t : B :: \Sc}.}
\end{align*}
The remaining pieces of substitutional calculus are straightforward and look the
same as for the type erasure:
\begin{align*}
\tqm{\grm{\epsilon}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\epsilon} \text{,} \\
\tqm{\grm{(\sigma,\, t)}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\left( \grm{\sigma}^\WW_\Sc(\blgamma),\,\grm{t}^\WW(\blgamma)\right)}
  \text{ for \grm{t : B :: \Sc},} \\
\tqm{\grm{(\sigma,\, t)}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\grm{\sigma}^\WW_\Sc(\blgamma)} \\
\tqm{\grm{\pi_1(\sigma)}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\pi_1(\grm{\sigma}^\WW_\Sc(\blgamma))}
  \text{ for \grm{\IISub{\sigma}{\Gamma}{\Delta,\, B :: \Sc}},} \\
\tqm{\grm{\pi_1(\sigma)}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\grm{\sigma}^\WW_\Sc(\blgamma)}
  \text{ for \grm{\IISub{\sigma}{\Gamma}{\Delta,\, A :: \Pc}},} \\
\tqm{\grm{\pi_2(\sigma)}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\pi_2(\grm{\sigma}^\WW_\Sc(\blgamma))}
  \text{ for \grm{\IISub{\sigma}{\Gamma}{\Delta,\, B :: \Sc}},} \\
\tqm{\grm{\pi_2(\sigma)}^\WW_\Sc(\blgamma)}
  &:\equiv \tqm{\grm{\sigma}^\WW_\Sc(\blgamma)}
  \text{ for \grm{\IISub{\sigma}{\Gamma}{\Delta,\, A :: \Pc}},}
\end{align*}

For the next step -- using the wellformedness predicate to define the initial
object itself -- we will need data which provides evidence that the point contexts
of the wellformedness predicate behave as well as the sort substitutions.
Since we don't have point substitutions as part of the syntax of inductive
families, we will proceed like in Definition~\ref{def:red-e-points} and work
directly on algebras.
To be able to give the definition we will also need a corresponding operation
on the terms of point types.

\begin{defn}[Wellformedness for Point Substitutions]
We give a wellformedness predicate operation on substitutions and point terms
in the following form:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \delta_\Sc : \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma)}^\CC }
  {\grm{\sigma}^\WW(\gamma)
    : \tqm{\grm{\Gamma}^\WW(\blgamma)}^\CC(\delta_\Sc)
    \to \tqm{\grm{\Delta}^\WW(\grm{\sigma}^\EE(\blgamma))}^\CC\left(\tqm{\grm{\sigma}^\WW_\Sc(\blgamma)}^\CC(\delta_\Sc)\right)}
\\[.7em]
\inferrule{\grm{\Gamma \vdash t : A :: \Pc} \\
   \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \delta_\Sc : \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma)}^\CC \\
  \delta : \tqm{\grm{\Gamma}^\WW(\blgamma)}^\CC(\delta_\Sc) }
  {\grm{t}^\WW(\gamma, \delta)
    : \tqm{\grm{A}^\WW(\blgamma, \blm{\grm{t}^\EE(\gamma)})}^\CC(\delta_\Sc) }
\end{gathered}
\end{equation*}
The definition will follow the structure of the algebra, ignoring the occurence
of sort terms:
\begin{align*}
\grm{\id}^\WW(\gamma, \delta)
  &:\equiv \delta \text{,} \\
\grm{\sigma \circ \delta}^\WW(\gamma, \delta')
  &:\equiv \grm{\sigma}^\WW(\grm{\delta}^\EE(\gamma), \grm{\delta}^\WW(\gamma, \delta')) \text{,} \\
\grm{\epsilon}^\WW(\gamma, \delta)
  &:\equiv \star \text{,} \\
\grm{(\sigma ,\, t)}^\WW(\gamma, \delta)
  &:\equiv \grm{\sigma}^\WW(\gamma, \delta)
  & \text{ for \grm{\Gamma \vdash t : B[\sigma] :: \Sc},} \\
\grm{(\sigma ,\, t)}^\WW(\gamma, \delta)
  &:\equiv \left(\grm{\sigma}^\WW(\gamma, \delta) , \grm{t}^\WW(\delta)\right)
  & \text{ for \grm{\Gamma \vdash t : A[\sigma] :: \Pc},} \\
\grm{\pi_1(\sigma)}^\WW(\gamma, \delta)
  &:\equiv \grm{\sigma}^\WW(\gamma, \delta)
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\,B :: \Sc)}}, and} \\
\grm{\pi_1(\sigma)}^\WW(\gamma, \delta)
  &:\equiv \pr_1(\grm{\sigma}^\WW(\gamma, \delta))
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\,A :: \Pc)}},} \\[.7em]
\grm{\IIapp(f)}^\WW(\gamma, \alpha)(\delta, \omega)
  &:\equiv \grm{f}^\WW(\delta)(\alpha)(\omega)
  & \text{ for \grm{\Gamma \vdash f : \Pi(a, A :: \Pc)},} \\
\grm{f(\bltau)}^\WW(\gamma, \delta)
  &:\equiv \grm{f}^\WW(\gamma, \delta)(\tau)
  & \text{ for \grm{\Gamma \vdash f : \ExtPiP{T}{A}},} \\
\grm{f[\sigma]}^\WW(\gamma, \delta)
  &:\equiv \grm{f}^\WW(\grm{\sigma}^\EE(\gamma), \grm{\sigma}^\WW(\gamma, \delta))
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{\Delta}}, and} \\
\grm{\pi_2(\sigma)}^\WW(\gamma, \delta)
  &:\equiv \pr_2(\grm{\sigma}^\WW(\gamma, \delta))
  & \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\,A :: \Pc)}}.}
\end{align*}
\end{defn}

\section{The Initial Object}\label{sec:red-sg}

Since we now have a way to ``carve out'' the wellformed elements from the types
we created via type erasure, can now define our desired inductive-inductive types
itself.
In this section, this will amount to defining just one specific algebra over the
given inductive-inductive signature.
This corresponds to giving sorts with the correct \emph{point constructors}.
What distinguishes this algebra from others is that we will in the later sections
demonstrate how to show that, besides constructors, it also admits a dependent
\emph{eliminator}, or, equivalently, that it is initial among all algebras.

The construction of the initial object obviously presupposes the existence of
initial algebras of inductive families.
Nevertheless, we need to apply the same strategy as in the definition of the
wellformedness predicate:
The construction will depend on arbitrary algebras of type erasure and wellformedness
instead of just relying on the initial on.
This allows us to descend recursively and still refer to the correct algebra
of the respective inductive families.

Like in the last two steps of the construction, let us again start off by taking
a look at our set of running examples:

\begin{example}[Natural Numbers]\label{ex:red-init-nat}
Continuing from Example \ref{ex:red-w-nat}, we again assume %TODO fix red-w-nat
sort and point algebras $(\star, N')$ and $(\star, z', s')$ of the erasure of
natural numbers \tqm{\grm{\Gamma_{nat}}^\EE_\Sc} and \tqm{\grm{\Gamma_{nat}}^\EE}.
Given this data,
the algebras of the wellformedness predicate take the form of
$(\star, W_N)$ and $(\star, w_z, w_s)$ with types
\begin{align*}
W_N &: N' \to \UU \text{,} \\
w_z &: W(z') \text{, and} \\
w_s &: (n' : N') \to W_N(n') \to W_N(s'(n')) \text{.}
\end{align*}
Then, we want the inductive-inductive algebra
$\con{\Gamma_{nat}} : \grm{\Gamma_{nat}}^\CC$ to consist of the subsets of
erased types which (in this case trivially) fulfil the wellformedness condition,
with the point constructors lifted to these subsets:
$\con{\Gamma_{nat}} = (\star, N, z, s)$ with
\begin{align*}
N &= (n' : N') \times W_N(n') \text{,} \\
z &= (z', w_z) \text{, and} \\
s &= \lambda ((n', w_n) : N).\, (s'(n'), w_s(n', w_n)) \text{.}
\end{align*}
\end{example}

\begin{example}[Vectors]
Let us next consider the type of vectors on a type $A : \UU$.
The assumed algebras of the type erasure give us $V'$, $n'$, and $c'$ as in
\ref{ex:red-w-vec}.
With those as input, algebras of the sort and point part of the 
wellformedness predicate \tqm{\grm{\Gamma_{vec}}^\WW_\Sc} and
\tqm{\grm{\Gamma_{vec}}^\WW} look like
$(\star, W_V)$ and $(\star, w_n, w_c)$ with
\begin{align*}
W_V &: \N \to V' \to \UU \text{,} \\
w_n &: W_V(0, n') \text{, and} \\
w_c &: (a : A)(m : \N)(v' : V) \to W_V(m, v') \to W_V(m + 1, c'(a, m, v')) \text{.}
\end{align*}
This suggests that we will have an algebra $\con{\Gamma_{vec}} : \Gamma_{vec}^\CC$
defined by $\con{\Gamma_{vec}} = (\star, V, n, c)$ with
\begin{align*}
V &= \lambda (n : \N).\, (v' : V') \times W_V(n, v') \text{,} \\
n &= (n', w_n) \text{, and} \\
c &= \lambda (a : A)(m : \N)((v', w_{v'}) : V).\, (c'(a, m, v'), w_c(a, m, v', w_{v'})) \text{.}
\end{align*}
\end{example}

\begin{example}[Type Theory Syntax]
baz
\end{example}

Let us now consider the case of an arbitrary signature \grm{\vdash \Gamma}.
The form which our operation will take is clear -- for each signature we need
to return an algebra of that signature:
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}
  {\con{\Gamma} : \grm{\Gamma}^\CC}
\end{equation*}
But as we saw before, recursion is easier when we make the dependent on arbitrary
algebras of the previous steps -- that is, arbitrary algebras over type erasure
and the wellformedness predicate.
After we succeed in defining this more general construction $\grm{\Gamma}^\Sg$,
we will eliminate this dependency by fixing these algebras to be the initial ones
which we assume to exist in this chapter.

\begin{defn}[Sigma Construction]
As mentioned, the more general construction will depend on both the type erasure
and the wellformedness, so that the operation will take the following form:
\begin{equation*}
\inferrule{\grm{\vdash \Gamma} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \delta_\Sc : \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma)}^\CC \\
  \delta : \tqm{\grm{\Gamma}^\WW(\blgamma)}^\CC(\delta_\Sc) }
  {\grm{\Gamma}^\Sg(\gamma, \delta) : \grm{\Gamma}^\CC }
\end{equation*}

To recurse on the contexts, we again need to extend the operations to types,
distinguishing between sort and point constructors, resulting in the following
two rules:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\Gamma \vdash B :: \Sc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \delta_\Sc : \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma)}^\CC \\
  \delta : \tqm{\grm{\Gamma}^\WW(\blgamma)}^\CC(\delta_\Sc) \\
  \alpha : \UU \\
  \omega : \tqm{\grm{B}^\WW(\blgamma, \blalpha)}^\CC }
  {\grm{B}^\Sg(\gamma, \delta, \omega) 
   : \grm{B}^\CC\left(\grm{\Gamma}^\Sg(\gamma, \delta) \right) }
\\[.7em]
\inferrule{\grm{\Gamma \vdash A :: \Pc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \delta_\Sc : \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma)}^\CC \\
  \delta : \tqm{\grm{\Gamma}^\WW(\blgamma)}^\CC(\delta_\Sc) \\
  \alpha : \tqm{\grm{A}^\EE}^\CC(\gamma_\Sc) \\
  \omega : \tqm{\grm{A}^\WW(\blgamma, \blalpha) }^\CC(\delta_\Sc) }
  {\grm{A}^\Sg(\gamma, \delta, \omega)
     : \grm{A}^\CC\left(\grm{\Gamma}^\Sg(\gamma, \delta) \right) }
\end{gathered}
\end{equation*}
These operations allow us two define the sigma construction as straightforward
as we have seen in the previous constructions:
\begin{align*}
\grm{\cdot}^\Sg(\gamma, \delta)
  &:\equiv \star \\
\grm{(\Gamma,\,B :: \Sc)}^\Sg(\gamma)\{\delta_\Sc, \omega\}( \delta)
  &:\equiv \left( \grm{\Gamma}^\Sg(\gamma,\delta) ,
    \grm{B}^\Sg(\gamma, \delta, \omega)\right) \\
\grm{(\Gamma,\,A :: \Pc)}^\Sg((\gamma, \alpha), (\delta, \omega))
  &:\equiv \left( \grm{\Gamma}^\Sg(\gamma, \delta) ,
    \grm{A}^\Sg(\gamma, \delta, \omega)\right)
\end{align*}
\end{defn}

Again, the necessity to define $\grm{\El(a)}^\Sg$ forces us to extend the definition
on terms as well.
The treatment for sort and point terms differs because type erasure and
wellformedness predicate are defined as maps between algebras of
inductive family syntax instead of syntax itself:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\Gamma \vdash t : B :: \Sc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \delta_\Sc : \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma)}^\CC \\
  \delta : \tqm{\grm{\Gamma}^\WW(\blgamma)}^\CC(\delta_\Sc) }
  {\grm{t}^\CC\left(\grm{\Gamma}^\Sg(\gamma, \delta)\right)
    = \grm{B}^\Sg\left(\gamma, \delta,
      \tqm{\grm{t}^\WW(\blgamma)}^\CC(\delta_\Sc) \right)}
\\[.7em]
\inferrule{\grm{\Gamma \vdash t : A :: \Pc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \delta_\Sc : \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma)}^\CC \\
  \delta : \tqm{\grm{\Gamma}^\WW(\blgamma)}^\CC(\delta_\Sc) }
  {\grm{t}^\CC\left(\grm{\Gamma}^\Sg(\gamma, \delta)\right)
    = \grm{A}^\Sg\left(\gamma, \delta, \grm{t}^\WW(\delta)\right)}
\end{gathered}
\end{equation*}

We will now go all the type formers in order, starting with the universe.
It justifies the name of the construction, producing a sigma type of the erasure and
its wellformedness.
For the element operator, we need the above equation for terms to be able to
give to populate these sigma types accordingly:
\begin{align*}
\grm{\UU}^\Sg(\gamma, \delta, \omega)
  &:\equiv (x : \alpha) \times \omega(x) \text{ and} \\
\grm{\El(a)}^\Sg(\gamma, \delta, \omega)
  &:\equiv \left(\grm{a}^\Sg(\gamma, \delta)\inv\right)^*(\alpha, \omega)
\end{align*}

Let us next look at the recursive $\Pi$-types and their application:
Let $(\alpha, \omega)$ be the result of
$\left(\grm{a}^\Sg(\gamma, \delta)\right)^*(\xi)$, then
we can set
\begin{align*}
\grm{\Pi(a, B :: \Sc)}^\Sg(\gamma, \delta, \phi, \xi)
  &:\equiv p^*\left(\grm{B}^\Sg((\gamma, \alpha), (\delta, \omega), \phi(\alpha))\right)
    \text{ and} \\
\grm{\Pi(a, A :: \Pc)}^\Sg(\gamma, \delta, \phi, \xi)
  &:\equiv p^*\left(\grm{B}^\Sg((\gamma, \alpha), (\delta, \omega), \phi(\alpha, \omega))\right)
    \text{,}
\end{align*}
where $p$ is an equation providing proof for
\begin{equation*}
\grm{B}^\CC\left(\grm{\Gamma}^\Sg(\gamma, \delta), \left(\grm{a}^\Sg(\gamma, \delta)\inv\right)^*(\alpha, \omega) \right)
  = \grm{B}^\CC\left(\grm{\Gamma}^\Sg(\gamma, \delta), \xi \right) \text{.}
\end{equation*}
For the application we provide 
$\grm{\IIapp(f)}^\Sg((\gamma, \alpha), (\delta, \omega))$ for
\grm{\Gamma \vdash f : \Pi(a, B)} by the following
identity proofs:
\begin{align*}
  & \grm{\IIapp(f)}^\CC\left(\grm{(\Gamma,\,\El(a))}^\Sg((\gamma, \alpha), (\delta, \omega))\right) \\
  &\equiv \grm{f}^\CC\left(\grm{\Gamma}^\Sg(\gamma), \left(\grm{a}^\Sg(\gamma, \delta)\inv\right)^*(\alpha, \omega)\right) \\
  &= \grm{\Pi(a, B)}^\Sg\left(\gamma, \delta, \left(\grm{a}^\Sg(\gamma, \delta)\inv\right)^*(\alpha, \omega)\right) \text{ by $\grm{f}^\Sg$}\\
  &\equiv 
    \begin{cases}
    \grm{B}^\Sg\left((\gamma, \alpha), (\delta, \omega),
    \tqm{\grm{f}^\EE }^\CC(\gamma_\Sc)
      \left(\tqm{\grm{f}^\WW(\blgamma)}^\CC(\delta_\Sc)\right)\right)
     & \text{for \grm{B :: \Sc} and} \\
    \grm{B}^\Sg\left((\gamma, \alpha), (\delta, \omega),
     \grm{f}^\EE(\gamma)\left(\grm{f}^\WW(\delta)\right)\right)
     & \text{for \grm{B :: \Pc}.}
    \end{cases}
\end{align*}

The case for non-recursive $\Pi$-types is a rather straightforward descent,
compared to the recursive ones:
\begin{align*}
\grm{\Pi(a, B)}^\Sg(\gamma, \delta, \phi, \tau)
  &:\equiv \grm{B}^\Sg(\gamma, \delta, \phi(\tau)) \text{ and}\\
\grm{f(\bltau)}^\Sg(\gamma, \delta)
  &:\equiv \happly\left(\grm{f}^\Sg(\gamma, \delta), \tau\right)
\end{align*}

This concludes all type formers, though we still need to have a definition on
types which are the result of pullback along a substitution, and thus need
to extend the operation to substitution with the following rule, which introduces
equalities similar to the ones that we already saw for terms:
\begin{equation*}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \delta_\Sc : \tqm{\grm{\Gamma}^\WW_\Sc(\blgamma)}^\CC \\
  \delta : \tqm{\grm{\Gamma}^\WW(\blgamma)}^\CC  }
  {\grm{\sigma}^\Sg(\gamma, \delta) :
    \grm{\sigma}^\CC\left(\grm{\Gamma}^\Sg(\gamma, \delta)\right)
    = \grm{\Delta}^\Sg\left(\grm{\sigma}^\EE(\gamma), \grm{\sigma}^\WW(\delta) \right) }
\end{equation*}
With this rule we can set the provide the correct operations on pulled back types
and terms:
\begin{align*}
\grm{B[\sigma]}^\Sg(\gamma, \delta, \omega)
  &:\equiv \left(\grm{\sigma}^\Sg(\gamma, \delta)\inv\right)^*
    \left(\grm{B}^\Sg(\grm{\sigma}^\EE(\gamma), \grm{\sigma}^\WW(\delta), \omega ) \right)
\end{align*}
for \grm{\Gamma \vdash B :: \Sc}, and for a term \grm{\Gamma \vdash t[\sigma] : B[\sigma]}, we
use $\grm{\sigma}^\Sg$ in the proof of the equality $\grm{t[\sigma]}^\Sg$:
\begin{align*}
  & \grm{t[\sigma]}^\CC(\grm{\Gamma}^\Sg(\gamma, \delta)) \\
  &\equiv \grm{t}^\CC(\grm{\sigma}^\CC(\grm{\Gamma}^\Sg(\gamma, \delta))) \\
  &= \left(\grm{\sigma}^\Sg(\gamma, \delta)\inv\right)^*
    \left(\grm{t}^\CC(\grm{\Delta}^\Sg(\grm{\sigma}^\EE(\gamma), \grm{\sigma}^\WW(\delta)))\right) \\
  &= \left(\grm{\sigma}^\Sg(\gamma, \delta)\inv\right)^*
     \left(\grm{B}^\Sg(\grm{\sigma}^\EE(\gamma), \grm{\sigma}^\WW(\gamma, \delta), 
       \tqm{\grm{t}^\WW(\gamma)}^\CC(\tqm{\grm{\sigma}^\WW_\Sc(\gamma)}^\CC(\delta_\Sc)  )
       )\right) \\
  &\equiv \grm{B[\sigma]}^\Sg(\gamma, \delta, \tqm{\grm{t}^\WW[\grm{\sigma}^\WW_\Sc(\gamma) ]  }^\CC(\delta_\Sc) ) %TODO re-check all this
\end{align*}
and similarly for \grm{\Gamma \vdash A :: \Pc}.


The substitutional calculus for this rule is easily defined since
$\grm{\id}^\Sg(\gamma, \delta)$ and $\grm{\epsilon}^\Sg(\gamma, \delta)$ hold
definitionally,
the composition rule $\grm{\sigma \circ \delta}^\Sg(\gamma, \delta')$
for \grm{\IISub{\sigma}{\Delta}{\Sigma}} and
\grm{\IISub{\delta}{\Gamma}{\Delta}} is justified
by
\begin{align*}
\grm{\sigma}^\CC\left(\grm{\delta}^\CC\left(\grm{\Gamma}^\Sg(\gamma, \delta')\right)\right)
  &= \grm{\sigma}^\CC\left(\grm{\Delta}^\Sg(\grm{\delta}^\EE(\gamma), \grm{\delta}^\WW(\gamma, \delta') ) \right)
  & \text{by $\grm{\delta}^\Sg(\gamma, \delta') $} \\
  & = \grm{\Sigma}^\Sg(\grm{\sigma}^\EE(\grm{\delta}^\EE(\gamma)),
     \grm{\sigma}^\WW(\grm{\delta}^\EE(\gamma),\grm{\delta}^\WW(\gamma, \delta') ) )
  & \text{by $\grm{\sigma}^\Sg(\ldots) $.}
\end{align*}
To prove the coherence of a substitution extended by a term
$\grm{(\sigma,\,t)}$ with \grm{\IISub{\sigma}{\Gamma}{\Delta}} and
\grm{\Gamma \vdash B[\sigma] :: \Sc}, we use
$\grm{\sigma}^\Sg(\gamma, \delta)$ and $\grm{t}^\Sg(\gamma, \delta)$
simultaneously to obtain the required equation (the variant for point terms follows
in similar fashion):
\begin{align*}
  & \grm{(\sigma,\,t)}^\CC(\grm{\Gamma}^\Sg(\gamma, \delta)) \\
  \equiv &\left( \grm{\sigma}^\CC(\grm{\Gamma}^\Sg(\gamma, \delta)) ,\,
    \grm{t}^\CC(\grm{\Gamma}^\Sg(\gamma, \delta))   \right) \\
  = &\left( \grm{\Delta}^\Sg(\grm{\sigma}^\EE(\gamma), \grm{\sigma}^\WW(\gamma, \delta) ) ,
    \grm{B}^\Sg(\grm{\sigma}^\EE(\gamma), \grm{\sigma}^\WW(\gamma, \delta),
      \tqm{\grm{t}^\WW(\blgamma)}^\CC(\delta_\Sc))\right) \\
  \equiv & \grm{(\Gamma,\,B)}^\Sg(\grm{\sigma}^\EE(\gamma), \grm{\sigma}^\WW(\gamma, \delta)) \text{.}
\end{align*}
The remaining equations follow in similarly obvious way.


\end{defn}

\begin{defn}[Initial Object]
Using the generalized sigma construction we are now able to define the initial
object by plugging in the respective initial objects of the inductive families:
\begin{equation*}
\con{\Gamma} :\equiv \grm{\Gamma}^\Sg(\IFcon{\grm{\Gamma}^\EE}, \IFcon{\grm{\Gamma}^\WW(\blm{\IFcon{\grm{\Gamma}^\EE}})})
  : \grm{\Gamma}^\CC
\end{equation*}
\end{defn}

\section{The Eliminator Relation}\label{sec:red-r}

Now that we have defined a candidate for the initial object in the category of
algebras,
the obvious next step is to prove its initiality.
The strategy for this is, as we have seen in Chapter~\ref{sec:red-ex},
to first define a \emph{relation} for the non-dependent eliminator, before showing
that this relation is right-unique and left-total and as such, a function.
Like the wellformedness predicate, the construction of this relation
relies on the fact that we are provided with an initial algebra for the type
erasure.

Again, we start by taking on the running examples of natural numbers, vectors,
and type theoretic syntax, to get a feeling for what the construction is supposed
to look like.

\begin{example}[Natural Numbers]
Continuing the construction from Example~\ref{ex:red-e-nat} and parallel to 
Example~\ref{ex:red-w-nat}, we assume sort and point algebras
$(\star,N') : \grm{\Gamma_{nat}}^\CC $ and $(\star,z',s') : \grm{\Gamma_{nat}}^\CC(\star, N)$.
Furthermore, our relation should relate these algebras to an arbitray algebra
of \grm{\Gamma_{nat}}, so we assume that we are given
\begin{align*}
(\star, N, z, s) &: \grm{\Gamma_{nat}}^\CC \text{ with} \\ %TODO think about these names 🙄️
N &: \UU \text{,}\\
z &: N \text{, and} \\
s &: N \to N \text{.}
\end{align*}
Since, as we observed in Example~\ref{ex:red-e-nat}, no erasure takes place, this
algebra already contains the same amount of information as $((\star, N'), (\star, z', s'))$.
Like type erasure and wellformedness predicate, the eliminator relation will come
in the form of the sort and point context of an inductive family.
The sort context simply describes the one of a type family indexed both over $N$
and $N'$ (we will use variable names instead of de-Bruijn indices):
\begin{equation*}
\tqm{\grm{\Gamma_{nat}}^\RR_\Sc}
  = \tqm{(\cdot_\Sc ,\, R_N : \ExtPiS{N}{\ExtPiS{N'}{\UU}})} \text{.}
\end{equation*}
The point context will now populate this relation by witnesses for the fact
that the corresponding point constructors are related, or, for $s$, that they
preserve relatedness:
\begin{align*}
\tqm{\grm{\Gamma_{nat}}^\RR}
  =& \tqm{\Bigl(\cdot ,\, r_z : \El(R_N(\blm{z})(\blm{z'}) ,\, } \\
   & \tqm{ \phantom{\Bigl(}
    \ExtPiP{n : N}{\ExtPiP{n' : N'}{R_N(\blm{n})(\blm{n'}) \Rightarrow_\Pc
      \El(R_N(\blm{s(n)})(\blm{s'(n')}))}} \Bigr)} \text{.}
\end{align*}
Since, as we remarked earlier, the type erasure on \grm{\Gamma_{nat}} is without
effect, we can expect this relation to be the same as the graph of the
non-dependent eliminator on $N'$ already.
\end{example}

\begin{example}[Vectors]
To move on to an example where on the one hand no real induction-induction is
happening, but we still have a non-trivial effect by type erasure, let us
consider the type of vectors over an external type $A : \UU$.
Again, we assume that we already have constructed point and sort algebras
$(\star, V')$ and $(\star, n', c')$ as in Example~\ref{ex:red-w-vec}.
We also assume an arbitrary algebra of the vectors in \grm{\Gamma_{vec}}, which
comes in the form of $(\star, V, n, c)$ where
\begin{align*}
V &: \N \to \UU \text{,} \\
n &: V(0) \text{, and} \\
c &: (a : A)(n : \N) \to V(n) \to V(n + 1) \text{.}
\end{align*}
Since $V$ is a type family, the relation will also need to be indexed by its codomain
and so we obtain the following for the sort context describing the relation:
\begin{equation*}
\tqm{\grm{\Gamma_{vec}}^\RR(...)} =
  \tqm{\Bigl( \cdot_\Sc ,\, R_V : \ExtPiS{n : \N}{\ExtPiS{V(n)}{\ExtPiS{V'}{\UU}}} \Bigr)} \text{.}
\end{equation*}
The point context again describes that relatedness is preserved by all point
constructors:
\begin{equation*}
\begin{gathered}
\tqm{\grm{\Gamma_{vec}}^\RR}
  = \tqm{ \Bigl( \cdot ,\,} \tqm{ \El(R_V(\blm{0})(\blm{n})(\blm{n'})) ,\, } \\
 \tqm{ \ExtPiP{a : A}{\ExtPiP{n : \N}{\ExtPiP{v : V}{\ExtPiP{v' : V'}{R_V(\blm{n})(\blm{v})(\blm{v'})
     \Rightarrow_\Pc R_V(\blm{n+1})(\blm{c(a,v)})(\blm{c'(a,v')})}}}} \Bigr) } \text{.} %TODO formatting
\end{gathered}
\end{equation*}
\end{example}

\begin{example}[Type Theory Syntax]
For an example involving non-trivial dependency between the sorts, let us
at last consider the example of contexts and types:
foo
\end{example}

\begin{defn}[Eliminator Relation]
As we have noticed before, the specification of the eliminator relation bears
many similarities with the one of the wellformedness predicate,
with the difference that we now also depend on an arbitrary algebra over the
inductive-inductive signature under consideration.
The definition on contexts again produces both a sort and a point context:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \gamma^\CC : \grm{\Gamma}^\CC }
  {\tqm{\SCon \grm{\Gamma}^\RR_\Sc(\blm{\gamma}, \blm{\gamma^\CC})} }
\\[.7em]
\inferrule{\grm{\vdash \Gamma} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \gamma^\CC : \grm{\Gamma}^\CC }
  {\tqm{\vdash_{\grm{\Gamma}^\RR_\Sc(\blm{\gamma}, \blm{\gamma^\CC})} \grm{\Gamma}^\RR(\blm{\gamma}, \blm{\gamma^\CC}) }}
\end{gathered}
\end{equation*}

For the definition on types, we can make a a big simplification on sort types:
The definition does not depend on the erasure of the remaining context, but only
on the erasure of the type itself.
For point types, we are not able to make this simplification.
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\Gamma \vdash B :: \Sc} \\
  \gamma^\CC : \grm{\Gamma}^\CC \\
  \alpha : \UU \\
  \alpha^\CC : \grm{B}^\CC(\gamma^\CC) }
  {\tqm{\grm{B}^\RR(\blalpha, \blalphaCC) :: \Sc} }
\\[.7em]
\inferrule{\grm{\Gamma \vdash A :: \Pc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \gamma^\CC : \grm{\Gamma}^\CC \\
  \alpha : \grm{A}^\EE(\gamma_\Sc) \\
  \alpha^\CC : \grm{A}^\CC(\gamma^\CC) }
  {\tqm{\grm{\Gamma}^\RR_\Sc(\blgamma, \blgammaCC) \SCon \grm{A}^\RR(\blgamma, \blalpha, \blalphaCC) }}
\end{gathered}
\end{equation*}

As usual, we define the operation on contexts by a simple recursion, using the
definition on types, ignoring extensions by types of the respective other kind:
\begin{align*}
\tqm{\grm{\cdot}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\cdot_\Sc} \\
\tqm{\grm{(\Gamma,\, B :: \Sc)}^\RR_\Sc\{\blm{\gamma_\Sc, \alpha}\}(\blgamma, \blm{(\blgammaCC, \blalphaCC)})}
  &:\equiv \tqm{\left(\grm{\Gamma}^\RR_\Sc(\blgamma, \blgammaCC) ,\, \grm{B}^\RR(\blalpha, \blalphaCC)\right)} \\
\tqm{\grm{(\Gamma,\, A :: \Pc)}^\RR_\Sc((\blgamma, \blalpha), \blm{(\blgammaCC, \blalphaCC)}) }
  &:\equiv \tqm{\grm{\Gamma}^\RR_\Sc(\blgamma, \blgammaCC)} \\[.7em]
\tqm{\grm{\cdot}^\RR(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\cdot} \\
\tqm{\grm{(\Gamma,\, B :: \Sc)}^\RR\{\blm{\gamma_\Sc, \alpha}\}(\blgamma, \blm{(\blgammaCC, \blalphaCC)})}
  &:\equiv \tqm{\grm{\Gamma}^\RR(\blgamma, \blgammaCC)[\wk_\id]} \\
\tqm{\grm{(\Gamma,\, A :: \Pc)}^\RR((\blgamma, \blalpha), \blm{(\blgammaCC, \blalphaCC)}) }
  &:\equiv \tqm{\left( \grm{\Gamma}^\RR(\blgamma, \blgammaCC) ,\, \grm{A}^\RR(\blgamma, \blalpha, \blalphaCC) \right)}
\end{align*}

Before giving the definition on type formers, we need again care about how to handle
at least sort terms.
For those, we introduce the a construction of the following type:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash t : B :: \Sc} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \gamma^\CC : \grm{\Gamma}^\CC }
  {\tqm{\grm{\Gamma}^\RR_\Sc(\blgamma, \blgammaCC) \SCon \grm{t}^\RR(\blgamma, \blgammaCC)
    : \grm{B}^\RR(\blm{\tqm{\grm{t}^\EE}^\CC(\gamma_\Sc)}, \blm{\grm{t}^\CC(\blgammaCC)})}}
\end{equation*}

Using this we can give the definition on the universe -- producing the relation
itself -- and the element operator, populating the relation via the following
definitions:
\begin{align*}
\tqm{\grm{\UU}^\RR(\blalpha, \blalphaCC)}
  &:\equiv \tqm{\ExtPiS{\blalphaCC}{\ExtPiS{\blalpha}{\UU}}} \\
\tqm{\grm{\El(a)}^\RR(\blgamma, \blalpha, \blalphaCC)}
  &:\equiv \tqm{\El(\grm{a}^\RR(\blgamma, \blgammaCC)(\blalphaCC)(\blalpha))}
\end{align*}

To continue to recursive $\Pi$-types, we observe that we need sort-kinded
$\Pi$-types to be translated $\Pi$-types which the generated relation is
indexed over, including the appropriate application,
while point-kinded $\Pi$-types are translated to the fact that
relatedness is preserved for all point constructors.
\begin{align*}
\tqm{\grm{\Pi(a, B :: \Sc)}^\RR(\blphi, \blphiCC)}
  &:\equiv \tqm{\ExtPiS{\blalphaCC : \grm{a}^\CC(\blgammaCC)}
    {\grm{B}^\RR(\blphi, \blm{\blphiCC(\blalphaCC)})}} \\
\tqm{\grm{\Pi(a, A :: \Pc)}^\RR(\blgamma, \blphi, \blphiCC)}
  &:\equiv \tqm{\ExtPiP{\blalphaCC : \grm{a}^\CC(\blgammaCC)}
    {\ExtPiP{\blalpha : \tqm{\grm{a}^\EE}^\CC(\gamma_\Sc)}
    {\grm{a}^\RR(\blgamma,\blgammaCC)(\blalphaCC)(\blalpha)
    \Rightarrow_\Pc \grm{B}^\RR(\blm{(\gamma, \alpha)}, \blm{\phi(\alpha)}, \blm{\blphiCC(\blalphaCC)}) }}  } \\[.7em]
\tqm{\grm{(\IIapp(f) : B :: \Sc)}^\RR(\blm{(\gamma, \alpha)},\blm{(\blgammaCC,\blalphaCC)})}
  &:\equiv \tqm{\grm{f}^\RR(\blgamma, \blgammaCC)(\blalphaCC) }
\end{align*}

The treatment of external $\Pi$-types is a simple one-to-one translation
using the respective external $\Pi$-types in the generated inductive-family:
\begin{align*}
\tqm{\grm{\ExtPi{T}{B :: \Sc}}^\RR(\blphi, \blphiCC)}
  &:\equiv \tqm{\ExtPiS{\tau : T}{\grm{B(\bltau)}^\RR(\blphi, \blm{\phi^\CC(\tau)})}} \\
\tqm{\grm{\ExtPi{T}{A :: \Pc}}^\RR(\blphi, \blphiCC)}
  &:\equiv \tqm{\ExtPiP{\tau : T}{\grm{A(\bltau)}^\RR(\blm{\phi(\tau)}, \blm{\phi^\CC(\tau)})}} \\
\tqm{\grm{f(\bltau)}^\RR(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\grm{f}^\RR(\blgamma, \blgammaCC)(\bltau)}
\end{align*}

To provide the relation for types pulled along substitutions,
we again have to provide data for substitutions,
in the form of sort substitutions:
\begin{equation*}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}} \\
  \gamma_\Sc : \tqm{\grm{\Gamma}^\EE_\Sc }^\CC \\
  \gamma : \tqm{\grm{\Gamma}^\EE }^\CC(\gamma_\Sc) \\
  \gamma^\CC : \grm{\Gamma}^\CC }
  {\tqm{\IFSub{\grm{\sigma}^\RR_\Sc(\blgamma, \blgammaCC)}
    {\grm{\Gamma}^\RR_\Sc(\blgamma, \blgammaCC)}
    {\grm{\Delta}^\RR_\Sc(\blm{\grm{\sigma}^\EE(\blgamma)}, \blm{\grm{\sigma}^\CC(\blgammaCC)})}}}
\end{equation*}
As the sort substitutions of inductive families, these follow the categorical
structure trivially:
\begin{align*}
\tqm{\grm{\id}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\id} \text{ and} \\
\tqm{\grm{\sigma \circ \delta}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\grm{\sigma}^\RR_\Sc(\blm{\grm{\delta}^\EE(\gamma)}, \blm{\grm{\delta}^\CC(\blgammaCC)})
    \circ \grm{\delta}^\RR_\Sc(\blgamma, \blgammaCC)} \text{.}
\end{align*}
Pulled back sort types are invariant under pullback while point types and sort terms
are pulled back with the operation we gave in Definition~\ref{def:if-sort-subs}:
\begin{align*}
\tqm{\grm{B[\sigma]}^\RR(\blalpha, \blalphaCC)}
  &:\equiv \tqm{\grm{B}^\RR(\blalpha, \blalphaCC)} \text{ for \grm{\Gamma \vdash B :: \Sc},} \\
\tqm{\grm{A[\sigma]}^\RR(\blgamma, \blalpha, \blalphaCC)}
  &:\equiv \tqm{\grm{A}^\RR(\blm{\grm{\sigma}^\EE(\gamma)}, \blalpha, \blalphaCC)[\grm{\sigma}^\RR_\Sc(\blgamma, \blgammaCC)]}
    \text{ for \grm{\Gamma \vdash A :: \Pc}, and} \\
\tqm{\grm{t[\sigma]}^\RR(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\grm{t}^\RR(\blm{\grm{\sigma}^\EE(\gamma)}, \blm{\grm{\sigma}^\CC(\blgammaCC)})
    [\grm{\sigma}^\RR_\Sc(\blgamma, \blgammaCC)] } \text{.}
\end{align*}
The remaining parts of the substitutional calculus are given by their counterparts
in the sort substitutions of inductive families as they were defined in
Definition~\ref{def:if-sort-subs}:
\begin{align*}
\tqm{\grm{\epsilon}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\epsilon} \text{,} \\
\tqm{\grm{(\sigma,\,t)}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{(\grm{\sigma}^\RR_\Sc(\blgamma, \blgammaCC) , \grm{t}^\RR(\blgamma, \blgammaCC))}
    \text{ for \grm{\Gamma \vdash t : B :: \Sc},} \\
\tqm{\grm{(\sigma,\,t)}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\grm{\sigma}^\RR_\Sc(\blgamma, \blgammaCC)} \text{ for \grm{\Gamma \vdash t : A :: \Pc},} \\
\tqm{\grm{\pi_1(\sigma)}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\pi_1(\grm{\sigma}^\RR_\Sc(\blgamma, \blgammaCC))} \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, B :: \Sc)}},} \\
\tqm{\grm{\pi_1(\sigma)}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\grm{\sigma}^\RR_\Sc(\blgamma, \blgammaCC)} \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, A :: \Pc)}},} \\
\tqm{\grm{\pi_2(\sigma)}^\RR_\Sc(\blgamma, \blgammaCC)}
  &:\equiv \tqm{\pi_2(\grm{\sigma}^\RR_\Sc(\blgamma, \blgammaCC))} \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta ,\, B :: \Sc)}} .}
\end{align*}
This concludes our definition of the eliminator relation.
\end{defn}





















