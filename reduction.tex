\section{(OLD) -- Fragments of Inductive-Inductive Types}

As we have seen in the previous sections, inductive-inductive types as specified
allow for a very broad variety of definitions.
We will now see that it is easy to carve out different subsets of specifications
to obtain more restrictive fragments of inductive types.
Starting from the largest of these subsets, we will first see that there is a
straightforward way to restrict inductive-inductive types to those whose constructors
are finitary in the sense that no point constructor depends on an infinite
amount of data: %TODO improve that last sentence

\begin{defn}[Finitary IITs]
Given a specification \grm{\Gamma} for an inductive-inductive types we say that
it is \textbf{finitary} if the infinitary $\Pi$-type is not used.
\end{defn}

One example of a specification which does not meet this requirement are the
infinitely branching trees. %TODO cite example

Instead of only preventing the use of external data in ``small functions''

We want to reduce inductive-inductive types to inductive families.
This means, we postulate that inductive families be admissible in our target
type theory and show that this implies the existence of all inductive-inductive
types.
Since we want to reuse the way of specifying inductive-inductive types to specify
instances which are as well inductive families, we want to rediscover the specifications
of inductive families as a subset of all inductive-inductive specifications:

\begin{defn}[Inductive families]
A context \grm{\Gamma} is said to specify a \textbf{inductive family} if it is
generated without using the inductive function type in the specification of sorts
and thus, no sorts depend on other sorts but are only iterated function depending
on external types.
This means that the formation rule for inductive function types is restricted
to the case where \grm{k \equiv \Pc}.
\end{defn}

We assume for the remainder of this chapter, that if \grm{\Gamma} specifies an
inductive family, we are provided with $\con{\Gamma} : \grm{\Gamma}^\CC$ and
$\elim_\grm{\Gamma} : \grm{\Gamma}^\EE(\con{\Gamma}, m)$ for each
$m : \grm{\Gamma}^\MM$.

TODO: explain reduction to W-types maybe

\section{Type Erasure}

As seen in the examples, the first step to prove the reducability is to formally
define the operation which we will call \emph{flattening} or -- inspired by
the syntax example -- \emph{type erasure}.
This operation strips away any dependencies between the sorts of a signature
as well as all external indices to sorts.
The operation should take arbitrary inductive-inductive signatures (contexts) and
return signatures for inductive families.
Let us look at what type erasure should do with our running examples:

\begin{example}[Natural Numbers]\label{ex:red-e-nat}
Since the inductive-inductive signature of the \emph{natural numbers}~\ref{ex:ii-syntax-nat} doesn't
contain any indexed sorts, type erasure should ``do nothing'' with it.
That is, returning the sort context and point context of the inductive family
syntax which looks like a obvious correspondence to it (cf. Example~\ref{ex:if-natvec}):
\begin{align*}
  &\tqm{\grm{(\cdot,\, \UU,\, \El(\vz),\, \Pi\left(\vs(\vz),\, \El(\vs(\vs(\vz)))\right))}^\EE_\Sc} \\
= &\tqm{(\cdot_\Sc,\, \UU)} \text{ and} \\
  &\tqm{\grm{(\cdot,\, \UU,\, \El(\vz),\, \Pi\left(\vs(\vz),\, \El(\vs(\vs(\vz)))\right))}^\EE} \\
= &\tqm{(\cdot,\, \El(\var(\vz)),\, \var(\vz) \Rightarrow_\Pc \El(\var(\vz)))} \text{.}
\end{align*}
\end{example}

\begin{example}[Vectors]
In the example of vectors \ref{ex:ii-syntax-vec} we need to erase the natural numbers
index of the only sort under consideration:
\begin{align*}
\tqm{\grm{\Gamma_{vec}}^\EE_\Sc}
 &= \tqm{(\cdot_\Sc,\, \UU)} \text{ and} \\
\tqm{\grm{\Gamma_{vec}}^\EE}
  &= \tqm{(\cdot,\, \El(\var(\vz)),\, 
    \ExtPiP{A}{\blm{\lambda a.\,}\ExtPiP{\N}{\blm{\lambda n.\,}
    \var(\vz) \Rightarrow_\Pc \El(\var(\vz))}})} \text{.}
\end{align*}
Note that the erasure of the vectors does not coincide with the vectors represented
as an inductive family (Example~\ref{ex:if-natvec}), because its sort lacks the
indexing over the natural numbers.
In fact, it's easy to see that the algebras of this signature would no be isomorphic
to the type of lists over the type \blm{A \times \N}.
\end{example}

\begin{example}[Type Theory Syntax]
In our syntax we will now see why the operation is called ``type erasure'':
%TODO
\end{example}

To go from examples to the general case, we will present the different components
of the type erasure operation in roughly the same order in which they appear in
Section~\ref{sec:ii-syntax}, most often needing to distinguish between sort
and point constructors.

\begin{defn}[Type Erasure]
First of all, each context will need to be split into a sort context and a point
context:
\begin{equation*}
\inferrule{\grm{\vdash \Gamma}}
  {\tqm{\SCon \grm{\Gamma}^\EE_\Sc}}
\qquad
\inferrule{\grm{\vdash \Gamma}}
  {\tqm{\vdash_{\grm{\Gamma}^\EE_\Sc} \grm{\Gamma}^\EE }}
\end{equation*}
To descent down the components of the contexts, we will need to define the operation
on types as well.
Since we are erasing all information from the sorts, we will only need this for
point types, though.
Unsurprisingly, we want them to be translated to point types in the appropriate
sort context:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash A :: \Pc}}
  {\tqm{\grm{\Gamma}^\EE_\Sc \SCon \grm{A}^\EE :: \Pc}}
\end{equation*}
Using this we will be able to define the operation creating sort contexts by
\begin{align*}
\tqm{\grm{\cdot}^\EE_\Sc}
  &:\equiv\tqm{\cdot_\Sc} \text{,} \\
\tqm{\grm{(\Gamma,\, B)}^\EE_\Sc}
  &:\equiv \tqm{\left(\grm{\Gamma}^\EE_\Sc,\, \grm{\UU}^\EE_\Sc\right)} \text{ for \grm{B :: \Sc}, and} \\
\tqm{\grm{(\Gamma,\, A)}^\EE_\Sc}
  &:\equiv \tqm{\grm{\Gamma}^\EE_\Sc} \text{ for \grm{A :: \Pc}.}
\end{align*}
The generated point context over this sort context has to be extended in the case
where the input is an extension by a point type.
In the case where it is an extension by a sort type, we want to return the
unextended context, but to make up for the definition above, we need to weaken
to account for the extension of the resulting sort context:
\begin{align*}
\tqm{\grm{\cdot}^\EE}
  &:\equiv\tqm{\cdot} \text{,} \\
\tqm{\grm{(\Gamma,\, B)}^\EE}
  &:\equiv \tqm{\grm{\Gamma}^\EE[\wk_{\id}]} \text{ for \grm{B :: \Sc}, and} \\
\tqm{\grm{(\Gamma,\, A)}^\EE}
  &:\equiv \tqm{\left(\grm{\Gamma}^\EE,\, \grm{A}^\EE\right)} \text{ for \grm{A :: \Pc}.}
\end{align*}
So how do we define \tqm{\grm{A}^\EE} for a point type \grm{A}?
The fact the we have to recurse on \grm{\El(a)} makes it clear that we will have
to extend our operation to terms of sort types at least.
That is, together with \tqm{\grm{A}^\EE} we also need the following:
\begin{equation*}
\inferrule{\grm{\Gamma \vdash t : B :: \Sc}}
  {\tqm{\grm{\Gamma}^\EE_\Sc \SCon \grm{t}^\EE : \UU}}
\end{equation*}
And indeed, with this we can set
\begin{align*}
\tqm{\grm{\El(a)}^\EE}
  &:\equiv \tqm{\El(\grm{a}^\EE)} \text{.}
\end{align*}
For recursive $\Pi$-types, we need only care about the ones yielding point types.
Note that the operation turns a $\Pi$-type into a non-dependent function type!
\begin{align*}
\tqm{\grm{\Pi(a, A)}^\EE}
  &:\equiv \tqm{\grm{a}^\EE \Rightarrow_\Pc \grm{A}^\EE}
\end{align*}
Since we forgot about the indexing of sort types, erasure of sort-kinded application terms
is just erasure of its $\Pi$-type term:
\begin{align*}
\tqm{\grm{\IIapp(f)}^\EE}
  &:\equiv \tqm{\grm{f}^\EE} \text{ for \grm{\Gamma \vdash t : \Pi(a, B) :: \Sc}.}
\end{align*}
External $\Pi$-types and their applications convert directly into their
respective counterparts in the syntax of inductive families:
\begin{align*}
\tqm{\grm{\ExtPi{T}{A}}^\EE}
  &:\equiv \tqm{\ExtPiP{T}{\blm{\lambda \tau.\, }\grm{A(\bltau)}^\EE}} \text{, and} \\
\tqm{\grm{f(\bltau)}^\EE}
  &:\equiv \tqm{\grm{f}^\EE} \text{ for \grm{\Gamma \vdash f : \ExtPi{T}{B} : \Sc}}
\end{align*} %TODO this is a bit confusing since the application is for sorts and the types for points
Defining the erasure on point types and sort terms pulled back along a substitution,
we see that we will also need to erase entire sort substitutions.
This is achieved by extending the operation as follows:
\begin{equation*}
\inferrule{\grm{\IISub{\sigma}{\Gamma}{\Delta}}}
  {\tqm{\IISub{\grm{\sigma}^\EE_\Sc}{\grm{\Gamma}^\EE_\Sc}{\grm{\Delta}^\EE_\Sc}}}
\end{equation*}
We will then be able to use this in a straight forward way to define the pullbacks:
\begin{align*}
\tqm{\grm{A[\sigma]}^\EE}
  &:\equiv \tqm{\grm{A}^\EE[\sigma^\EE_\Sc]} \text{ for \grm{\Gamma \vdash A :: \Pc} and} \\
\tqm{\grm{t[\sigma]}^\EE}
  &:\equiv \tqm{\grm{t}^\EE[\sigma^\EE_\Sc]} \text{ for \grm{\Gamma \vdash t : B :: \Sc}.}
\end{align*}
Erasure of substitutions is built recursively, ignoring point types.
Likewise, the first projection will ignore point types:
\begin{align*}
\tqm{\grm{\epsilon}^\EE_\Sc}
  &:\equiv \tqm{\epsilon} \text{,} \\
\tqm{\grm{(\sigma,\, t)}^\EE_\Sc}
  &:\equiv \tqm{(\grm{\epsilon}^\EE_\Sc,\, \grm{t}^\EE)} \text{ for \grm{\Gamma \vdash t : B :: \Sc}, and} \\
\tqm{\grm{(\sigma,\, t)}^\EE_\Sc}
  &:\equiv \tqm{\grm{\epsilon}^\EE_\Sc} \text{.} \\
\tqm{\grm{\pi_1(\sigma)}^\EE_\Sc}
  &:\equiv \tqm{\pi_1(\grm{\sigma}^\EE_\Sc)} \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, B :: \Sc)}},} \\
\tqm{\grm{\pi_1(\sigma)}^\EE_\Sc}
  &:\equiv \tqm{\grm{\sigma}^\EE_\Sc} \text{ for \grm{\IISub{\sigma}{\Gamma}{(\Delta,\, A :: \Pc)}}, and} \\
\tqm{\grm{\pi_2(\sigma)}^\EE}
  &:\equiv \tqm{\pi_2(\grm{\sigma}^\EE_\Sc)} \text{.}
\end{align*} %TODO laws
This concludes the definition of the erasure operation.
\end{defn}

For the steps that follow it will be necessary to equip the \emph{algebras}
of the resulting signatures with a substitution calculus that also considers
point contexts instead of only sort contexts.
To this end, we defined what we called lifted substitution algebras in Definition~\ref{def:if-alg-lsub}

\section{(OLD) -- Type Erasure}

Since we cannot define type families simultaneously together with their index
type, we will first produce a version of a given code, whose dependencies between
sorts have been \emph{erased}.
For this, we will use an operation on contexts, types and terms, which we will
call \emph{flattening}.
The resulting code will specify a type which is now a mutual definition
of a number of plain types instead of families,
but it will, in general, contain too many elements, because it lacks all the
restrictions on which fiber arguments of inductively generated elements should
lie in.

Note that $\flatten{}$ erases all uses of the function type in the
specifications of sorts.

\section{(OLD) -- Wellformedness Predicates}

From this section onwards we will, for the code $\grm{\Gamma \equiv (\cdot, x_1 : A_1, \ldots, x_n : A_n)}$
in consideration, assume that we have the projections $\bar{x_1} : \bar{A_1}, \ldots, \bar{x_n} : \bar{A_1}$ of
$\con{\grm{\flatten{\Gamma}}} : \grm{\flatten{\Gamma}}^\CC$ at our disposal in the target
language.

To motivate the next step of our construction, consider the following code:
\begin{equation*}
\grm{
A : \UU,\, B : A \to \UU,\, a_0, a_1 : \underline{A},\, b : \underline{B(a_0)}
} \text{.}
\end{equation*}
In its flattened form
\begin{equation*}
\grm{
\bar{A} : \UU,\, \bar{B} : \UU,\, \bar{a_0}, \bar{a_1} : \underline{\bar{A}},\, \bar{b} : \underline{\bar{B}}
} \text{,}
\end{equation*}
there is no way to recognize, whether \grm{b} was meant to be in \grm{B(a_0)},
in \grm{B(a_1)}.
To reintroduce this piece of information, we will transform a given code into a
mutually defined predicate over the flattened code, which shall indicate, in which
fiber of a type family a given constructor (or one of its inductive arguments)
should be located.

\begin{defn}[Wellformedness]
Like with \grm{\flatten{}}, we define a \emph{annotation}
transformation \annotate{} on contexts, types, and
terms by structural recursion on the syntax.
On contexts and sort types it is defined like this:
\begin{align*}
\annotate{\cdot}			&:\equiv \grm{\cdot} \\
\annotate{(\Gamma, x : A)}		&:\equiv
	\begin{cases}
	\grm{\annotate{\Gamma}, W_x : \blm{\bar{x}} \to \annotate{A}}	& \text{for \grm{A :: \Sc}} \\
	\grm{\annotate{\Gamma}, w_x : \anntwo{\bar{x}}{A}}		& \text{for \grm{A :: \Pc}}
	\end{cases} \\
\annotate{\UU}				&:\equiv \grm{\UU} \\
\annotate{(x : a) \to B}		&:\equiv \grm{\flatten{a} \to \annotate{B}} \text{ for \grm{B :: \Sc}} \\
\annotate{(\blm{x : A}) \to B}		&:\equiv \grm{\blm{A} \to \annotate{B}}  \text{ for \grm{B :: \Sc}}
\end{align*} %TODO alignment
As we can see, on point types, the operation takes another argument, which is a
term of the target theory.
\begin{align*}
\anntwo{y}{\UU}				&:\equiv \grm{\UU} \\
\anntwo{y}{\underline{a}}		&:\equiv \grm{\underline{\anntwo{y}{a}}} \\
\anntwo{y}{(x : a) \to B}		&:\equiv
	\grm{(\blm{\bar{x} : \flatten{a}})(\annotate{\blm{\bar{x}}, a})}  \\
	& \grm{\hfill{} \to \anntwo{y(\bar{x})}{B}} & \text{for \grm{B :: \Pc}} \\
\anntwo{y}{(\blm{x : A}) \to B}	&:\equiv
	\grm{(\blm{x : A}) \to \anntwo{y(x)}{B}} & \text{for \grm{B :: \Pc}}
\end{align*}
Annotate is also defined where the second argument is a term of a sort type:
\begin{align*}
\anntwo{y}{x}				&:\equiv \grm{W_x(\blm{y})} \text{ for variables \grm{x}} \\
\anntwo{y}{t(u)}			&:\equiv \grm{\anntwo{y}{t}(\flatten{u})} \\
\anntwo{y}{t(\blm{u})}			&:\equiv \grm{\anntwo{y}{t}(\blm{u})} \\
\anntwo{y}{(\blm{x : A}) \to b}		&:\equiv \grm{(\blm{x : A}) \to \anntwo{y(x)}{b}} \\
\anntwo{y}{t \app \blm{u}}		&:\equiv \grm{\anntwo{y}{t} \app \blm{u}}
\end{align*}
\end{defn}

\begin{example}[Type Theory Syntax]
Let us look at one sort and one point constructor of our prime example~\ref{ex:ttintt}.
The sort \grm{\mathop{Ty} : \mathop{Con} \to \UU} gets transformed to the following:
\begin{align*}
\grm{W_{\mathop{Ty}} :} 
&\phantom{\equiv~} \grm{\blm{\overline{Ty}} \to \annotate{\mathop{Con} \to \UU} } \\
&\equiv \grm{\blm{\overline{Ty}} \to \flatten{\mathop{Con}} \to \annotate{\UU}} \\
&\equiv \grm{\blm{\overline{Ty}} \to \blm{\overline{Con}} \to \UU} \text{.}
\end{align*}
The point constructor
\grm{\mathop{pi} : (\Gamma : \mathop{Con})(A : \mathop{Ty}(\Gamma))(\mathop{Ty}(\mathop{ext}(\Gamma, A))) \to \underline{\mathop{Ty}(\Gamma)}}
becomes a term \grm{w_{\mathop{pi}}} of the following type:
\begin{align*}
& \grm{\anntwo{\overline{x}}{(\Gamma : \mathop{Con})(A : \mathop{Ty}(\Gamma))(\mathop{Ty}(\mathop{ext}(\Gamma, A)))
	\to \mathop{Ty}(\Gamma)}} \\
\equiv & \grm{(\blm{\overline{\Gamma} : \overline{Con}})(\anntwo{\overline{\Gamma}}{\mathop{Con}})
	\to \anntwo{\overline{pi}(\overline{\Gamma})}{(A : \mathop{Ty}(\Gamma))(\mathop{Ty}(\mathop{ext}(\Gamma, A))) \to \underline{\mathop{Ty}(\Gamma)}}} \\
\equiv & \grm{
	(\blm{\overline{\Gamma} : \overline{Con}})(W_{\mathop{Con}}(\blm{\overline{\Gamma}}))
	(\blm{\overline{A} : \overline{Ty}})(\anntwo{\overline{A}}{\mathop{Ty}(\Gamma)}) } \\
& \grm{
	\to \anntwo{\overline{pi}(\overline{\Gamma}, \overline{A})}{(\mathop{Ty}(\mathop{ext}(\Gamma, A))) \to \underline{\mathop{Ty}(\Gamma)}}
} \\
\equiv & \grm{
	(\blm{\overline{\Gamma} : \overline{Con}})(W_{\mathop{Con}}(\blm{\overline{\Gamma}}))
	(\blm{\overline{A} : \overline{Ty}})(\anntwo{\overline{A}}{\mathop{Ty}}(\blm{\overline{\Gamma}}))
	(\blm{\overline{B} : \overline{Ty}})(\anntwo{\overline{B}}{\mathop{Ty}(\mathop{ext}(\Gamma, A))}) } \\
& \grm{
	\to \anntwo{\overline{pi}(\overline{\Gamma}, \overline{A}, \overline{B})}{\underline{Ty(\Gamma)}}
} \\
\equiv & \grm{
	(\blm{\overline{\Gamma} : \overline{Con}})(W_{\mathop{Con}}(\blm{\overline{\Gamma}}))
	(\blm{\overline{A} : \overline{Ty}})(W_{\mathop{Ty}}(\blm{\overline{A}}, \blm{\overline{\Gamma}}))
	(\blm{\overline{B} : \overline{Ty}})(\anntwo{\overline{B}}{\mathop{Ty}}(\blm{\overline{ext}(\overline{\Gamma}, \overline{A})}))
} \\
& \grm{
	\to \underline{\anntwo{\overline{pi}(\overline{\Gamma}, \overline{A}, \overline{B})}{\mathop{Ty}(\Gamma)}}
} \\
\equiv & \grm{
	(\blm{\overline{\Gamma} : \overline{Con}})(W_{\mathop{Con}}(\blm{\overline{\Gamma}}))
	(\blm{\overline{A} : \overline{Ty}})(W_{\mathop{Ty}}(\blm{\overline{A}}, \blm{\overline{\Gamma}}))
	(\blm{\overline{B} : \overline{Ty}})(W_{\mathop{Ty}}(\blm{\overline{B}}, \blm{\overline{ext}(\overline{\Gamma}, \overline{A})}))
} \\
& \grm{
	\to \underline{\anntwo{\overline{pi}(\overline{\Gamma}, \overline{A}, \overline{B})}{\mathop{Ty}}(\blm{\overline{\Gamma}})}
} \\
\equiv & \grm{
	(\blm{\overline{\Gamma} : \overline{Con}})(W_{\mathop{Con}}(\blm{\overline{\Gamma}}))
	(\blm{\overline{A} : \overline{Ty}})(W_{\mathop{Ty}}(\blm{\overline{A}}, \blm{\overline{\Gamma}}))
	(\blm{\overline{B} : \overline{Ty}})(W_{\mathop{Ty}}(\blm{\overline{B}}, \blm{\overline{ext}(\overline{\Gamma}, \overline{A})}))
} \\
& \grm{ \hspace*{0pt}\hfill
	\to \underline{W_{\mathop{Ty}}(\blm{\overline{pi}(\overline{\Gamma}, \overline{A}, \overline{B})},\blm{\overline{\Gamma}})}
} 
\end{align*}
\end{example}

\begin{lemma}
We have \grm{\vdash \annotate{\Gamma}} for every \grm{\vdash \Gamma}.
\end{lemma}

\begin{proof}
We simultaneouly prove that all of the following rules are admissible:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma}}{\grm{\vdash \annotate{\Gamma}}}
\qquad
\inferrule{\grm{\Gamma \vdash B :: \Sc}}{\grm{\annotate{\Gamma} \vdash \annotate{B} :: \Sc}}
\\[.7em]
\inferrule{\grm{\Gamma \vdash A :: \Pc} \\ \bar{x} : \flatten{A}}{\grm{\annotate{\Gamma} \vdash \anntwo{\bar{x}}{A} :: \Pc}}
\\[.7em]
\inferrule{\grm{\Gamma \vdash a : B :: \Sc} \\ \bar{x} : \flatten{a}} %TODO underline here??
	{\grm{\annotate{\Gamma} \vdash \anntwo{\bar{x}}{a} : \annotate{B} :: \Sc}}
\end{gathered}
\end{equation*}
For context extension by sort constructors,
assume that \grm{\vdash \annotate{\Gamma}} and \grm{\annotate{\Gamma} \vdash \annotate{B} :: \Sc}.
Since \blm{\overline{x} : \overline{A} \equiv \UU}, we infer \grm{\annotate{\Gamma} \vdash \blm{\overline{x}} \to \annotate{B}},
and thus
\begin{equation*}
\grm{\vdash \annotate{\Gamma}, W_x : \blm{\overline{x}} \to \annotate{B} \equiv \annotate{\Gamma, x : A}} \text{.}
\end{equation*}
For extension by point constructors we similarly reason that given
\grm{\vdash \annotate{\Gamma}} and \grm{\Gamma \vdash A :: \Pc}, from which we
can infer \grm{\annotate{\Gamma} \vdash \anntwo{\overline{x}}{A}} for \blm{\overline{x} : \overline{A}},

Let us next handle the case of types in \grm{\Sc}.
Given \grm{\vdash \annotate{\Gamma}},
we obviously have \grm{\annotate{\Gamma} \vdash \annotate{\UU} \equiv \UU}.
To show that \grm{\annotate{\Gamma} \vdash \annotate{(x : a) \to B}}, we may assume
that \grm{\vdash \annotate{\Gamma}} and that for \blm{\overline{x} : \overline{a}}
we have \grm{\annotate{\Gamma} \vdash \anntwo{\overline{x}}{a} : \UU},
and that \grm{\annotate{\Gamma, x : \underline{a}} \vdash \annotate{B}}.
That latter reduces to
\begin{equation*}
\grm{\annotate{\Gamma}, w_x : \underline{\anntwo{\overline{x}}{a}} \vdash \annotate{B} :: \Sc} \text{,}
\end{equation*}
but since, by definition, \grm{B} cannot contain any reference to \grm{w_x},
we conclude \grm{\annotate{\Gamma} \vdash \annotate{B}}, which, together with
\grm{\annotate{\Gamma}} and \blm{\overline{A} : \UU}, suffices to show
the desired result.
The case of non-inductive functions works likewise.

There are three formers for \grm{\Pc}-types: Small types, inductive functions, and
non-inductive functions:
\begin{itemize}
\item Assume that \grm{\Gamma \vdash a : \UU} and thus that for each
\blm{\overline{x} : \overline{a}} we have
\grm{\annotate{\Gamma} \vdash \anntwo{\overline{x}}{a} : \UU}.
We know that \grm{\annotate{\Gamma} \vdash \underline{\anntwo{\overline{x}}{a}}}
which is enough to infer \grm{\annotate{\Gamma} \vdash \underline{\anntwo{\overline{x}}{a}} \equiv \anntwo{\overline{x}}{\underline{a}}}.
\item Given \grm{\Gamma \vdash a : \UU} and \grm{\Gamma, x : \underline{a} \vdash B :: \Pc}
we may assume that \grm{\annotate{\Gamma} \vdash \anntwo{\overline{x}}{a} : \UU} for \blm{\overline{x} : \overline{a}}
and that for \blm{\overline{y}:\overline{B}} we have
\begin{equation*}
\grm{\annotate{\Gamma}, w_x : \anntwo{\overline{x}}{a} \vdash \anntwo{\overline{y}}{B} :: \Pc} \text{.}
\end{equation*}
We want to show that for \blm{\overline{f} : \overline{(x : a) \to B} \equiv (\overline{x} : \overline{a}) \to \overline{B}},
\begin{align*}
\grm{\annotate{\Gamma}} &\vdash \grm{\anntwo{\overline{f}}{(x : a) \to B} :: \Pc} \\
&\equiv \grm{(\blm{\overline{x} : \overline{a}})(\anntwo{\overline{x}}{a}) \to \anntwo{\overline{f}(\overline{x})}{B}} \text{.}
\end{align*}
To this end, we need to show that for \blm{\overline{x} : \overline{a}} we have
\grm{\annotate{\Gamma} \vdash \anntwo{\overline{x}}{a} \to \anntwo{\overline{f}(\overline{x})}{B}},
but this is true by induction and weakening.
\end{itemize}
As a last part of this proof, we need to show that \grm{\annotate{}} behave well
on the terms of \grm{\Sc}-types: Variables and applications of inductive and
non-inductive functions.
\begin{itemize}
\item Given \grm{\Gamma \vdash B :: \Sc} and assuming \grm{\annotate{\Gamma} \vdash \annotate{B}},
we want to show that for \blm{\overline{x}:\overline{a}} we have
\begin{equation*}
\grm{\annotate{\Gamma, a : B} \vdash \anntwo{\overline{x}}{a} : \annotate{B}} \text{,}
\end{equation*}
but this reduces to
\begin{equation*}
\grm{\annotate{\Gamma}, W_a : \blm{\overline{a}} \to \annotate{B} \vdash W_a(\blm{\overline{x}}) : \annotate{B}} \text{,}
\end{equation*}
which is obviously true.
\item Let \grm{\Gamma \vdash t : (x : a) \to B :: \Sc}, which lets us assume
\begin{equation*}
\grm{\annotate{\Gamma} \vdash \anntwo{\overline{f}}{t} : \blm{\overline{a}} \to \annotate{B}} \text{ for \blm{\overline{f} : \overline{t}}.}
\end{equation*}
For \grm{u : \underline{a}} we than have that
\begin{align*}
\grm{\annotate{\Gamma} \vdash} & \grm{\anntwo{\overline{f}}{t}(\overline{u}) : \annotate{B}} \\
& \grm{\equiv \anntwo{\overline{f}}{t(u)} : \annotate{B[x \mapsto u]}} \text{,}
\end{align*}
since \grm{x} is turned into \grm{w_x} which \grm{\annotate{B}} doesn't depend on. %TODO make this cleaner
\item For \blm{A : \UU}, \grm{\vdash \annotate{\Gamma}}, and
\begin{align*}
\grm{\annotate{\Gamma} \vdash} & \anntwo{\overline{f}}{t} : \annotate{(\blm{x : A}) \to B} \\
& \equiv \anntwo{\overline{f}}{t} : A \to \annotate{B} \text{ for \blm{\overline{f} : \overline{t}},}
\end{align*}
we see that for any \blm{u : A} we have \grm{\anntwo{\overline{f}}{t}(u) \equiv \anntwo{\overline{f}}{t(u)} : \annotate{B[\blm{x} \mapsto \blm{u}]}}
as desired.
\end{itemize}
\end{proof}

Like \grm{\flatten{}}, \grm{\annotate{}} only produces inductive families, so
we can assume to have $\con{\grm{\annotate{\Gamma}}} : \grm{\annotate{\Gamma}}^\CC$:

\begin{lemma}
If \grm{\vdash{\Gamma}}, then \grm{\annotate{\Gamma}} is an inductive family.
\end{lemma}

\begin{proof}
All occurences of inductive functions in sort constructors are replaced
by non-inductive functions.
\end{proof}

\section{Constructing the initial algebra}

With \grm{\flatten{\Gamma}} and \grm{\annotate{\Gamma}} with have two inductive
families which will suffice to construct the initial algebra for any code \grm{\Gamma}:
We use $\Sigma$-types over the wellformedness predicates to select which ones of
the objects in the flattened types and type families we want to include in the
initial algebra.

\begin{defn}(Initial algebra)
Define \blm{\con{}} on contexts by:
\begin{align*}
\con{\cdot} &:\equiv \star : \unit \\
\con{\Gamma, a : B :: \Sc} &:\equiv (\con{\Gamma}, \contwo{W_a}{B}) \\
\con{\Gamma, x : A :: \Pc} &:\equiv (\con{\Gamma}, \conthree{\bar{x}}{w_x}{A}) \\
\end{align*}
On sort constructors we need:
\begin{align*}
\contwo{f}{\UU} &:\equiv
\begin{cases}
(x : A) \to \contwo{b}{\UU} & \text{if \blm{f \equiv (x : A) \to b : \UU},} \\
\Sigma(f) & \text{otherwise} %TODO avoid this distinction
\end{cases}\\
\contwo{f}{(x : a) \to B :: \Sc} &:\equiv \lambda x : \conthree{\flatten{a}}{\annotate{a}}{\UU}. \contwo{\lambda y. f(y, \pr_1(x))}{B} \\ %TODO fix
\contwo{f}{(\blm{x : A}) \to B :: \Sc} &:\equiv \lambda x : A. \contwo{\lambda y. f(y, x)}{B}
\end{align*}
On point constructor we have:
\begin{align*}
\conthree{f}{w}{\underline{a}} &:\equiv (f, w) \text{ for a variable \grm{a}} \\
\conthree{f}{w}{\underline{t(u)}} &:\equiv \conthree{f}{w}{\underline{t}} \\
\conthree{f}{w}{\underline{(\blm{x : A}) \to b}} &:\equiv \lambda x : A. \conthree{f(x)}{w(x)}{\underline{b}} \\
\conthree{f}{w}{(x : a) \to B :: \Pc} &:\equiv
\lambda x : \conthree{\flatten{a}}{\annotate{a}}{\UU}. \conthree{f(\pr_1(x))}{w(\pr_1(x), \pr_2(x))}{B} \\ %TODO fix
\conthree{f}{w}{(\blm{x : A}) \to B :: \Pc} &:\equiv
\lambda x : A. \conthree{f(x)}{w(x)}{B}
\end{align*}
Here, \blm{\pr_1} and \blm{\pr_2} are generalized projections, defined on universe
terms and for $i \in {1, 2}$ as follows:
\begin{align*}
\pr_i(y, \grm{a}) &:\equiv \pr_i(y) \text{ for a variable \grm{a}} \\
\pr_i(y, \grm{t(u)}) &:\equiv \pr_i(y) \\ %TODO this really seems fishy
\pr_i(y, \grm{(\blm{x : A}) \to b}) &:\equiv \lambda x : A. \pr_i(y(x), \grm{b})
\end{align*}
Also we need for universe terms a way to reference them as the domain of function
types:
\begin{align*}
\mathsf{ref}(\grm{a}) &:\equiv \contwo{W_a}{\UU} \text{ for a variable \grm{a}} \\
\mathsf{ref}(\grm{t(u)}) &:\equiv \mathsf{ref}(\grm{t})(\bar{u}) \\
\mathsf{ref}(\grm{(\blm{x : A}) \to b}) &:\equiv (x : A) \to \mathsf{ref}(\grm{b})
\end{align*}
\end{defn}

\section{Constructing the Eliminator}

TODO: Define $r$
