\documentclass[12pt,headings=optiontohead,openany,oneside,a4paper]{book}
%TODO: page layout
\usepackage[backref=page,
unicode,
pdfauthor={Jakob von Raumer},
pdftitle={Reducing Inductive-Inductive Types to Indexed Inductive Types},
pdfsubject={Mathematics, Computer Science},
pdfkeywords={interactive theorem proving}]{hyperref}

%code listings
\usepackage{mathpartir}
\usepackage{newunicodechar}
%\renewcommand{\MintedPygmentize}{./pygments-main/pygmentize}
\usepackage{fontspec,xunicode}
\usepackage[osf]{mathpazo}
%\usepackage{shellesc}
\usepackage{minted}
\setmainfont[Ligatures=TeX]{TeX Gyre Pagella}
\setmonofont{Ubuntu Mono}
\newfontfamily{\freeserif}{DejaVu Sans}
\newunicodechar{⦃}{\ensuremath{\texttt{\{}\mkern-7mu\texttt{|}}}
	%{\makebox[.5em]{\freeserif⦃}}
\newunicodechar{⦄}{\ensuremath{\texttt{|}\mkern-7mu\texttt{\}}}}
	%{\makebox[.5em]{\freeserif⦄}}
\newunicodechar{→}{\texttt{\freeserif{→}}}
\newunicodechar{⟶}{\texttt{\freeserif{⟶}}}
\newunicodechar{⁻}{\texttt{\freeserif{⁻}}}
\newunicodechar{▹}{\freeserif{▹}}
\newunicodechar{ℕ}{\texttt{\freeserif{ℕ}}}
\newunicodechar{⟨}{\texttt{\freeserif{⟨}}}
\newunicodechar{⟩}{\texttt{\freeserif{⟩}}}
\newunicodechar{⬝}{\ensuremath{\ct}}
\newunicodechar{∼}{\freeserif{∼}}
\newunicodechar{≃}{\freeserif{≃}}
\newunicodechar{≅}{\freeserif{≅}}
\newunicodechar{∘}{\freeserif{∘}}
\newunicodechar{ʰ}{\freeserif{ʰ}}
\newunicodechar{ᵍ}{\freeserif{ᵍ}}
\newunicodechar{⇒}{\freeserif{⇒}}
\newunicodechar{⋆}{\freeserif{⋆}}
\newunicodechar{∘}{\freeserif{∘}}
\newunicodechar{←}{\freeserif{←}}

%workaround to remove red boxes
\AtBeginEnvironment{minted}{\renewcommand{\fcolorbox}[4][]{#4}}
\usemintedstyle{colorful}
\newminted{lean}{
	linenos,
	numbersep=5pt,
	frame=single,
	fontsize=\footnotesize,
	framesep=1mm,
	samepage,
	autogobble}
\newminted[leancodebr]{lean}{
	linenos,
	numbersep=5pt,
	frame=single,
	fontsize=\footnotesize,
	framesep=1mm,
	autogobble}
\newcommand{\leani}[1]{\mintinline{lean}{#1}}
\newminted{agda}{
	linenos,
	numbersep=5pt,
	frame=single,
	fontsize=\footnotesize,
	framesep=1mm,
	samepage,
	autogobble}

\linespread{1.05}
\usepackage[dvipsnames]{xcolor}
\usepackage{graphicx}
\usepackage{array}
\usepackage[all,2cell,cmtip]{xy}
\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing,arrows}
\usepackage[numbered]{bookmark}
\usepackage{fancyhdr}
\usepackage{amssymb,amsmath,amsthm,mathrsfs,wasysym}
\usepackage{enumitem,mathtools,xspace}
\usepackage[nottoc]{tocbibind}
\usepackage{cleveref}
\usepackage{aliascnt}
\usepackage{natbib}
\usepackage{mathtools}
\usepackage{footnote}
\usepackage{booktabs}
%\usepackage[top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry} %TODO decide

\fancyhead[LO]{\leftmark}
\fancyhead[RE]{\rightmark}
\fancyhead[LE,RO]{\thepage}
\cfoot{}
\pagestyle{fancy}

\def\defthm#1#2#3{
	\newaliascnt{#1}{thm}
	\newtheorem{#1}[#1]{#2}
	\aliascntresetthe{#1}
	\crefname{#1}{#2}{#3}
}

\newtheorem{thm}{Theorem}[section]
\crefname{thm}{Theorem}{Theorems}
\defthm{lemma}{Lemma}{Lemmas}
\defthm{axiom}{Axiom}{Axioms}
\defthm{corollary}{Corollary}{Corollaries}
\theoremstyle{definition}
\defthm{defn}{Definition}{Definitions}
\defthm{example}{Example}{Examples}
\defthm{remark}{Remark}{Remarks}

\newcommand{\upperf}{\partial^-_1}
\newcommand{\lowerf}{\partial^+_1}
\newcommand{\leftf}{\partial^-_2}
\newcommand{\rightf}{\partial^+_2}
\newcommand{\inv}{^{-1}}
\newcommand{\DCat}{\mathbf{DCat}}
\newcommand{\DGpd}{\mathbf{DGpd}}
\newcommand{\XMod}{\mathbf{XMod}}
\newcommand{\twotype}{\mathbf{2}}
\newcommand{\unit}{\mathbf{1}}
\newcommand{\emptytype}{\mathbf{0}}
\newcommand{\UU}{\mathcal{U}}
\newcommand{\isProp}{\mathsf{isProp}}
\newcommand{\isSet}{\mathsf{isSet}}
\newcommand{\PropU}{\mathsf{Prop}}
\newcommand{\SetU}{\mathsf{Set}}
\newcommand{\seg}{\mathsf{seg}}
\newcommand{\isContr}{\mathsf{isContr}}
\newcommand{\isIso}{\mathsf{isIso}}
\newcommand{\idtoiso}{\mathsf{idtoiso}}
\newcommand{\idtoeqv}{\mathsf{idtoeqv}}
\newcommand{\ua}{\mathsf{ua}}
\newcommand{\alliso}{\mathsf{alliso}}
\newcommand{\refl}{\mathsf{refl}}
\newcommand{\ap}{\mathsf{ap}}
\newcommand{\apd}{\mathsf{apd}}
\newcommand{\ind}{\mathsf{ind}}
\newcommand{\rec}{\mathsf{rec}}
\newcommand{\pr}{\mathsf{pr}}
\newcommand{\inl}{\mathsf{inl}}
\newcommand{\inr}{\mathsf{inr}}
\newcommand{\ishae}{\mathsf{ishae}}
\newcommand{\apiop}{\ap_{\iota'}}
\DeclareMathOperator{\comp}{comp}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\invv}{inv_1}
\DeclareMathOperator{\invh}{inv_2}
\DeclareMathOperator{\obj}{obj}
\DeclareMathOperator{\EI}{EI}
\DeclareMathOperator{\IE}{IE}
\DeclareMathOperator{\op}{op}
\DeclareMathOperator{\inj}{inj}
\newcommand{\assoc}{\mathsf{assoc}}
\newcommand{\assocv}{\mathsf{assoc}_1}
\newcommand{\assoch}{\mathsf{assoc}_2}
\newcommand{\idLeft}{\mathsf{idLeft}}
\newcommand{\idLeftv}{\mathsf{idLeft}_1}
\newcommand{\idLefth}{\mathsf{idLeft}_2}
\newcommand{\idRight}{\mathsf{idRight}}
\newcommand{\idRightv}{\mathsf{idRight}_1}
\newcommand{\idRighth}{\mathsf{idRight}_2}
\newcommand{\leftInv}{\mathsf{leftInv}}
\newcommand{\leftInvv}{\mathsf{leftInv}_1}
\newcommand{\leftInvh}{\mathsf{leftInv}_2}
\newcommand{\rightInv}{\mathsf{rightInv}}
\newcommand{\rightInvv}{\mathsf{rightInv}_1}
\newcommand{\rightInvh}{\mathsf{rightInv}_2}
\newcommand{\respectId}{\mathsf{respectId}}
\newcommand{\respectIdv}{\mathsf{respectId}_1}
\newcommand{\respectIdh}{\mathsf{respectId}_2}
\newcommand{\respectComp}{\mathsf{respectComp}}
\newcommand{\respectCompv}{\mathsf{respectComp}_1}
\newcommand{\respectComph}{\mathsf{respectComp}_2}
\newcommand{\isequiv}{\mathsf{isequiv}}
\newcommand{\isodd}{\mathsf{isodd}}
\newcommand{\thin}{\mathsf{thin}}
\newcommand{\Sbase}{\mathsf{base}}
\newcommand{\Sloop}{\mathsf{loop}}
\newcommand{\Smerid}{\mathsf{merid}}
\newcommand{\vecty}{\mathsf{vec}}
\newcommand{\nil}{\mathsf{nil}}
\newcommand{\cons}{\mathsf{cons}}
\newcommand{\ct}{
	\mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}
		{\mathbin{\raisebox{0.5ex}{$\centerdot$}}}
		{\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}
		{\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}
\newcommand{\trunc}[2]{\left\Vert #2\right\Vert_{#1}}
\newcommand{\squash}[1]{\trunc{}{#1}}
\newcommand{\isntype}[1]{\mathsf{is}\mbox{-}{#1}\mbox{-}\mathsf{type}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Sph}{\mathbb{S}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Cat}{\mathbf{Cat}}
\newcommand{\Fam}{\mathbf{Fam}}
\newcommand{\Alg}{\mathbf{Alg}}
\newcommand{\CT}{\mathbf{CT}}
\newcommand{\CTw}{\mathbf{CTw}}
\newcommand{\old}[1]{\overline{#1}}
\newcommand{\oldold}[1]{\overline{\overline{#1}}}
\newcommand{\gr}[1]{{\color{ForestGreen}#1}}
\newcommand{\grm}[1]{\ensuremath{\gr{#1}}}
\newcommand{\blm}[1]{\ensuremath{{\color{Black}#1}}}
%\newcommand{\grinfer}[2]{\grm{\inferrule{{#1}}{{#2}}}}
\newcommand{\Sc}{\mathsf{S}}
\newcommand{\Pc}{\mathsf{P}}
\newcommand{\CC}{\mathsf{C}}
\newcommand{\EE}{\mathsf{E}}
\newcommand{\MM}{\mathsf{M}}
\newcommand{\mm}{\mathsf{m}}
\newcommand{\con}{\mathsf{con}}
\newcommand{\elim}{\mathsf{elim}}
\newcommand{\flatten}[1]{\blm{\mathsf{flatten}(\grm{#1})}}
\newcommand{\app}{\mathrel{@}}

\renewcommand{\backrefalt}[4]{
	\ifcase #1
		(No citations.)
	\or
		(Cited on page\ #2.)
	\else
		(Cited on pages\ #2.)
	\fi
}

\begin{document}

\title{Reducing Inductive-Inductive Types to Indexed Inductive Types}
\author{Jakob von Raumer}

\frontmatter
\maketitle

\tableofcontents

\mainmatter

\chapter{Introduction}

\section{Examples of Inductive-Inductive Types}

In the following, we will take a look at a few examples which we are going to
revisit at various steps throughout this presentation:

\begin{example}[Type Theory Syntax]\label{ex:ttintt}
\cite{ttintt} showed how to internalise the syntax of type theory inside type
theory itself, using a quotient inductive-inductive type.
Leaving out terms and substitutions, we arrive at a fragment of type theoretical
syntax specifying a type of contexts and a type of types over a certain contexts,
together with type formers for a unit type and a $\Pi$-type:
We want $\mathop{Con} : \UU$ to be inductively defined by
\begin{align*}
\mathop{nil}	&: \mathop{Con} \text{and } \\
\mathop{ext}	&: (\Gamma : \mathop{Con})(A : \mathop{Ty}(\Gamma)) \to \mathop{Con} \text{,}
\end{align*}
while simultaneously defining a family $\mathop{Ty} : \mathop{Con} \to \UU$ with constructors
\begin{align*}
\mathop{unit}	&: (\Gamma : \mathop{Con}) \to \mathop{Ty}(\Gamma) \text{ and} \\
\mathop{pi}	&: (\Gamma : \mathop{Con})(A : \mathop{Ty}(\Gamma))(B : \mathop{Ty}(\mathop{ext}(\Gamma, A))) \to \mathop{Ty}(\Gamma) \text{.}
\end{align*}
\end{example}

\begin{example}[Free Dense Completion]
\cite{nordvallinductive} proposed the example of a ``free dense completion'' of
an order (or, more general, any relation) which for any type $A : \UU$ and
any type valued relation $\_<\_ : A \to A \to \UU$ on $A$ freely adds midpoints
to all pairs of related elements by $\_<\_$.
It does so by introducing a new type $A' : \UU$ inductively generated by the
original points and their midpoints:
\begin{align*}
\iota_A		&: A \to A' \text{ and} \\
\mathop{mid}	&: \{x, y : A'\}(p : x <' y) \to A' \text{.}
\end{align*}
But since our relation was only defined on $A$, we have to extend it to $A'$ by
postulating
\begin{align*}
\iota_<		&: \{a, b : A\}(p : a < b) \to \iota_A(a) <' \iota_A(b) \text{,} \\
\mathop{mid}_l	&: \{x, y : A'\}(p : x <' y) \to x < \mathop{mid}(p) \text{, and} \\
\mathop{mid}_r	&: \{x, y : A'\}(p : x <' y) \to \mathop{mid}(p) < y \text{.}
\end{align*}
\end{example}

\chapter{Specification of Inductive-Inductive Types}

Inductive-Inductive Types are specified by giving a context in  a small type
theoretic syntax which we will refer to as \emph{source type theory}.

This idea originates from Ambrus Kaposi's work on the syntax of \emph{higher}
inductive-inductive types (~\cite{ambrussyntax}) which we adapt and rid of equality
constructors to only allow for inductive-inductive types.
In contrast to their presentation we will leave the context of the ambient type
theory implicit and, instead of highlighting syntax of the ambient type theory,
mark elements of the source type theory in \gr{green}.

We assume that the source type theory makes use of the standard syntax of type
theory, using contexts, types, terms, and variables.
Types and terms are uniquely ascribed to one of two \emph{kinds}:
Either their kind is \grm{\Sc} which indicates that the type contains sort
constructors, or their kind is \grm{\Pc} because elements of it describe
point constructors.
We will write \grm{\Gamma \vdash A :: k} to say that \grm{A} is a type of kind
\grm{k} and \grm{\Gamma \vdash t : A :: k} to state that \grm{t} is a term of the
type \grm{A} which in turn has kind \grm{k}.
Often, we will omit the annotation of the sort, meaning that a judgment is to
hold true for both \grm{\Sc} and \grm{\Pc}, or that the kind of a term's type
has already been specified.

\section{The Source Type Theory}

We will work with named variables and implicit weakening, giving the following
rules:
\begin{equation*}
\begin{gathered}
\inferrule{}{\grm{\vdash \cdot}}
\qquad
\inferrule{\grm{\Gamma \vdash A}}{\grm{\vdash \Gamma, x : A}}
\qquad
\inferrule{\grm{\Gamma \vdash A}}{\grm{\Gamma, x : A \vdash x : A}}
\qquad
\inferrule{\grm{\Gamma \vdash x : A} \\ \grm{\Gamma \vdash B}}{\grm{\Gamma, y : B \vdash x : A}}
\end{gathered}
\end{equation*}

The universe \grm{\UU} is used as the type of constant sorts. We use a Tarski-style
encoding of its elements, so we have an explicit notation for the extraction of
``small'' types extracted from this universe:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma}}{\grm{\Gamma \vdash \UU :: \Sc}}
\qquad
\inferrule{\grm{\Gamma \vdash a : \UU :: \Sc}}{\grm{\Gamma \vdash \underline{a} :: \Pc}}
\end{gathered}
\end{equation*}

Our source type theory finally features three different formers for $\Pi$-types.
The first one are functions used for \emph{inductive parameters} which, to ensure
strict positivity of constructors, allow only small domains.
Their kind is thus determined only by the kind of their codomain:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\Gamma \vdash a : \UU} \\ \grm{\Gamma, x : \underline{a} \vdash B :: k}}
	{\grm{\Gamma \vdash ((x : a) \to B) :: k}}
\qquad
\inferrule{\grm{\Gamma \vdash t : (x : a) \to B} \\ \grm{\Gamma \vdash u : \underline{a}}}
	{\grm{\Gamma \vdash t(u) : B[x \mapsto u]}}
\end{gathered}
\end{equation*}

For \emph{non-inductive}, or \emph{external parameters}, we introduce a function
type whose domain
is a type of the ambient theory we're working in:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma} \\ A : \UU_i \\ (x : A) \to (\grm{\Gamma \vdash B :: k})}
	{\grm{\Gamma \vdash ((\blm{x : A}) \to B) :: k}}
\qquad
\inferrule{\grm{\Gamma \vdash t : (\blm{x : A}) \to B} \\ u : A}
	{\grm{\Gamma \vdash t(\blm{u}) : B[\blm{x} \mapsto \blm{u}]}}
\end{gathered}
\end{equation*}

Since for some examples of inductive-inductive types, especially ones which are
\emph{infinitely branching}, we need functions with external domain as the domains of
other functions, we will also add another function type which is itself small, and
has external domain and small codomain:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma} \\ A : \UU_i \\ (x : A) \to (\grm{\Gamma \vdash b : \UU})}
	{\grm{\Gamma \vdash ((\blm{x : A}) \to b) : \UU}}
\qquad
\inferrule{\grm{\Gamma \vdash t : \underline{(\blm{x : A}) \to b}} \\ u : A}
	{\grm{\Gamma \vdash (t \app \blm{u}) : \underline{b[\blm{x} \mapsto \blm{u}]}}}
\end{gathered}
\end{equation*}

Note that for none of the function types we add the means for $\lambda$-abstrac\-tion,
so there is no need for $\alpha$-conversion, $\beta$-reduction, and $\eta$-conversion.

\begin{example}
To see what the different function types are used for, consider the following three
examples:

The encoding of the natural numbers as would correspond to the
following source type theory context using the first :
\begin{equation*}
\grm{
\cdot,\, \N : \UU,\, 0 : \underline{\N},\, \mathop{S} : (n : \N) \to \underline{\N}
}\text{.}
\end{equation*}

The type of vectors over a type $A : \UU$ can be represented using the ``external''
natural numbers $\N$.
In the following, the constructor \blm{\mathop{cons}} uses both the non-inductive
and the inductive function type:
\begin{equation*}
\grm{
\cdot,\, \vecty : \blm{\N} \to \UU,\, \mathop{nil} : \underline{\vecty(\blm{0})},\,
	\mathop{cons} : (\blm{n : \N})(\blm{a : A})(v : \vecty(\blm{n})) \to \underline{\vecty(\blm{S(n)})}
}
\end{equation*}

An example for a type which uses the third, small function type is the following
definition of full $\omega$-ary rooted trees:
\begin{equation*}
\grm{
\cdot,\, T : \UU,\, \mathop{leaf} : \underline{T},\,
	\mathop{node} : (\blm{\N} \to T) \to \underline{T}
} \text{.}
\end{equation*}
\end{example}

\begin{example}[Type Theory Syntax]
The example of the syntax of type theory~\ref{ex:ttintt} is represented by the
following code:
\begin{multline*}
\grm{\cdot,\, \mathop{Con} : \UU,\, \mathop{Ty} : \mathop{Con} \to \UU,} \\
\grm{\mathop{nil} : \mathop{Con},} \\
\grm{\mathop{ext} : (\Gamma : \mathop{Con})(A : \mathop{Ty}(\Gamma)) \to \underline{\mathop{Con}},} \\
\grm{\mathop{unit} : (\Gamma : \mathop{Con}) \to \underline{\mathop{Ty}(\Gamma)},} \\
\grm{\mathop{pi} : (\Gamma : \mathop{Con})(A : \mathop{Ty}(\Gamma))(B : \mathop{Ty}(\mathop{ext}(\Gamma, A))) \to \underline{\mathop{Ty}(\Gamma)}}
\end{multline*} %TODO find a better way to typeset this!
\end{example}

\section{Algebras for the Codes}

To give meaning to the codes expressed in the source type theory, we need to
interpret the contexts as a type in the ambient type theory whose elements are
the algebras of of the specified inductive-inductive type.
This means that the interpretation of our contexts must give the types of the
sort and point constructors they specify.

\begin{defn}[Constructor operator]
By structural recursion over the source syntax, we define an operation $-^\CC$
which assigns types to source contexts, fibrations over those to types and
sections to terms:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma}}{\grm{\Gamma}^C : \UU_1}
\qquad
\inferrule{\grm{\Gamma \vdash A}}{\grm{A}^C : \grm{\Gamma}^C \to \UU_1}
\qquad
\inferrule{\grm{\Gamma \vdash t : A}}{\grm{t}^C : (\gamma : \grm{\Gamma}^C) \to \grm{A}^C(\gamma)}
\end{gathered}
\end{equation*}

We will give the construction on contexts, types, and terms, while relying on
the freshness of names to make sure that the construction respects the substitution
calculus which we left implicit in this presentation. On contexts, the operation
is defined by iterated $\Sigma$-types:
\begin{align*}
\grm{\cdot}^\CC &:\equiv \unit \text{ and} \\
\grm{(\Gamma, x : A)}^\CC &:\equiv (\gamma : \grm{\Gamma}^\CC) \times \grm{A}^\CC(\gamma)
\end{align*}
Alternatively, context interpretation $\grm{(\cdot, x_1 : A_1, \ldots, x_n : A_n)}^\CC$
can be considered a \emph{record type} with fields $x_1 : \grm{A_1}^\CC, \ldots, x_n : \grm{A_n}^\CC$.

Sorts will be interpreted as functions into the universe, constructors as inhabiting
these functions:
\begin{align*}
\grm{\UU}^\CC(\gamma) 			&:\equiv \UU_0 \text{,} \\
\grm{(\underline{a})}^\CC(\gamma)	&:\equiv \grm{a}^\CC(\gamma) \text{,} \\
\grm{((x : a) \to B)}^\CC(\gamma)	&:\equiv (x : \grm{a}^\CC(\gamma)) \to \grm{B}^\CC(\gamma, x) \text{, and} \\ %TODO notation?
\grm{((\blm{x : A}) \to B)}^\CC(\gamma) &:\equiv (x : A) \to \grm{B}^\CC(\gamma) \text{.}
\end{align*}
The interpretation of terms is the straightforward translation into the type interpretation
above:
\begin{align*}
\grm{x}^\CC(\gamma) 			&:\equiv \gamma.\grm{x} \qquad \text{for variables \grm{x},} \\
\grm{(t(u))}^\CC(\gamma)		&:\equiv (\grm{t}^\CC(\gamma))(\grm{u}^\CC(\gamma)) \text{,} \\
\grm{((\blm{x : A}) \to b)}^\CC(\gamma)	&:\equiv (x : A) \to \grm{b}^\CC(\gamma) \text{,} \\
\grm{(t(\blm{u}))}^\CC(\gamma)		&:\equiv (\grm{t}^\CC(\gamma))(u) \text{, and} \\
\grm{(t \app \blm{u})}^\CC(\gamma)	&:\equiv (\grm{t}^\CC(\gamma))(u) \text{.}
\end{align*}

\end{defn}

TODO: Add some examples here.

\section{Motives and Methods}

TODO: Add definition of $\grm{-}^\MM$.

TODO: Add examples.

\section{Recursion and Computation}

TODO: Add definition of $\grm{-}^\EE$.

TODO: Add examples.

\section{Existence of HIITs}

\begin{defn}[Dependent Eliminator]
An algebra $c : \grm{\Gamma}^\CC$ is said to admit \emph{dependent elimination}
if for each motive $m : \grm{\Gamma}^\MM(c)$ there is a dependent eliminator
$\elim_{\grm{\Gamma}}(m) : \grm{\Gamma}^\EE(c, m)$.
\end{defn}

\begin{thm}[Admissibility of Inductive-Inductive Types]
Our type theory admits inductive-inductive types if for each wellformed context
$\grm{\Gamma}$ we can find a constructor $\con_{\grm{\Gamma}}$ which admits dependent
elimination $\elim_{\grm{\Gamma}}$.
\end{thm}

\section{Morphisms of Algebras}

TODO: Add definition of algebra morphisms $\grm{-}^\mm$.

TODO: Add examples.

\chapter{Reducing Inductive-Inductive Types to Inductive Families}
\chaptermark{Reducing Inductive-Inductive Types}

\section{Inductive Families}

TODO: Add definition of inductive families

TODO: postulate their existence

\section{Initiality}

\begin{defn}[Initial algebra]
For a source context \grm{\vdash \Gamma}, an algebra $s : \grm{\Gamma}^\CC$ is
called \textbf{initial}, if there is a \emph{unique} algebra morphism from $s$ to any
other algebra, which is to say that the following two rules hold true:
\begin{equation*}
\begin{gathered}
\inferrule{a : \grm{\Gamma}^\CC}{m_a : \grm{\Gamma}^\mm(s, a)}
\qquad
\inferrule{a : \grm{\Gamma}^\CC \\ m' : \grm{\Gamma}^\mm(s, a)}{m' = m_a}
\end{gathered}
\end{equation*}
We will call the first rule \emph{weak initiality} and the second one \emph{universality}
of the algebra.
\end{defn}

\section{Initiality implies Elimination}

TODO: use sigma construction for this, cite whoever's done this first

\section{Type Erasure}

Since we cannot define type families simultaneously together with their index
type, we will first produce a version of a given code, whose dependencies between
sorts have been \emph{erased}.
For this, we will use an operation on contexts, types and terms, which we will
call \emph{flattening}.
The resulting code will specify a type which is now a mutual definition
of a number of plain types instead of families,
but it will, in general, contain too many elements, because it lacks all the
restrictions on which fiber arguments of inductively generated elements should
lie in.
The flattening construction is defined like this:

\begin{defn}[Flattening]
Let \grm{\Gamma} be a context. We inductively define an operation $\flatten{}$ on
contexts, types and terms, returning contexts, types on flattened contexts, and
terms of flattened types, respectively:
\begin{align*}
\flatten{\cdot}			&:\equiv \grm{\cdot} \\
\flatten{\Gamma, x : A}		&:\equiv \grm{(\flatten{\Gamma}, \bar{x} : \flatten{A})} \\ %TODO bar or overline?
\flatten{\UU}			&:\equiv \grm{\UU} \\
\flatten{\underline{a}}		&:\equiv \grm{\underline{\flatten{\grm{a}}}} \\
\flatten{(x : a) \to B}		&:\equiv
	\begin{cases}
	\flatten{B} & \text{for \grm{B :: \Sc},} \\
	\grm{(\bar{x} : \flatten{a}) \to \flatten{B}} & \text{for \grm{B :: \Pc}}
	\end{cases} \\
\flatten{(\blm{x : A}) \to B}	&:\equiv \grm{(\blm{x : A}) \to \flatten{B}} \\
\flatten{x}				&:\equiv \grm{\bar{x}} \qquad \text{for variables \grm{x}} \\
\flatten{t(u)}			&:\equiv
	\begin{cases}
	\flatten{t} & \text{for \grm{t : (x : a) \to B :: \Sc},} \\
	(\flatten{t})\grm{(\flatten{u})} & \text{for \grm{t : (x : a) \to B :: \Pc}}
	\end{cases} \\
\flatten{t(\blm{u})}		&:\equiv (\flatten{t})\grm{(\blm{u})} \\
\flatten{(\blm{x : A}) \to b}	&:\equiv \grm{(\blm{x : A}) \to \flatten{b}} \\
\flatten{t \app \blm{u}}	&:\equiv (\flatten{t}) \app \blm{u}
\end{align*}
\end{defn}

Note that $\flatten{}$ converts all sorts in a context to be just \grm{\UU}.
If we have an inductive family and the inductive function type is not used in the
specification of sorts, it does no substantial changes, except for a renaming
of variables \grm{x} to \grm{\bar{x}}.

\begin{example}
Let \grm{\Gamma} be the code of our syntax example~\ref{ex:ttintt}.
Its flattened version looks like this:
\begin{multline*}
\grm{\cdot,\, \overline{\mathop{Con}} : \UU,\, \overline{\mathop{Ty}} : \UU,} \\
\grm{\overline{\mathop{nil}} : \overline{\mathop{Con}},} \\
\grm{\overline{\mathop{ext}} : (\bar{\Gamma} : \overline{\mathop{Con}})(\bar{A} : \overline{\mathop{Ty}}) \to \underline{\overline{\mathop{Con}}},} \\
\grm{\overline{\mathop{unit}} : (\bar{\Gamma} : \overline{\mathop{Con}}) \to \underline{\overline{\mathop{Ty}}},} \\
\grm{\overline{\mathop{pi}} : (\bar{\Gamma} : \overline{\mathop{Con}})(\bar{A} : \overline{\mathop{Ty}})(\bar{B} : \overline{\mathop{Ty}}) \to \underline{\overline{\mathop{Ty}}}}
\end{multline*} %TODO find a better way to typeset this!
\end{example}

\begin{lemma}
The operation $\flatten{}$ produces wellformed contexts in the sense that the
following rules hold true:
\begin{equation*}
\begin{gathered}
\inferrule{\grm{\vdash \Gamma}}{\grm{\vdash \flatten{\Gamma}}}
\qquad
\inferrule{\grm{\Gamma \vdash A}}{\grm{\flatten{\Gamma} \vdash \flatten{A}}}
\\
\inferrule{\grm{\Gamma \vdash t : A}}{\grm{\flatten{\Gamma} \vdash \flatten{t} : \flatten{A}}}
\end{gathered}
\end{equation*}
\end{lemma}

\begin{proof}
The only cases in which $\flatten{}$ acts neither as the identity nor
trivially by structural descent are the cases of inductive functions in the signature
of sorts and their application.

Observe first that the all sort types in $\flatten{\Gamma}$ are iterated functions
with external codomain and \grm{\UU} as their ultimate domain.
Thus, if we have \grm{\Delta, x : A \vdash \flatten{B}} for any \grm{\Delta} and \grm{B},
we also have \grm{\Delta \vdash \flatten{B}}. %TODO weniger wirr bitte

Assuming that for \grm{\Gamma \vdash a : \UU} and \grm{\Gamma, x : \underline{a} \vdash B :: k}
we have \\ \grm{\flatten{\Gamma} \vdash \flatten{a} : \flatten{\UU}}
and \grm{\flatten{\Gamma, x : \underline{a}} \vdash \flatten{B}}.
This resolves to \grm{\flatten{\Gamma} \vdash \flatten{a} : \UU} and
\grm{\flatten{\Gamma}, \bar{x}:\underline{\flatten{a}} \vdash \flatten{B}}.
Thus we have \grm{\flatten{\Gamma} \vdash \flatten{(x : a) \to B} \equiv \flatten{B}}.

For the application term assume \grm{\flatten{\Gamma} \vdash \flatten{t} : \flatten{(x : a) \to B}}
and \grm{\flatten{\Gamma} \vdash \flatten{u} : \underline{\flatten{a}}}.
We have 
\begin{align*}
\grm{\flatten{t(u)} \equiv \flatten{t} : \flatten{(x : a) \to B}} &\equiv \grm{\flatten{B}} \\
	&\equiv \grm{\flatten{B}[x \to u]} \text{,}
\end{align*}
where the last step holds since, as we have seen above, \grm{B} does not depend
on \grm{x}.
\end{proof}

\section{Wellformedness Predicates}

TODO: Define wellformedness.



\bibliographystyle{unsrtnat}
\bibliography{references}

\end{document}


